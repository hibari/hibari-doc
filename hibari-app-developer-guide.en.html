<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Hibari Application Developer’s Guide</title><link rel="stylesheet" href="./docbook-xsl.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.74.3" /></head><body><div class="article" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="id455421"></a>Hibari Application Developer’s Guide</h2></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="2"><b>Revision History</b></th></tr><tr><td align="left">Revision 0.2.1</td><td align="left">2011/03/14</td></tr></table></div></div></div><hr /></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#_introduction">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#_why_nosql">1.1. Why NOSQL?</a></span></dt><dt><span class="section"><a href="#_why_hibari">1.2. Why Hibari?</a></span></dt><dd><dl><dt><span class="section"><a href="#engineered-erlang">1.2.1. Engineered in Erlang</a></span></dt><dt><span class="section"><a href="#chain-replication">1.2.2. Chain Replication for High Availability and Strong Consistency</a></span></dt><dt><span class="section"><a href="#scalability">1.2.3. Easy, Affordable Scalability</a></span></dt><dt><span class="section"><a href="#high-performance">1.2.4. High Performance, Especially for Reads and Large Values</a></span></dt><dt><span class="section"><a href="#simple-powerful-api">1.2.5. Simple But Powerful Client API</a></span></dt><dt><span class="section"><a href="#production-proven">1.2.6. Production-Proven</a></span></dt><dt><span class="section"><a href="#hibari-benefits-by-user">1.2.7. Hibari Benefits for Developers, System Administrators, and Businesses</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#getting-started">2. Getting Started</a></span></dt><dd><dl><dt><span class="section"><a href="#system-requirements">2.1. System Requirements</a></span></dt><dt><span class="section"><a href="#required-software">2.2. Required Third-Party Software</a></span></dt><dd><dl><dt><span class="section"><a href="#_required_software_for_a_single_node_installation">2.2.1. Required Software for a Single-Node Installation</a></span></dt><dt><span class="section"><a href="#_required_software_for_a_multi_node_installation">2.2.2. Required Software for a Multi-Node Installation</a></span></dt></dl></dd><dt><span class="section"><a href="#download-hibari">2.3. Downloading Hibari</a></span></dt><dt><span class="section"><a href="#installing-single-node">2.4. Installing a Single-Node Hibari System</a></span></dt><dt><span class="section"><a href="#starting-single-node">2.5. Starting and Stopping Hibari on a Single Node</a></span></dt><dd><dl><dt><span class="section"><a href="#_starting_and_bootstrapping_hibari">2.5.1. Starting and Bootstrapping Hibari</a></span></dt><dt><span class="section"><a href="#_verifying_hibari">2.5.2. Verifying Hibari</a></span></dt><dt><span class="section"><a href="#_stopping_hibari">2.5.3. Stopping Hibari</a></span></dt></dl></dd><dt><span class="section"><a href="#installing-multi-node">2.6. Installing a Multi-Node Hibari Cluster</a></span></dt><dd><dl><dt><span class="section"><a href="#_setting_up_your_user_privileges">2.6.1. Setting Up Your User Privileges</a></span></dt><dt><span class="section"><a href="#download-cluster">2.6.2. Downloading the Cluster Installer Tool</a></span></dt><dt><span class="section"><a href="#config-cluster">2.6.3. Configuring the Cluster Installer Tool</a></span></dt><dt><span class="section"><a href="#_installing_hibari">2.6.4. Installing Hibari</a></span></dt></dl></dd><dt><span class="section"><a href="#starting-multi-node">2.7. Starting and Stopping a Multi-Node Hibari Cluster</a></span></dt><dd><dl><dt><span class="section"><a href="#_starting_and_bootstrapping_the_hibari_cluster">2.7.1. Starting and Bootstrapping the Hibari Cluster</a></span></dt><dt><span class="section"><a href="#_verifying_the_hibari_cluster">2.7.2. Verifying the Hibari Cluster</a></span></dt><dt><span class="section"><a href="#_stopping_the_hibari_cluster">2.7.3. Stopping the Hibari Cluster</a></span></dt></dl></dd><dt><span class="section"><a href="#creating-tables">2.8. Creating New Tables</a></span></dt></dl></dd><dt><span class="section"><a href="#client-api-erlang">3. Client API: Native Erlang</a></span></dt><dd><dl><dt><span class="section"><a href="#_hibari_client_api_overview">3.1. Hibari Client API Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#_erlang_basic_data_types">3.1.1. Erlang Basic Data Types</a></span></dt><dt><span class="section"><a href="#_the_hibari_data_model">3.1.2. The Hibari Data Model</a></span></dt></dl></dd><dt><span class="section"><a href="#brick-simple-add">3.2. brick_simple:add/6</a></span></dt><dt><span class="section"><a href="#brick-simple-replace">3.3. brick_simple:replace/6</a></span></dt><dt><span class="section"><a href="#brick-simple-set">3.4. brick_simple:set/6</a></span></dt><dt><span class="section"><a href="#brick-simple-get">3.5. brick_simple:get/4</a></span></dt><dt><span class="section"><a href="#brick-simple-get-many">3.6. brick_simple:get_many/5</a></span></dt><dt><span class="section"><a href="#brick-simple-delete">3.7. brick_simple:delete/4</a></span></dt><dt><span class="section"><a href="#brick-simple-do">3.8. brick_simple:do/4</a></span></dt><dt><span class="section"><a href="#brick-simple-fold-table">3.9. brick_simple:fold_table/7</a></span></dt><dt><span class="section"><a href="#brick-simple-fold-key">3.10. brick_simple:fold_key_prefix/9</a></span></dt></dl></dd><dt><span class="section"><a href="#client-api-ubf">4. Client API: UBF</a></span></dt><dd><dl><dt><span class="section"><a href="#hibari-server-impl-of-ubf-proto-stack">4.1. The Hibari Server’s Implementation of the UBF Protocol Stack</a></span></dt><dt><span class="section"><a href="#ubf-representation-of-strings">4.2. UBF representation of strings vs. binaries</a></span></dt><dt><span class="section"><a href="#using-ubf-in-any-language">4.3. Steps for Using a UBF-based Protocol in Any Language</a></span></dt><dt><span class="section"><a href="#the-hibari-ubf-protocol-contract">4.4. The Hibari UBF Protocol Contract</a></span></dt><dt><span class="section"><a href="#using-ubf-erlang-client">4.5. Using the UBF Client Library for Erlang</a></span></dt><dt><span class="section"><a href="#using-ubf-java-client">4.6. Using the UBF Client Library for Java</a></span></dt><dd><dl><dt><span class="section"><a href="#_compiling_the_ubf_client_library_for_java">4.6.1. Compiling the UBF client library for Java</a></span></dt><dt><span class="section"><a href="#_compiling_the_ubf_client_library_test_program_hibaritest_java">4.6.2. Compiling the UBF client library test program HibariTest.java</a></span></dt><dt><span class="section"><a href="#_examining_the_hibaritest_java_test_program">4.6.3. Examining the HibariTest.java test program</a></span></dt><dt><span class="section"><a href="#_the_ubf_event_handler_interface">4.6.4. The UBF event handler interface</a></span></dt></dl></dd><dt><span class="section"><a href="#using-ubf-python-client">4.7. Using the EBF Client Library for Python</a></span></dt></dl></dd><dt><span class="section"><a href="#client-api-tbf">5. Client API: Thrift</a></span></dt><dd><dl><dt><span class="section"><a href="#_the_hibari_thrift_api">5.1. The Hibari Thrift API</a></span></dt><dt><span class="section"><a href="#_mapping_ubf_contract_types_to_thrift_types">5.2. Mapping UBF Contract Types to Thrift Types</a></span></dt><dt><span class="section"><a href="#_mapping_ubf_contract_to_thrift_service">5.3. Mapping UBF Contract to Thrift Service</a></span></dt><dt><span class="section"><a href="#_examples_of_using_a_thrift_client">5.4. Examples of using a Thrift client</a></span></dt><dt><span class="section"><a href="#_mapping_tbf_contract_responses_from_thrift_client">5.5. Mapping TBF Contract Responses From Thrift Client</a></span></dt></dl></dd><dt><span class="section"><a href="#_developer_utilities">6. Developer Utilities</a></span></dt><dd><dl><dt><span class="section"><a href="#_basho_bench">6.1. Basho Bench</a></span></dt><dt><span class="section"><a href="#_yahoo_cloud_serving_benchmark">6.2. Yahoo! Cloud Serving Benchmark</a></span></dt></dl></dd><dt><span class="section"><a href="#HibariBuildingSource">7. Building Hibari from Source</a></span></dt><dd><dl><dt><span class="section"><a href="#_required_third_party_software">7.1. Required Third Party Software</a></span></dt><dd><dl><dt><span class="section"><a href="#_mandatory_items_required_for_building_hibari">7.1.1. Mandatory Items (Required for Building Hibari)</a></span></dt><dt><span class="section"><a href="#_optional_items_required_for_building_hibari_8217_s_documentation">7.1.2. Optional Items (Required for Building Hibari’s Documentation)</a></span></dt></dl></dd><dt><span class="section"><a href="#_downloading_hibari">7.2. Downloading Hibari</a></span></dt><dt><span class="section"><a href="#_building_the_hibari_release_package">7.3. Building the Hibari Release Package</a></span></dt><dt><span class="section"><a href="#HibariAsciiDoc">7.4. Building Hibari’s Documentation</a></span></dt><dt><span class="section"><a href="#ErlangOTP">7.5. Building and Installing Erlang/OTP</a></span></dt></dl></dd><dt><span class="section"><a href="#_sample_application">8. Sample Application</a></span></dt><dt><span class="section"><a href="#_contributing_to_hibari">9. Contributing to Hibari</a></span></dt><dd><dl><dt><span class="section"><a href="#_github_git_and_repo">9.1. GitHub, Git, and Repo</a></span></dt><dt><span class="section"><a href="#_code_branch_and_version_management">9.2. Code, Branch, and Version Management</a></span></dt><dt><span class="section"><a href="#_documentation">9.3. Documentation</a></span></dt><dt><span class="section"><a href="#_submitting_patches">9.4. Submitting Patches</a></span></dt></dl></dd></dl></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_introduction"></a>1. Introduction</h2></div></div></div><p>Hibari is a production-ready, distributed, key-value, big data
store. In the emerging field of "NOSQL" solutions to today’s
mass-scale data storage challenges, Hibari stands out for several
reasons:</p><div class="itemizedlist"><ul type="disc"><li>
Hibari is the <span class="strong"><strong>only open source key-value database to couple Erlang
  engineering with innovative chain replication technology</strong></span>. Erlang is
  the ideal programming foundation on which to build a robust,
  high-performance distributed storage solution. Chain replication
  delivers high throughput and availability without sacrificing data
  consistency.
</li><li>
Hibari is the <span class="strong"><strong>only open source KVDB built to the exacting standards
  of the carrier-class telecom sector</strong></span>, and proven in multi-million
  user telecom production environments.
</li><li><p>
Hibari delivers a <span class="strong"><strong>distinctive feature matrix</strong></span> that includes:
</p><div class="itemizedlist"><ul type="circle"><li>
Per-table options for disk-based or RAM-only value storage
</li><li>
Support for per-key expiration times and per-key custom meta-data
</li><li>
Support for multi-key atomic transactions, within range limits
</li><li>
A key timestamping mechanism that facilitates "test-and-set" type operations
</li><li>
Automatic data rebalancing as the system scales
</li><li>
Support for live code upgrades
</li><li>
Multiple client API implementations
</li></ul></div></li></ul></div><p>This introductory chapter will briefly address the recent emergence of
NOSQL solutions to the challenges posed by the "Big Data" era before
turning to describe more fully the distinctive benefits that Hibari
provides to developers, administrators, and users of data-intensive
applications.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_why_nosql"></a>1.1. Why NOSQL?</h3></div></div></div><p>The NOSQL "movement" is, first off, not an outright rejection of
traditional relational database management systems (RDBMS) but rather
a growing recognition that today’s data environment requires a diverse
storage toolset that is "Not Only SQL (NOSQL)". Relational and NOSQL
data storage solutions should be viewed as complements, with each
approach better suited toward different types of applications and
services.</p><p>The main driver of NOSQL has been the proliferation of applications
and services that must store and serve terabytes or petabytes of data,
often while striving to guarantee "always-on" availability and low
latencies for end users. Organizations in many market sectors are
grappling with the advent of Big Data, including but not limited to:</p><div class="itemizedlist"><ul type="disc"><li>
Web properties — coping with the massive data requirements of
  search, e-commerce, social media, and user-generated content.
</li><li>
Telecoms — managing and analyzing network logs and call data
  records for multi-millions of subscribers.
</li><li>
Utilities — managing and analyzing the enormous data volume
  associated with smart grids.
</li><li>
Financial services — storing and mining customer history data in
  order to analyze and model risk.
</li><li>
Retail analytics — click-stream analysis and micro-targeting.
</li><li>
Biotech — genome analysis.
</li></ul></div><p>Organizations in these and other data-intensive environments have been
challenged to build data storage systems of unprecedented scale. Many
such organizations have found their needs ill-met by traditional data
storage approaches that center around relational database management
systems and specialized high-end hardware. In particular:</p><div class="itemizedlist"><ul type="disc"><li>
"Scaling up" a single RDBMS instance doesn’t achieve nearly the
  scale required, no matter how high-end the systems or how great the
  expenditure.
</li><li>
"Scaling out" by sharding the system over multiple RDBMS instances
  entails enormous costs and enormous operational complexity, while at
  the same time forfeiting much of the power of the relational model.
</li></ul></div><p>Wanting Big Data capacity without crippling cost and complexity, some
innovative organizations have sought a better way to scale. At the
same time, with an ever-expanding array of data usage scenarios, it’s
become apparent that not all scenarios require the complex querying
and management functionality associated with an RDBMS. For some
applications and services, SQL-structuring and strict ACID properties
are overkill. Worse, in some environments they’re expensive overkill
that can potentially hamstring service offerings in highly competitive
markets that demand flexibility and responsiveness.</p><p>In short, recent years have seen a proliferation of services that
require more data, with less structure.</p><p>Not surprisingly, some of the leading web enterprises have been at the
forefront of the NOSQL movement. In particular, Google with its
<a class="ulink" href="http://labs.google.com/papers/bigtable.html" target="_top">BigTable paper</a> in 2006
and Amazon with its
<a class="ulink" href="http://s3.amazonaws.com/AllThingsDistributed/sosp/amazon-dynamo-sosp2007.pdf" target="_top">Dynamopaper</a>
in 2007 had a profound effect on the NOSQL market. A number of NOSQL
solutions have drawn inspiration from either BigTable or Dynamo or
both, and in the past couple years several solutions have been
released into the open source community.</p><p>While NOSQL data storage solutions vary in their particulars, they
have these basic traits in common:</p><div class="itemizedlist"><ul type="disc"><li>
A simplified data model. Data models vary across specific solutions,
  and sometimes form the basis of a tripartite classification of NOSQL
  systems into 1) key-value data stores (such as Dynamo and Hibari);
  2) column-oriented data stores (such as BigTable); and 3)
  document-oriented data stores (such as CouchDB). All variants,
  however, are simpler and more flexible in data model than the
  traditional RDBMS. That simplification tends to carry over to client
  APIs as well.
</li><li>
Distribution across multiple nodes based on commodity
  PCs. Affordable Big Data capacity is achieved by scaling out across
  tens, hundreds, or even thousands of commodity PCs. Data
  partitioning schemes coupled with parallel processing of incoming
  requests deliver the needed high performance.
</li><li>
Replication of data objects across multiple nodes, to ensure high
  availability in the event of component failures.
</li></ul></div><p>For much more on the history, merits, and design issues associated
with NOSQL storage solutions, consult with your favorite search
engine.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_why_hibari"></a>1.2. Why Hibari?</h3></div></div></div><p>Hibari was developed internally by Gemini Mobile Technologies, a
leading producer of mass-scale messaging and transaction systems for
Tier 1 mobile operators in Asia, Europe, and the Americas. Gemini had
need for a data store that was efficient, fast, flexible, and
scalable, as well as robust enough to withstand the rigors of
deployment in Tier 1 telecom production environments. Dissatisfied
with the then-available options, Gemini in 2005 began work on what
came to be Hibari (the name is Japanese for skylark; the kanji
characters stand for "cloud bird"). With the system having in recent
years matured and been proven in production, Gemini released Hibari to
the open source community in July 2010 under the Apache 2.0
license. Gemini regards the open source community as the best venue in
which Hibari can continue to perfect and grow.</p><p>This section describes some of the distinctive features that make
Hibari a very attractive option for businesses and developers seeking
a modern Big Data storage system:</p><div class="itemizedlist"><ul type="disc"><li>
<a class="ulink" href="#engineered-erlang" target="_top">Engineered in Erlang</a>
</li><li>
<a class="ulink" href="#chain-replication" target="_top">Chain Replication for High Availability and Strong Consistency</a>
</li><li>
<a class="ulink" href="#scalability" target="_top">Easy, Affordable Scalability</a>
</li><li>
<a class="ulink" href="#high-performance" target="_top">High Performance, Especially for Reads and Large Values</a>
</li><li>
<a class="ulink" href="#simple-powerful-api" target="_top">Simple But Powerful Client API</a>
</li><li>
<a class="ulink" href="#production-proven" target="_top">Production-Proven</a>
</li><li>
<a class="ulink" href="#hibari-benefits-by-user" target="_top">Hibari Benefits for Developers, System Administrators, and Businesses</a>
</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="engineered-erlang"></a>1.2.1. Engineered in Erlang</h4></div></div></div><p>Erlang is a general purpose programming language and runtime
environment designed specifically to support reliable,
high-performance distributed systems. Originally developed by Ericsson
in the 1980s for building advanced telecom networking systems,
Erlang/OTP (Open Telecom Platform) was open-sourced in 1998. Hibari is
written entirely in Erlang.</p><p>Erlang provides a range of benefits that make it the ideal foundation
for a distributed key-value storage solution:</p><div class="itemizedlist"><ul type="disc"><li>
<span class="strong"><strong>Concurrency</strong></span>. Erlang has extremely lightweight processes that
   communicate by message passing and have no shared
   memory. Scheduling, memory management, and other
   concurrency-related services are managed by the Erlang VM, placing
   no requirements for concurrency on the host operating system.
</li><li>
<span class="strong"><strong>Distribution</strong></span>. Erlang is designed specifically for distributed
   environments. Passing messages transparently via TCP, Erlang
   processes on different nodes communicate with each other in exactly
   the same way as do processes on the same node. The simple and
   efficient design facilitates massive parallelism and scalability of
   the sort required by a high-performance distributed storage
   system. With its prowess for concurrency and distributed
   processing, it has been suggested that Erlang can be regarded as a
   first-of-its-kind
   <a class="ulink" href="http://www.oreillygmt.eu/open-sourcefree-software/erlang-the-ceos-view/" target="_top">"application
   system"</a>, analogous to an operating system except running across
   and coordinating multiple hosts.
</li><li>
<span class="strong"><strong>Robustness</strong></span>. Erlang processes are completely independent of each
   other, with no data sharing. While functionally isolated, Erlang
   processes are able to monitor each other and to detect and respond
   to crashed processes, even on remote nodes.
</li><li>
<span class="strong"><strong>Portability</strong></span>. The same Erlang VM can run on Linux, Unix, Windows,
   Macintosh, or VxWorks. Distributed Erlang processes can seamlessly
   communicate with each other regardless of the heterogeneity of
   their host operating systems. This OS portability is a valuable
   facilitator of storage system elasticity, as system managers may
   need to mix and match hosts in response to fluid demand
   environments.
</li><li>
<span class="strong"><strong>Hot code upgrades</strong></span>. Erlang-based applications like Hibari support
   hot code upgrades: upgrades can be applied without shutting down
   the system. During the change-over, old and new code can run
   simultaneously. This is a key benefit for environments that require
   "always-on" availability for end users.
</li></ul></div><p>Other features reinforce Erlang’s suitability for reliable distributed
applications, including incremental garbage collection,
single-assignment variables, and robust exception handling.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="chain-replication"></a>1.2.2. Chain Replication for High Availability and Strong Consistency</h4></div></div></div><p>The Hibari distributed key-value store implements a version of the
chain replication methodology first proposed by
<a class="ulink" href="http://www.usenix.org/event/osdi04/tech/full_papers/renesse/renesse.pdf" target="_top">van
Renesse and Schneider</a> to achieve redundancy and high availability
without sacrificing data consistency. At a high level, chain
replication in a Hibari storage cluster works as follows:</p><div class="itemizedlist"><ul type="disc"><li>
Through consistent hashing, the key space is divided across multiple
  storage "chains".
</li><li>
Each chain is composed of multiple logical storage "bricks", with
  each brick running in its own Erlang VM instance.
</li><li>
Within each chain, the member bricks have differentiated
  roles. Client-requested updates to key-value pairs are written first
  to the "head" brick, then automatically replicated downstream to one
  or more "middle" bricks and finally to the "tail" brick, which
  returns an update acknowledgement to the client. By contrast, read
  requests are directed to the tail brick, which returns the response
  to the client.
</li></ul></div><p><span class="inlinemediaobject"><img src="images/chain_replication.png" alt="images/chain_replication.png" /></span></p><p>While most distributed storage systems are able to guarantee only weak
or eventual data consistency across replicas — placing the burden on
the client application (and the client application developer) to
manage the potential inconsistencies — Hibari with its chain
replication implementation guarantees strong consistency. Data updates
are considered complete, and are acknowledged to clients, only when
they have replicated through the chain to the tail; and read requests
are processed only by the tail. Consequently, after an object update
is acknowledged to a Hibari client, other clients are guaranteed to
see only the newest version of that object. This strong consistency is
valuable in environments where <span class="emphasis"><em>eventual consistency</em></span> is at odds with
the service level expected by end users, or where system designers do
not want to clutter client applications with the logic required to
manage data inconsistency.</p><p>The "length" of a chain is configurable and can be based on your
desired degree of replication and redundancy. For example, a chain of
length four would have a head brick, two middle bricks, and a tail
brick; while a three-brick chain would have a head, one middle, and a
tail. A chain can also operate at length two (a head and tail, with no
middle) and even at length one (one brick playing both the head role
and the tail role).</p><p>Because chains can operate at any length, and because the system is
able to detect failures within the chain and to adjust member brick
roles accordingly, Hibari delivers high availability as well as strong
data consistency. For example, if in a three-brick chain the head
brick goes down, the middle brick automatically takes over the head
brick role, allowing the chain to continue functioning normally:</p><p><span class="inlinemediaobject"><img src="images/automatic_failover.png" alt="images/automatic_failover.png" /></span></p><p>If the new head brick failed also, the lone remaining brick would then
play both the head role and the tail role, processing all writes and
reads itself as a single-brick "chain".</p><p>While multiple logical bricks can run on a single physical node, for
high availability it is of course desirable that a particular chain’s
member bricks be deployed on separate machines. If you want to run
multiple bricks per machine and also ensure high availability for each
chain, an attractive deployment option is to "stripe" the chains
across machines:</p><p><span class="inlinemediaobject"><img src="images/load_balanced_chains.png" alt="images/load_balanced_chains.png" /></span></p><p>Note also that because head bricks (receiving incoming write requests)
and tail bricks (replying to write requests and processing read
requests) bear more load than do middle bricks, load balancing across
machines can be achieved in part by allocating the different brick
roles evenly, as in the diagram above.</p><p>In the event of a physical node failure, bricks within each impacted
chain automatically shift roles, and each chain continues to provide
normal service to clients:</p><p><span class="inlinemediaobject"><img src="images/automatic_failover_2.png" alt="images/automatic_failover_2.png" /></span></p><p>For further information about chain replication, fail-over, and
recovery in a Hibari storage system, and for information about
Hibari’s redundantly structured cluster membership application called
the Admin Server, see these sections of the Hibari System
Administrator’s Guide:</p><div class="itemizedlist"><ul type="disc"><li>
<a class="ulink" href="hibari-sysadmin-guide.en.html#hibari-architecture" target="_top">Hibari Architecture</a>
</li><li>
<a class="ulink" href="hibari-sysadmin-guide.en.html#life-of-brick" target="_top">The Life of a (Logical) Brick</a>
</li><li>
<a class="ulink" href="hibari-sysadmin-guide.en.html#dynamic-cluster-reconfiguration" target="_top">Dynamic Cluster Reconfiguration</a>
</li><li>
<a class="ulink" href="hibari-sysadmin-guide.en.html#admin-server-app" target="_top">The Admin Server Application</a>
</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="scalability"></a>1.2.3. Easy, Affordable Scalability</h4></div></div></div><p>Hibari provides Big Data scalability while minimizing the cost and
operational complexity of cluster growth:</p><div class="itemizedlist"><ul type="disc"><li>
Hibari scales horizontally by the addition of more chains, deployed
  on more physical nodes. The total storage and processing capacity of
  a Hibari cluster increases linearly as machines are added to the
  cluster.
</li><li>
The system rebalances data storage distribution automatically as
  chains are added to (or removed from) the cluster, with no
  downtime. You can grow (or shrink) your Hibari storage cluster with
  no service interruption.
</li><li>
Hibari runs on commodity PCs. Further, the system easily
  accommodates heterogeneous hardware resources. Bricks within the
  storage cluster can have different RAM and disk sizes, and different
  CPU speeds. You can tune Hibari’s consistent hash function to
  optimize your cluster’s utilization of mixed hardware. Each chain
  can be assigned a weighting factor that will increase or decrease
  that chain’s portion of the overall key space, relative to other
  chains.
</li></ul></div><p>In addition to supporting mixed hardware, Erlang-based Hibari can run
on most any OS. With its easy adaptability to disparate hardware and
operating systems, you can scale Hibari incrementally, with whatever
resources you have available. It’s not necessary to buy all your
resources at once, or all of the same kind.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The outer limits of Hibari’s horizontal scalability have not
been definitely determined, but 200 to 250 nodes is a practical
boundary due to the limitations of Erlang’s built-in network
distribution implementation. Also, while Hibari chains could
theoretically be stretched across multiple data centers to provide
geographic redundancy, to date only single data center deployments
have been tested and used in production.</p></td></tr></table></div><p>For further information on resizing a Hibari cluster, see
<a class="ulink" href="hibari-sysadmin-guide.en.html#dynamic-cluster-reconfiguration" target="_top">Dynamic
Cluster Reconfiguration</a> in the Hibari System Administrator’s Guide.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="high-performance"></a>1.2.4. High Performance, Especially for Reads and Large Values</h4></div></div></div><p>Several features work in combination to drive high performance in a
Hibari storage cluster, even at Big Data scale:</p><div class="itemizedlist"><ul type="disc"><li>
The Erlang technology that underlies Hibari was specifically
  designed for and excels at distributed parallel processing.
</li><li>
Hibari’s implementation of consistent hashing and chain replication
  partitions the key-space across multiple chains, enabling parallel
  simultaneous processing of requests incoming to individual
  chains. The distribution of data across chains is tunable to allow
  optimal utilization of heterogeneous hardware resources.
</li><li>
Hibari’s chain replication implementation further aids performance
  by assigning storage bricks differentiated processing roles as head,
  middle, or tail. This division of labor particularly benefits read
  performance, as read requests are processed by "tail" bricks that do
  not bear the load of initial processing of write requests (since
  that work is done by "head" bricks).
</li><li>
Hibari supports a number of performance-tuning options on a
  per-table basis. For example, while some distributed KVDBs support
  only disk-based storage or only RAM-based storage of value blobs,
  Hibari lets you choose disk-based or RAM-based storage on a
  per-table basis, depending on your application needs. Whichever
  storage option you choose, all data changes are logged to disk to
  ensure data durability in the event of power failures. A batch
  commit technique is used to minimize disk I/O.
</li></ul></div><p>Leveraging this feature set, Hibari is able to deliver scalable high
performance that is competitive with leading open source NOSQL storage
systems, while also providing the data durability and strong
consistency that many systems lack. Hibari’s performance relative to
other NOSQL systems is particularly strong for reads and for large
value (&gt; 200KB) operations. Hibari’s consistently high performance
even for large values distinguishes the system from solutions that are
tailored toward small value operations.</p><p>As one example of real-world performance, in a multi-million user
webmail deployment Hibari is processing about 2200 transactions per
second, with read latencies averaging between 1 and 20 milliseconds
and write latencies averaging between 20 and 80 milliseconds.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="simple-powerful-api"></a>1.2.5. Simple But Powerful Client API</h4></div></div></div><p>As a key-value store, Hibari’s core data model and client API model
are simple by design: blob-based key-value pairs can be inserted,
retrieved, and deleted from lexicographically sorted tables. While
Hibari thus provides the flexibility and scalability associated with
key-value stores, the system also provides distinctive features that
enhance the power of client applications and developers:</p><div class="itemizedlist"><ul type="disc"><li>
Clients can optionally assign per-object expiration times.
</li><li>
Clients can optionally assign per-object custom flags. This
  flexible, custom meta-data can be updated with or without updating
  the associated value blob, and can be retrieved with or without the
  value blob.
</li><li>
Objects are automatically timestamped each time they are
  updated. This timestamping mechanism facilitates "test-and-set" type
  operations: clients can specify that a requested operation be
  performed only if the target key’s timestamp matches the client’s
  expectations.
</li><li>
Within key-prefix range limits (specifically, within individual
  chains but not across chains), Hibari’s client API supports atomic
  transactions. This support for "micro-transactions" sets Hibari
  apart from other open source KVDBs and can greatly simplify the
  creation of robust client applications.
</li></ul></div><p>Hibari supports multiple client API implementations including:</p><div class="itemizedlist"><ul type="disc"><li>
Native Erlang
</li><li>
Universal Binary Format (UBF)
</li><li>
Thrift
</li><li>
Amazon S3
</li><li>
JSON-RPC
</li></ul></div><p>You can develop Hibari client applications in a variety of languages
including Java, C/C++, Python, Ruby, and Erlang.</p><p>For further information about Hibari’s client API, see
<a class="ulink" href="#client-api-erlang" target="_top">Client API: Native Erlang</a> and the subsequent
client API chapters in this guide.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="production-proven"></a>1.2.6. Production-Proven</h4></div></div></div><p>While initial development work on Hibari was geared generally toward
the data storage demands of the Tier 1 telecom sector, as the system
evolved it needed to meet the requirements of a particular major Asian
carrier that wished to launch a GB webmail service. This customer’s
requirements for Hibari included the following:</p><div class="itemizedlist"><ul type="disc"><li>
Several million users from the start.
</li><li>
Several billion stored messages within a few months of launch.
</li><li>
Hundreds of TB storage capacity.
</li><li>
Elasticity to support continual growth.
</li><li>
Low system costs, particularly since the service would employ the
  "freemium" model.
</li><li>
Individual messages could range in size from a few bytes to many MB
  with attachments.
</li><li>
Support for per-object meta-data required.
</li><li>
Strong consistency required, for interactive sessions.
</li><li>
Data durability required — loss of messages or meta-data unacceptable.
</li><li>
High availability — an "always on", branded service.
</li><li>
Low latency, with &lt; 1 second response times for end user transactions.
</li></ul></div><p>Hibari was built to meet these rigorous requirements, was hardened
through extensive testing and trials, and went live in support of this
large-scale webmail system at the beginning of 2010. The system now
stores billions of messages on behalf of millions of end users, while
meeting customer requirements for availability, latency, consistency,
durability, and affordability.</p><p>Coinciding with Hibari’s development and fine tuning for this GB
webmail service, the system was also deployed as a storage solution
for two major Asian carriers' mobile social networking services. In
this context, Hibari stores user profile data as well as digital goods
of varying types and sizes.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="hibari-benefits-by-user"></a>1.2.7. Hibari Benefits for Developers, System Administrators, and Businesses</h4></div></div></div><p>For application developers, Hibari offers a distinctive set of
benefits not often found in distributed key-value stores:</p><div class="itemizedlist"><ul type="disc"><li>
Strong data consistency guarantees that relieve client applications
  of the burden of managing potential inconsistencies.
</li><li>
Micro-transaction support that simplifies the creation of powerful
  applications.
</li><li>
Per-object custom flags that facilitate flexible, service-specific
  application design.
</li><li>
Support for a variety of API implementations and development
  languages.
</li></ul></div><p>For system administrators, Hibari provides valuable operational
automations that simplify data management in a dynamic storage
environment:</p><div class="itemizedlist"><ul type="disc"><li>
Automatic data replication.
</li><li>
Automatic failover when a node goes down.
</li><li>
Automatic repair when a failed node comes back up.
</li><li>
Automatic rebalancing of data as a cluster grows or shrinks.
</li></ul></div><p>For businesses as a whole, Hibari offers affordable Big Data
scalability while delivering the high availability and low latencies
that service users demand. Hibari is an appropriate storage solution
for a range of data-intensive service scenarios including but not
limited to large-scale messaging, social media, and archiving. Hibari
offers particular value in environments that require strong data
consistency and/or high performance across a variety of object types
and sizes.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="getting-started"></a>2. Getting Started</h2></div></div></div><p>This section covers the following topics to help you get up and
running with Hibari:</p><div class="itemizedlist"><ul type="disc"><li>
<a class="ulink" href="#system-requirements" target="_top">System Requirements</a>
</li><li>
<a class="ulink" href="#required-software" target="_top">Required Third Party Software</a>
</li><li>
<a class="ulink" href="#download-hibari" target="_top">Downloading Hibari</a>
</li><li>
<a class="ulink" href="#installing-single-node" target="_top">Installing a Single-Node Hibari System</a>
</li><li>
<a class="ulink" href="#starting-single-node" target="_top">Starting and Stopping a Single-Node Hibari System</a>
</li><li>
<a class="ulink" href="#installing-multi-node" target="_top">Installing a Multi-Node Hibari Cluster</a>
</li><li>
<a class="ulink" href="#starting-multi-node" target="_top">Starting and Stopping a Multi-Node Hibari Cluster</a>
</li><li>
<a class="ulink" href="#creating-tables" target="_top">Creating New Tables</a>
</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="system-requirements"></a>2.1. System Requirements</h3></div></div></div><p>Hibari will run on any OS that the Erlang VM supports, which includes
most Unix and Unix-like systems, Windows, and Mac OS X. See
<a class="ulink" href="http://www.erlang.org/faq/implementations.html" target="_top">Implementation and
Ports of Erlang</a> from the official Erlang documentation for further
information.</p><p>For guidance on hardware requirements in a production environment, see
<a class="ulink" href="hibari-sysadmin-guide.en.html#brick-hardware" target="_top">Notes on Brick
Hardware</a> in the Hibari System Administrator’s Guide.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="required-software"></a>2.2. Required Third-Party Software</h3></div></div></div><p>Hibari’s requirements for third party software depend on whether
you’re doing a single-node installation or a multi-node installation.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_required_software_for_a_single_node_installation"></a>2.2.1. Required Software for a Single-Node Installation</h4></div></div></div><p>The node on which you plan to install Hibari must have the following software:</p><div class="itemizedlist"><ul type="disc"><li><p>
OpenSSL - <a class="ulink" href="http://www.openssl.org/" target="_top">http://www.openssl.org/</a>
</p><div class="itemizedlist"><ul type="circle"><li>
Required for Erlang’s "crypto" module
</li></ul></div></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_required_software_for_a_multi_node_installation"></a>2.2.2. Required Software for a Multi-Node Installation</h4></div></div></div><p>When you install Hibari on multiple nodes you will use an installer
tool that simplifies the cluster set-up process. When you use this
tool you will identify the hosts on which you want Hibari to be
installed, and the tool will manage the installation of Hibari onto
those target hosts. You can run the tool itself from one of your
target Hibari nodes or from a different machine. There are distinct
requirements for third party software on the "installer node" (the
machine from which you run the installer tool) and on the Hibari nodes
(the machines on which Hibari will be installed and run.)</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="_installer_node_required_software"></a>2.2.2.1. Installer Node Required Software</h5></div></div></div><p>The installer node must have the software listed below. If you are
missing any of these items, you can use the provided links for
downloads and installation instructions.</p><div class="itemizedlist"><ul type="disc"><li>
Bash - <a class="ulink" href="http://www.gnu.org/software/bash/" target="_top">http://www.gnu.org/software/bash/</a>
</li><li>
Expect - <a class="ulink" href="http://www.nist.gov/el/msid/expect.cfm" target="_top">http://www.nist.gov/el/msid/expect.cfm</a>
</li><li>
Perl - <a class="ulink" href="http://www.perl.org/" target="_top">http://www.perl.org/</a>
</li><li>
SSH (client) - <a class="ulink" href="http://www.openssh.com/" target="_top">http://www.openssh.com/</a>
</li><li><p>
Git - <a class="ulink" href="http://git-scm.com/" target="_top">http://git-scm.com/</a>
</p><div class="itemizedlist"><ul type="circle"><li>
Must be version 1.5.4 or newer
</li><li><p>
If you haven’t yet done so, please configure your email address
    and name for Git:
</p><pre class="screen">$ git config --global user.email "you@example.com"
$ git config --global user.name "Your Name"</pre></li><li>
If you haven’t yet done so, you must sign up for a GitHub account -
   <a class="ulink" href="https://github.com/" target="_top">https://github.com/</a>
</li></ul></div></li></ul></div><p>There are currently no known version requirements for Bash, Expect,
Perl, or SSH.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="_hibari_nodes_required_software"></a>2.2.2.2. Hibari Nodes Required Software</h5></div></div></div><p>The nodes on which you plan to install Hibari must have the software
listed below.</p><div class="itemizedlist"><ul type="disc"><li>
SSH (server) - <a class="ulink" href="http://www.openssh.com/" target="_top">http://www.openssh.com/</a>
</li><li><p>
OpenSSL - <a class="ulink" href="http://www.openssl.org/" target="_top">http://www.openssl.org/</a>
</p><div class="itemizedlist"><ul type="circle"><li>
Required for Erlang’s "crypto" module
</li></ul></div></li></ul></div></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="download-hibari"></a>2.3. Downloading Hibari</h3></div></div></div><p>Hibari is not yet available as a pre-built release. In the meanwhile,
you can build Hibari from source. Follow the instructions in
<a class="xref" href="#HibariBuildingSource" title="7. Building Hibari from Source">Section 7, “Building Hibari from Source”</a>, and then return to this section to continue
the set-up process.</p><p>When you build Hibari your output is two files that you will later use
in the set-up process:</p><div class="itemizedlist"><ul type="disc"><li>
A tarball package "hibari-<span class="emphasis"><em>X.Y.Z-DIST-ARCH-WORDSIZE</em></span>.tgz"
</li><li>
An md5sum file "hibari-<span class="emphasis"><em>X.Y.Z-DIST-ARCH-WORDSIZE</em></span>-md5sum.txt"
</li></ul></div><p><span class="emphasis"><em>X.Y.Z</em></span> is the release version, <span class="emphasis"><em>DIST</em></span> is the release distribution,
<span class="emphasis"><em>ARCH</em></span> is the release architecture, and <span class="emphasis"><em>WORDSIZE</em></span> is the release
wordsize.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="installing-single-node"></a>2.4. Installing a Single-Node Hibari System</h3></div></div></div><p>A single-node Hibari system will not provide data replication and
redundancy in the way that a multi-node Hibari cluster will. However,
you may wish to deploy a simple single-node Hibari system for testing
and development purposes.</p><div class="orderedlist"><ol type="1"><li><p>
Create a directory for running Hibari:
</p><pre class="screen">$ mkdir running-directory</pre></li><li><p>
Untar the Hibari tarball package that you created when you built
  Hibari from source:
</p><pre class="screen">$ tar -C running-directory -xvf hibari-X.Y.Z-DIST-ARCH-WORDSIZE.tgz</pre></li></ol></div><div class="important" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./images/icons/important.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>On your Hibari node, in the system’s <code class="literal">/etc/sysctl.conf</code> file,
set <code class="literal">vm.swappiness=0</code>. Swappiness is not desirable for an Erlang VM.</p></td></tr></table></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="starting-single-node"></a>2.5. Starting and Stopping Hibari on a Single Node</h3></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_starting_and_bootstrapping_hibari"></a>2.5.1. Starting and Bootstrapping Hibari</h4></div></div></div><div class="orderedlist"><ol type="1"><li><p>
Start Hibari:
</p><pre class="screen">$ running-directory/hibari/bin/hibari start</pre></li><li><p>
If this is the first time you’ve started Hibari, bootstrap the system:
</p><pre class="screen">$ running-directory/hibari/bin/hibari-admin bootstrap</pre><p>The Hibari bootstrap process starts Hibari’s Admin Server on the
single node and creates a single table "tab1" serving as Hibari’s
default table. For information on creating additional tables, see
<a class="ulink" href="#creating-tables" target="_top">Creating New Tables</a>.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_verifying_hibari"></a>2.5.2. Verifying Hibari</h4></div></div></div><p>Do these quick checks to verify that your single-node Hibari system is
up and running.</p><div class="orderedlist"><ol type="1"><li><p>
Confirm that you can open the "Hibari Web Administration" page:
</p><pre class="screen">$ your-favorite-browser http://127.0.0.1:23080</pre></li><li><p>
Confirm that you can successfully ping the Hibari node:
</p><pre class="screen">$ running-directory-name/hibari/bin/hibari ping</pre></li></ol></div><div class="important" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./images/icons/important.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>A single-node Hibari system is hard-coded to listen on the
localhost address 127.0.0.1. Consequently the Hibari node is reachable
only from the node itself.</p></td></tr></table></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_stopping_hibari"></a>2.5.3. Stopping Hibari</h4></div></div></div><p>To stop Hibari:</p><pre class="screen">$ running-directory/hibari/bin/hibari stop</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="installing-multi-node"></a>2.6. Installing a Multi-Node Hibari Cluster</h3></div></div></div><p>Before you install Hibari on to the target nodes you must complete
these preparation steps:</p><div class="itemizedlist"><ul type="disc"><li>
Set up required user privileges on the installer node and on the
  target Hibari nodes.
</li><li>
Download the Cluster installer tool.
</li><li>
Configure the Cluster installer tool.
</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_setting_up_your_user_privileges"></a>2.6.1. Setting Up Your User Privileges</h4></div></div></div><p>The system user ID that you use to perform the installation must be
different than the Hibari runtime user. Your installing user account
($USER) must be set up as follows:</p><div class="itemizedlist"><ul type="disc"><li>
$USER must exist on the installer node and also on the target Hibari
  nodes.
</li><li>
$USER on the installer node must have SSH private/public keys, with
  the SSH agent set up to enable password-less SSH login.
</li><li>
$USER account must be accessible with password-less SSH login on the
  target Hibari nodes.
</li><li>
$USER must have password-less sudo access on the target Hibari
  nodes.
</li></ul></div><p>If your installing user account does not currently have the above
privileges, follow these steps:</p><div class="orderedlist"><ol type="1"><li><p>
As the root user, add your installing user ($USER) to the installer
  node. Then on each of the Hibari nodes, add your installing user and
  grant your user password-less sudo access:
</p><pre class="screen">$ useradd $USER
$ passwd $USER
$ visudo
# append the following line and save it
$USER  ALL=(ALL)       NOPASSWD: ALL</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>If you get a "sudo: sorry, you must have a tty to run sudo"
error while testing sudo, try commenting out following line inside of
the <code class="literal">/etc/sudoers</code> file:</p></td></tr></table></div><pre class="screen">$ visudo
Defaults    requiretty</pre></li><li><p>
On the installer node, create a new SSH private/public key for your
  installing user:
</p><pre class="screen">$ ssh-keygen
# enter your password for the private key
$ eval `ssh-agent`
$ ssh-add ~/.ssh/id_rsa
# re-enter your password for the private key</pre></li><li><p>
On each of the Hibari nodes:
</p><div class="itemizedlist"><ul type="disc"><li>
Append an entry for the installer node to the <code class="literal">\~/.ssh/known_hosts</code>
  file.
</li><li><p>
Append an entry for your public SSH key to the
  <code class="literal">~/.ssh/authorized_keys</code> file.
</p><p>In the example below, the target Hibari nodes are dev1, dev2, and
dev3:</p><pre class="screen">$ ssh-copy-id -i ~/.ssh/id_rsa.pub $USER@dev1
$ ssh-copy-id -i ~/.ssh/id_rsa.pub $USER@dev2
$ ssh-copy-id -i ~/.ssh/id_rsa.pub $USER@dev3</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>If your installer node will be one of the Hibari cluster nodes,
make sure that you ssh-copy-id to the installer node also.</p></td></tr></table></div></li></ul></div></li><li><p>
Confirm that password-less SSH access to the each of the Hibari
  nodes works as expected.
</p><pre class="screen">$ ssh $USER@dev1
$ ssh $USER@dev2
$ ssh $USER@dev3</pre></li></ol></div><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>If you need more help with SSH set-up, check
<a class="ulink" href="http://inside.mines.edu/~gmurray/HowTo/sshNotes.html" target="_top">http://inside.mines.edu/~gmurray/HowTo/sshNotes.html</a>.</p></td></tr></table></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="download-cluster"></a>2.6.2. Downloading the Cluster Installer Tool</h4></div></div></div><p>"Cluster" is a simple tool for installing, configuring, and
bootstrapping a cluster of Hibari nodes. The tool is not part of the
Hibari package itself, but is available from GitHub.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The Cluster tool should meet the needs of most users.  However,
this tool’s "target node" recipe is currently Linux-centric
(e.g. useradd, userdel, …).  Patches and contributions for other OS
and platforms are welcome.  For non-Linux deployments, the Cluster
tool is rather simple so installation can be done manually by
following the tool’s recipe.</p></td></tr></table></div><div class="orderedlist"><ol type="1"><li><p>
Create a working directory into which you will download the Cluster
  installer tool:
</p><pre class="screen">$ mkdir working-directory</pre></li><li><p>
Download the Cluster tool’s Git repository from GitHub:
</p><pre class="screen">$ cd working-directory
$ git clone git://github.com/hibari/clus.git</pre><p>The download creates a sub-directory <code class="literal">clus</code> under which the installer
tool and various supporting files are stored.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="config-cluster"></a>2.6.3. Configuring the Cluster Installer Tool</h4></div></div></div><p>The Cluster tool requires some basic configuration information that
indicates how you want your Hibari cluster to be set up. You will
create a simple text file that specifies your desired configuration,
and then later use the file as input when you run the Cluster tool.</p><p>It’s simplest to create the file in the same working directory in
which you downloaded the cluster tool. You can give the file any name
that you want; for purposes of these instructions we will use the file
name <code class="literal">hibari.config</code>.</p><p>Below is a sample <code class="literal">hibari.config</code> file. The file that you create must
include all of these parameters, and the values must be formatted in
the same way as in this example (with parentheses and quotation marks
as shown). Parameter descriptions follow the example file.</p><pre class="screen">ADMIN_NODES=(dev1 dev2 dev3)
BRICK_NODES=(dev1 dev2 dev3)
BRICKS_PER_CHAIN=2

ALL_NODES=(dev1 dev2 dev3)
ALL_NETA_ADDRS=("10.181.165.230" "10.181.165.231" "10.181.165.232")
ALL_NETB_ADDRS=("10.181.165.230" "10.181.165.231" "10.181.165.232")
ALL_NETA_BCAST="10.181.165.255"
ALL_NETB_BCAST="10.181.165.255"
ALL_NETA_TIEBREAKER="10.181.165.1"

ALL_HEART_UDP_PORT="63099"
ALL_HEART_XMIT_UDP_PORT="63100"</pre><div class="itemizedlist"><a id="eligible-admin-nodes"></a><ul type="disc"><li><p>
<code class="literal">ADMIN_NODES</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Host names of the nodes that will be eligible to run the Hibari
    Admin Server. For complete information on the Admin Server, see
    <a class="ulink" href="hibari-sysadmin-guide.en.html#admin-server-app" target="_top">The Admin
    Server Application</a> in the Hibari System Administrator’s Guide.
</li></ul></div></li><li><p>
<code class="literal">BRICK_NODES</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Host names of the nodes that will serve as Hibari storage
    bricks. Note that in the sample configuration file above there are
    three storage brick nodes (dev1, dev2, and dev3), and these three
    nodes are each eligible to run the Admin Server.
</li></ul></div></li><li><p>
<code class="literal">BRICKS_PER_CHAIN</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Number of bricks per replication chain. For example, with two
    bricks per chain there will be two copies of the data stored in
    the chain (one copy on each brick); with three bricks per chain
    there will be three copies, and so on. For an overview of chain
    replication, see <a class="ulink" href="#chain-replication" target="_top">Chain Replication for
    High Availability and Strong Consistency</a> in this document. For
    chain replication detail, see the Hibari System Administrator’s
    Guide.
</li></ul></div></li><li><p>
<code class="literal">ALL_NODES</code>
</p><div class="itemizedlist"><ul type="circle"><li>
This list of all Hibari nodes is the union of <code class="literal">ADMIN_NODES</code> and
    <code class="literal">BRICK_NODES</code>.
</li></ul></div></li><li><p>
<code class="literal">ALL_NETA_ADDRS</code>
</p><div class="itemizedlist"><ul type="circle"><li>
As described in
    <a class="ulink" href="hibari-sysadmin-guide.en.html#partition-detector" target="_top">The
    Partition Detector Application</a> in the Hibari System
    Administrator’s guide, the nodes in a multi-node Hibari cluster
    should be connected by two networks, Network A and Network B, in
    order to detect and manage network partitions. The
    <code class="literal">ALL_NETA_ADDRS</code> parameter specifies the IP addresses of each
    Hibari node within Network A, which is the network through which
    data replication and other Erlang communications will take
    place. The list of the IP addresses should correspond in order to
    host names you listed in the <code class="literal">ALL_NODES</code> setting.
</li></ul></div></li><li><p>
<code class="literal">ALL_NETB_ADDRS</code>
</p><div class="itemizedlist"><ul type="circle"><li>
IP addresses of each Hibari node within Network B. Network B is
    used only for heartbeat broadcasts that help to detect network
    partitions. The list of the IP addresses should correspond in
    order to host names you listed in the <code class="literal">ALL_NODES</code> setting.
</li></ul></div></li><li><p>
<code class="literal">ALL_NETA_BCAST</code>
</p><div class="itemizedlist"><ul type="circle"><li>
IP broadcast address for Network A.
</li></ul></div></li><li><p>
<code class="literal">ALL_NETB_BCAST</code>
</p><div class="itemizedlist"><ul type="circle"><li>
IP broadcast address for Network B.
</li></ul></div></li><li><p>
<code class="literal">ALL_NETA_TIEBREAKER</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Within Network A, the IP address for the network monitoring
    application to use as a "tiebreaker" in the event of a
    partition. If the network monitoring application on a Hibari node
    determines that Network A is partitioned and Network B is not
    partitioned, then if the Network A tiebreaker IP address responds
    to a ping, then the local node is on the "correct" side of the
    partition. Ideally the tiebreaker should be the address of the
    Layer 2 switch or Layer 3 router that all Erlang network
    distribution communications flow through.
</li></ul></div></li><li><p>
<code class="literal">ALL_HEART_UDP_PORT</code>
</p><div class="itemizedlist"><ul type="circle"><li>
UDP port for heartbeat listener.
</li></ul></div></li><li><p>
<code class="literal">ALL_HEART_XMIT_UDP_PORT</code>
</p><div class="itemizedlist"><ul type="circle"><li>
UDP port for heartbeat transmitter.
</li></ul></div></li></ul></div><p>For more detail on network monitoring configuration settings, see the
partition-detector’s OTP application source file
(<a class="ulink" href="https://github.com/hibari/partition-detector/raw/master/src/partition_detector.app.src" target="_top">https://github.com/hibari/partition-detector/raw/master/src/partition_detector.app.src</a>).</p><div class="caution" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="./images/icons/caution.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>In a production setting, Network A and Network B should be
physically different networks and network interfaces.  However, for
testing and development purposes the same physical network can be used
for Network A and Network B (as in the sample configuration file
above).</p></td></tr></table></div><p>As final configuration steps, on <span class="strong"><strong>each Hibari node</strong></span>:</p><div class="itemizedlist"><ul type="disc"><li><p>
Make sure that the <code class="literal">/etc/hosts</code> file has entries for all Hibari nodes
in the cluster. For example:
</p><pre class="screen">10.181.165.230  dev1.your-domain.com    dev1
10.181.165.231  dev2.your-domain.com    dev2
10.181.165.232  dev3.your-domain.com    dev3</pre></li><li>
In the system’s <code class="literal">/etc/sysctl.conf</code> file, set <code class="literal">vm.swappiness=0</code>. Swappiness
is not desirable for an Erlang VM.
</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_installing_hibari"></a>2.6.4. Installing Hibari</h4></div></div></div><p>From your installer node, logged in as the installer user, take these
steps to create your Hibari cluster:</p><div class="orderedlist"><ol type="1"><li><p>
In the working directory in which you
  <a class="ulink" href="#download-cluster" target="_top">downloaded the Cluster tool</a> and
  <a class="ulink" href="#config-cluster" target="_top">created your cluster configuration file</a>, place
  a copy of the Hibari tarball package and md5sum file:
</p><pre class="screen">$ cd working-directory
$ ls -1
clus
hibari-X.Y.Z-DIST-ARCH-WORDSIZE-md5sum.txt
hibari-X.Y.Z-DIST-ARCH-WORDSIZE.tgz
hibari.config
$</pre></li><li><p>
Create the "hibari" user on all Hibari nodes:
</p><pre class="screen">$ for i in dev1 dev2 dev3 ; do ./clus/priv/clus.sh -f init hibari $i ; done
hibari@dev1
hibari@dev2
hibari@dev3</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>If the "hibari" user already exists on the target nodes, the -f
option will forcefully delete and then re-create the "hibari" user.</p></td></tr></table></div></li><li><p>
Install the Hibari package on all Hibari nodes, via the newly
  created "hibari" user:
</p><pre class="screen">$ ./clus/priv/clus-hibari.sh -f init hibari hibari.config hibari-X.Y.Z-DIST-ARCH-WORDSIZE.tgz
hibari@dev1
hibari@dev2
hibari@dev3</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>By default the Cluster tool installs Hibari into
<code class="literal">/usr/local/var/lib</code> on the target nodes. If you prefer a different
location, before doing the install open the <code class="literal">clus.sh</code> script (in your
working directory, under <code class="literal">/clus/priv/</code>) and edit the <code class="literal">CT_HOMEBASEDIR</code>
variable.</p></td></tr></table></div></li></ol></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="starting-multi-node"></a>2.7. Starting and Stopping a Multi-Node Hibari Cluster</h3></div></div></div><p>You can use the Cluster installer tool to start and stop your
multi-node Hibari cluster, working from the same node from which you
managed the installation process. Note that in each of the Hibari
commands in this section you’ll be referencing the name of the
<a class="ulink" href="#config-cluster" target="_top">Cluster tool configuration file</a> that you created
during the installation procedure.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_starting_and_bootstrapping_the_hibari_cluster"></a>2.7.1. Starting and Bootstrapping the Hibari Cluster</h4></div></div></div><div class="orderedlist"><ol type="1"><li><p>
Change to the working directory in which you downloaded the Cluster
tool, then start Hibari on all Hibari nodes via the "hibari" user:
</p><pre class="screen">$ cd working-directory
$ ./clus/priv/clus-hibari.sh -f start hibari hibari.config
hibari@dev1
hibari@dev2
hibari@dev3</pre></li><li><p>
If this is the first time you’ve started Hibari, bootstrap the
  system via the "hibari" user:
</p><pre class="screen">$ ./clus/priv/clus-hibari.sh -f bootstrap hibari hibari.config
hibari@dev1 =&gt; hibari@dev1 hibari@dev2 hibari@dev3</pre><p>The Hibari bootstrap process starts Hibari’s Admin Server on the first
<a class="ulink" href="#eligible-admin-nodes" target="_top">eligible admin node</a> and creates a single
table "tab1" serving as Hibari’s default table. For information about
creating additional tables, see <a class="ulink" href="#creating-tables" target="_top">Creating New Tables</a>.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>If bootstrapping fails due to "another_admin_server_running"
error, please stop the other Hibari cluster(s) running on the network;
or reconfigure the Cluster tool to assign
<a class="ulink" href="#eligible-admin-nodes" target="_top">Hibari heartbeat listener ports</a> that are
not in use by another Hibari cluster or other applications and then
repeat the cluster installation procedure.</p></td></tr></table></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_verifying_the_hibari_cluster"></a>2.7.2. Verifying the Hibari Cluster</h4></div></div></div><p>Do these simple checks to verify that Hibari is up and running.</p><div class="orderedlist"><ol type="1"><li><p>
Confirm that you can open the "Hibari Web Administration" page:
</p><pre class="screen">$ your-favorite-browser http://dev1:23080</pre></li><li><p>
Confirm that you can successfully ping each of your Hibari nodes:
</p><pre class="screen">$ ./clus/priv/clus-hibari.sh -f ping hibari hibari.config
hibari@dev1 ... pong
hibari@dev2 ... pong
hibari@dev3 ... pong</pre></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_stopping_the_hibari_cluster"></a>2.7.3. Stopping the Hibari Cluster</h4></div></div></div><p>Stop Hibari on all Hibari nodes via the "hibari" user:</p><pre class="screen">$ cd working-directory
$ ./clus/priv/clus-hibari.sh -f stop hibari hibari.config
ok
ok
ok
hibari@dev1
hibari@dev2
hibari@dev3</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="creating-tables"></a>2.8. Creating New Tables</h3></div></div></div><p>The simplest way to create a new table is via the Admin Server’s
GUI. Open <code class="literal">http://localhost:23080/</code> and click the "Add a table" link.
In addition to the GUI, the hibari-admin tool can also be used to
create a new table.  See the hibari-admin tool for usage details.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>For information about creating tables using the administrative
API, see the Hibari System Administrator’s Guide.</p></td></tr></table></div><p>When adding a table through the GUI, you have these table
configuration options:</p><div class="itemizedlist"><ul type="disc"><li><p>
<code class="literal">Local</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Boolean. If true, all bricks for storing the new table’s data will
    be created on the local node, i.e. the node that’s running the
    Admin Server.  If false, then the "NodeList" field is used to
    specify which cluster nodes the new bricks should use.
</li></ul></div></li><li><p>
<code class="literal">BigData</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Boolean. If true, value blobs will be stored on disk.
</li></ul></div></li><li><p>
<code class="literal">DiskLogging</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Boolean. If true, all updates will be written to the write-ahead
    log for persistence.  If false, bricks will run faster but at the
    expense of data loss in a cluster-wide power failure.
</li></ul></div></li><li><p>
<code class="literal">SyncWrites</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Boolean. If true, all writes to the write-ahead log will be
    flushed to stable storage via the <code class="literal">fsync(2)</code> system call.  If
    false, bricks will run faster but at the expense of data loss in a
    cluster-wide power failure.
</li></ul></div></li><li><p>
<code class="literal">VarPrefix</code>
</p><div class="itemizedlist"><ul type="circle"><li><p>
Boolean. If true, then a variable-length prefix of the key will be
    used as input for the consistent hashing function.  If false, the
    entire key will be used.
</p><p>Many applications can benefit from using a variable-length or
fixed-length prefix hashing scheme.  As an example, consider an
application that maintains state for various users.  The app wishes to
use micro-transactions to update various keys (in the same table)
related to that user.  The table can be created to use
<code class="literal">VarPrefix=true</code>, together with <code class="literal">VarPrefixSeparator=47</code> (ASCII 47 is
the forward slash character) and <code class="literal">VarPrefixNumSeparator=2</code>, to create
a hashing scheme that will guarantee that keys <code class="literal">/FooUser/summary</code> and
<code class="literal">/FooUser/thing1</code> and <code class="literal">/FooUser/thing9</code> are all stored by the same
chain.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The HTTP interface for creating tables does not expose the
fixed-length key prefix scheme.  The Erlang API must be used in this
case.</p></td></tr></table></div></li></ul></div></li><li><p>
<code class="literal">VarPrefixSeparator</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Integer. Define the character used for variable-length key prefix
    calculation.  Note that the default value of ASCII 47 (the "/"
    character), or any other character, does not imply any UNIX/POSIX
    style file or directory semantics.
</li></ul></div></li><li><p>
<code class="literal">VarPrefixNumSeparators</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Integer. Define the number of <code class="literal">VarPrefixSeparator</code> bytes, and all
    bytes in between, used for consistent hashing.  If
    <code class="literal">VarPrefixSeparator=47</code> and <code class="literal">VarPrefixNumSeparators=3</code>, then for a
    key such as <code class="literal">/foo/bar/baz</code>, the prefix used for consistent hashing
    will be <code class="literal">/foo/bar/</code>.
</li></ul></div></li><li><p>
<code class="literal">Bricks</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Integer. If <code class="literal">Local=true</code> (see above), then this integer defines
    the total number of logical bricks that will be created on the
    local node.  This value is ignored if <code class="literal">Local=false</code>.
</li></ul></div></li><li><p>
<code class="literal">BPC</code>
</p><div class="itemizedlist"><ul type="circle"><li><p>
Integer. Define the number of bricks per chain.
</p><p>The algorithm used for creating chain → brick mapping is based on a
"striping" principle: enough chains are laid across bricks in a
stripe-wise manner so that all nodes (aka physical bricks) will have
the same number of logical bricks in head, middle, and tail roles.
See the example in the Hibari System Administrator’s Guide of
<a class="ulink" href="hibari-sysadmin-guide.en.html#3-chains-striped-across-3-bricks" target="_top">3
chains striped across three nodes</a>.</p><p>The Erlang API must be used to create tables with other chain layout
patterns.</p></li></ul></div></li><li><p>
<code class="literal">NodeList</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Comma-separated string. If <code class="literal">Local=false</code>, specify the list of
    nodes that will run logical bricks for the new table.  Each node
    in the comma-separated list should take the form
    <code class="literal">NodeName@HostName</code>.  For example, use <code class="literal">hibari1@machine-a,
    hibari1@machine-b, hibari1@machine-c</code> to specify three nodes.
</li></ul></div></li><li><p>
<code class="literal">NumNodesPerBlock</code>
</p><div class="itemizedlist"><ul type="circle"><li><p>
Integer. If <code class="literal">Local=false</code>, then this integer will affect the
    striping behavior of the default chain striping algorithm.  This
    value must be zero (i.e. this parameter is ignored) or a multiple
    of the <code class="literal">BPC</code> parameter.
</p><p>For example, if <code class="literal">NodeList</code> contains nodes A, B, C, D, E, and F, then
the following striping patterns would be used:</p><div class="itemizedlist"><ul type="square"><li>
<code class="literal">NumNodesPerBlock=0</code> would stripe across all 6 nodes for 6
       chains total.
</li><li>
<code class="literal">NumNodesPerBlock=2</code> and <code class="literal">BPC=2</code> would stripe 2 chains across
        nodes A &amp; B, 2 chains across C &amp; D, and 2 chains across E &amp; F.
</li><li>
<code class="literal">NumNodesPerBlock=3</code> and <code class="literal">BPC=3</code> would stripe 3 chains across
        nodes A &amp; B &amp; C and 3 chains across D &amp; E &amp; F.
</li></ul></div></li></ul></div></li><li><p>
<code class="literal">BlockMultFactor</code>
</p><div class="itemizedlist"><ul type="circle"><li><p>
Integer. If <code class="literal">Local=false</code>, then this integer will affect the
    striping behavior of the default chain striping algorithm.  This
    value must be zero (i.e. this parameter is ignored) or greater
    than zero.
</p><p>For example, if <code class="literal">NodeList</code> contains nodes A, B, C, D, E, and F, then
the following striping patterns would be used:</p><div class="itemizedlist"><ul type="square"><li>
<code class="literal">NumNodesPerBlock=0</code> and <code class="literal">BlockMultFactor=0</code> would stripe
       across all 6 nodes for 6 chains total.
</li><li>
<code class="literal">NumNodesPerBlock=2</code> and <code class="literal">BlockMultFactor=5</code> and <code class="literal">BPC=2</code> would
       stripe 2*5=10 chains across nodes A &amp; B, 2*5=10 chains across C
       &amp; D, and 2*5=10 chains across E &amp; F, for a total of 30 chains.
</li><li>
<code class="literal">NumNodesPerBlock=3</code> and <code class="literal">BlockMultFactor=4</code> and <code class="literal">BPC=3</code> would
       stripe 3*4=12 chains across nodes A &amp; B &amp; C and 3*4=12 chains
       across D &amp; E &amp; F, for a total of 24 chains.
</li></ul></div></li></ul></div></li></ul></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="client-api-erlang"></a>3. Client API: Native Erlang</h2></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_hibari_client_api_overview"></a>3.1. Hibari Client API Overview</h3></div></div></div><p>As a key-value database, Hibari provides a simple client API with
primitive operations for inserting, retrieving, and deleting
data. Within certain restrictions, the API also supports compound
operations that optionally can be executed as atomic transactions.</p><p>More specifically, Hibari’s client API supports the operations listed
below. For details on the native Erlang API for each operation, follow
the links.</p><p><span class="strong"><strong>Data Insertion</strong></span></p><div class="itemizedlist"><ul type="disc"><li><p>
Add a key-value pair that does not yet exist, along with optional
   flags:
</p><div class="itemizedlist"><ul type="circle"><li>
<a class="ulink" href="#brick-simple-add" target="_top">brick_simple:add/6</a>
</li></ul></div></li><li><p>
Assign a new value and/or new flags to a key that already exists:
</p><div class="itemizedlist"><ul type="circle"><li>
<a class="ulink" href="#brick-simple-replace" target="_top">brick_simple:replace/6</a>
</li></ul></div></li><li><p>
Set a key-value pair and optional flags regardless of whether the
   key yet exists:
</p><div class="itemizedlist"><ul type="circle"><li>
<a class="ulink" href="#brick-simple-set" target="_top">brick_simple:set/6</a>
</li></ul></div></li></ul></div><p><span class="strong"><strong>Data Retrieval</strong></span></p><div class="itemizedlist"><ul type="disc"><li><p>
Retrieve a key and optionally its associated value and flags:
</p><div class="itemizedlist"><ul type="circle"><li>
<a class="ulink" href="#brick-simple-get" target="_top">brick_simple:get/4</a>
</li></ul></div></li><li><p>
Retrieve multiple lexicographically contiguous keys and optionally
   their associated values and flags:
</p><div class="itemizedlist"><ul type="circle"><li>
<a class="ulink" href="#brick-simple-get-many" target="_top">brick_simple:get_many/5</a>
</li></ul></div></li></ul></div><p><span class="strong"><strong>Data Deletion</strong></span></p><div class="itemizedlist"><ul type="disc"><li><p>
Delete a key-value pair and associated flags:
</p><div class="itemizedlist"><ul type="circle"><li>
<a class="ulink" href="#brick-simple-delete" target="_top">brick_simple:delete/4</a>
</li></ul></div></li></ul></div><p><span class="strong"><strong>Compound Operations</strong></span></p><div class="itemizedlist"><ul type="disc"><li><p>
Execute a specified list of operations, optionally as an atomic
   transaction:
</p><div class="itemizedlist"><ul type="circle"><li>
<a class="ulink" href="#brick-simple-do" target="_top">brick_simple:do/4</a>
</li></ul></div></li></ul></div><p><span class="strong"><strong>Fold Operations</strong></span></p><div class="itemizedlist"><ul type="disc"><li><p>
Implement a fold operation across all keys in a table:
</p><div class="itemizedlist"><ul type="circle"><li>
<a class="ulink" href="#brick-simple-fold-table" target="_top">brick_simple:fold_table/7</a>
</li></ul></div></li><li><p>
Implement a fold operation across all keys having a specified
   prefix:
</p><div class="itemizedlist"><ul type="circle"><li>
<a class="ulink" href="#brick-simple-fold-key" target="_top">brick_simple:fold_key_prefix/9</a>
</li></ul></div></li></ul></div><p>If desired, clients can apply a "test 'n set" logic to data insertion,
retrieval, and deletion operations so that the operation will be
executed only if the target key has the exact timestamp specified in
the request.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_erlang_basic_data_types"></a>3.1.1. Erlang Basic Data Types</h4></div></div></div><p>The following provides a high level introduction to Erlang basic data
types that are referenced in this chapter. This material is excerpted
with minor modifications from the
<a class="ulink" href="http://www.erlang.org/doc/reference_manual/data_types.html" target="_top">official
Erlang documentation on data types</a>. For further information, see the
official Erlang documentation.</p><div class="important" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./images/icons/important.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>All Erlang commands must conclude with a period (.).</p></td></tr></table></div><div class="variablelist"><dl><dt><span class="term">
Term
</span></dt><dd>
A piece of data of any data type is called a <span class="strong"><strong>term</strong></span>.
</dd><dt><span class="term">
Number
</span></dt><dd>
There are two types of numeric literals, <span class="strong"><strong>integers</strong></span> and <span class="strong"><strong>floats</strong></span>.
</dd><dt><span class="term">
Atom
</span></dt><dd><p>
An <span class="strong"><strong>atom</strong></span> is a literal, a constant with name. An atom should be
enclosed in single quotes (') if it does not begin with a lower-case
letter or if it contains other characters than alphanumeric
characters, underscore (_), or @. Optionally, any atom can be enclosed
in single quotes. For example:
</p><pre class="screen">hello
phone_number
'Monday'
'phone number'
'hello'
'phone_number'</pre></dd><dt><span class="term">
Bit String and Binary
</span></dt><dd><p>
A <span class="strong"><strong>bit string</strong></span> is used to store an area of
untyped memory. Bit strings are expressed using
<a class="ulink" href="http://www.erlang.org/doc/reference_manual/expressions.html#bit_syntax" target="_top">Erlang
bit syntax</a>. A bit string that consists of a number of bits that is
evenly divisible by eight is called a <span class="strong"><strong>binary</strong></span>. For example:
</p><pre class="screen">&lt;&lt;10,20&gt;&gt;
&lt;&lt;"ABC"&gt;&gt;</pre></dd><dt><span class="term">
Tuple
</span></dt><dd><p>
A <span class="strong"><strong>tuple</strong></span> is a compound data type with a fixed number of
terms, enclosed by braces:
</p><pre class="screen">{Term1,...,TermN}</pre></dd><dt><span class="term">
List
</span></dt><dd><p>
A <span class="strong"><strong>list</strong></span> is a compound data type with a variable number of
terms, enclosed by square brackets:
</p><pre class="screen">[Term1,...,TermN]</pre></dd><dt><span class="term">
String
</span></dt><dd>
Strings are enclosed in double quotes ("), but are not a true
data type in Erlang. Instead a string "hello" is shorthand for the
list [$h,$e,$l,$l,$o], that is [104,101,108,108,111].
</dd><dt><span class="term">
Boolean
</span></dt><dd>
There is no Boolean data type in Erlang. Instead the atoms
<code class="literal">true</code> and <code class="literal">false</code> are used to denote Boolean values.
</dd></dl></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_the_hibari_data_model"></a>3.1.2. The Hibari Data Model</h4></div></div></div><p>If a Hibari table were represented within an SQL database, it would
look something like this:</p><pre class="screen">CREATE TABLE foo (
    BLOB key;
    BLOB value;
    INTEGER timestamp;                  -- Monotonically increasing
    INTEGER expiration_time;            -- Usually zero
    LIST OF ATOMS_AND_TWO_TUPLES flags; -- Metadata stored in RAM for speed
) PRIMARY KEY key;</pre><p>Hibari table names use the Erlang data type “atom”.  The types of
all key-related attributes are presented below.</p><div class="informaltable"><table cellpadding="4px" style="border-collapse: collapse;border-top: 2px solid #527bbd; border-bottom: 2px solid #527bbd; border-left: 2px solid #527bbd; border-right: 2px solid #527bbd; "><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="top"> Attribute Name </th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="top"> Erlang data type </th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="top"> Storage Location </th><th style="border-bottom: 1px solid ; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="top"><p>Key</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="top"><p>binary</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="top"><p>RAM</p></td><td style="border-bottom: 1px solid ; " align="left" valign="top"><p>A binary blob of any size, though due to RAM storage the key should be small enough for all keys to fit in RAM.</p></td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="top"><p>Value</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="top"><p>binary</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="top"><p>RAM or disk</p></td><td style="border-bottom: 1px solid ; " align="left" valign="top"><p>A binary blob of any size, though practical constraints limit value blobs to 16MB or so.</p></td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="top"><p>Timestamp</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="top"><p>integer</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="top"><p>RAM</p></td><td style="border-bottom: 1px solid ; " align="left" valign="top"><p>A monotonically increasing counter, usually (but not always) based on the client’s wall-clock time.  Updating a key with a timestamp smaller than the key’s current timestamp is not permitted.</p></td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="top"><p>Expiration Time</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="top"><p>integer</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="top"><p>RAM</p></td><td style="border-bottom: 1px solid ; " align="left" valign="top"><p>A UNIX <code class="literal">time_t</code> representing the expiration time for a key.  A value of 0 means no expiration, and no RAM overhead is required.</p></td></tr><tr><td style="border-right: 1px solid ; " align="center" valign="top"><p>Flags</p></td><td style="border-right: 1px solid ; " align="center" valign="top"><p>list</p></td><td style="border-right: 1px solid ; " align="center" valign="top"><p>RAM</p></td><td style="" align="left" valign="top"><p>This attribute cannot be represented in plain SQL.  It is a list of atoms and/or {atom(), term()} pairs.  Heavy use of this attribute is discouraged due to RAM-based storage.</p></td></tr></tbody></table></div><p>"Storage location = RAM" means that, during normal query handling,
data is retrieved from a copy in RAM.  All modifications of any/all
attributes of a key are written to the write-ahead log to prevent data
loss in case of a cluster-wide power failure.  See
<a class="xref" href="#">???</a> for more details.</p><p>"Store location = disk" means that the value of the attribute is not
stored in RAM.  Metadata in RAM contains a pointer to the attribute’s
location:file #, byte offset, and length.  A log sequence file inside
the common log must be opened, call <code class="literal">lseek(2)</code>, and then <code class="literal">read(2)</code> to
retrieve the attribute.</p><div class="variablelist"><dl><dt><span class="term">
Best case
</span></dt><dd>
Zero disk seeks are required to read a key’s value
blob from disk, because all data in question is in the OS’s page
cache.
</dd><dt><span class="term">
Typical case
</span></dt><dd>
One seek and read is required: the file’s inode
info is cached, but the desired file page(s) is not cached.
</dd><dt><span class="term">
Worse case
</span></dt><dd>
The file system will need to perform additional seeks and
reads to read intermediate directory data, inode, and indirect storage
block data within the inode.
</dd></dl></div><p>The practical constraints on maximum value blob size are affected by
total blob size and frequency of large blob access.  For example,
storing an occasional 64MB value blob is different than a 100% write
workload of 100% 64MB value blobs.  The Hibari client API does not
have a method to update or fetch less than the entire value blob, so a
brick can be blocked for many seconds if it tried to operate on (for
example) even a single 4GB blob.  In addition, other processes can be
blocked by <code class="literal">'busy_dist_port'</code> events while processing big value blobs.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="brick-simple-add"></a>3.2. brick_simple:add/6</h3></div></div></div><p>SYNOPSIS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
<span class="strong"><strong>brick_simple:add(Tab, Key, Value, ExpTime, Flags, Timeout).</strong></span>
</dd></dl></div><p>DESCRIPTION</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
Add <code class="literal">Key</code> and <code class="literal">Value</code> pair (and optional <code class="literal">Flags</code>) to the table <code class="literal">Tab</code>
if the key does not already exist.  The operation will fail if <code class="literal">Key</code>
already exists.
</dd></dl></div><p>PARAMETERS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Tab</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Name of the table to which to add the key-value pair.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Tab = table()</code>
</li><li>
<code class="literal">table() = atom()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Key</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Key to add to the table, in association with a paired value.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Key = key()</code>
</li><li>
<code class="literal">key() = iodata()</code>
</li><li>
<code class="literal">iodata() = iolist() | binary()</code>
</li><li><p>
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>While the <code class="literal">Key</code> may be specified as either <code class="literal">iolist()</code> or
<code class="literal">binary()</code>, it will be converted into binary before operation
execution. The same is true of <code class="literal">Value</code>.</p></td></tr></table></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Value</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Value to associate with the key.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Value = val()</code>
</li><li>
<code class="literal">val() = iodata()</code>
</li><li>
<code class="literal">iodata() = iolist() | binary()</code>
</li><li>
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>ExpTime</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Time at which the key will expire, expressed as a Unix time_t().
</li><li>
Optional; defaults to 0 (no expiration).
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">ExpTime = exp_time()</code>
</li><li>
<code class="literal">exp_time() = time_t()</code>
</li><li>
<code class="literal">time_t() = integer()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Flags</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
List of operational flags to apply to the ‘add’ operation, and/or
  custom property flags to associate with the key-value pair in the
  database. Heavy use of custom property flags is discouraged due to
  RAM-based storage.
</li><li>
Optional; defaults to empty list.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Flags = flags_list()</code>
</li><li>
<code class="literal">flags_list() = [do_op_flag() | property()]</code>
</li><li>
<code class="literal">do_op_flag() = 'value_in_ram'</code>
</li><li>
<code class="literal">property() = atom() | {term(), term()}</code>
</li></ul></div></li><li><p>
Operational flag usage
</p><div class="itemizedlist"><ul type="circle"><li><p>
<code class="literal">'value_in_ram'</code>
</p><div class="itemizedlist"><ul type="square"><li><p>
Store the value blob in RAM, overriding the default storage
       location of the brick.
</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>This flag has not yet been extensively tested by Gemini QA.</p></td></tr></table></div></li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Timeout</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Operation timeout in milliseconds.
</li><li>
Optional; defaults to 15000.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Timeout = timeout()</code>
</li><li>
<code class="literal">timeout() = integer() | 'infinity'</code>
</li></ul></div></li></ul></div></dd></dl></div><p>RETURNS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
Success return
</p><div class="itemizedlist"><ul type="disc"><li>
<code class="literal">'ok'</code>
</li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
Error returns
</p><div class="itemizedlist"><ul type="disc"><li><p>
<code class="literal">{'key_exists',timestamp()}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the key already exists.
</li><li>
<code class="literal">timestamp() = integer()</code>
</li></ul></div></li><li><p>
<code class="literal">'invalid_flag_present'</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because an invalid <code class="literal">do_op_flag()</code> was found
    in the <code class="literal">Flags</code> argument.
</li></ul></div></li><li><p>
<code class="literal">'brick_not_available'</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the chain that is responsible for
    this key is currently length zero and therefore unavailable.
</li></ul></div></li><li><p>
<code class="literal">{{'nodedown',node()},{'gen_server','call',term()}}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the server brick handling the request
    has crashed or else a network partition has occurred between the
    client and server. The client should resend the query after a
    short delay, on the assumption that the Admin Server will have
    detected the failure and taken steps to repair the chain.
</li><li>
<code class="literal">node() = atom()</code>
</li></ul></div></li></ul></div></dd></dl></div><p>ALIASES</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><div class="itemizedlist"><ul type="disc"><li><p>
brick_simple:add/3
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">brick_simple:add(Tab, Key, Value).</code>
</li></ul></div></li><li><p>
brick_simple:add/4
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">brick_simple:add(Tab, Key, Value, Flags).</code>
</li><li>
<code class="literal">brick_simple:add(Tab, Key, Value, Timeout).</code>
</li></ul></div></li></ul></div></dd></dl></div><p>EXAMPLES</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
Successful adding of a new key-value pair:
</p><pre class="screen">&gt; brick_simple:add(tab1, &lt;&lt;"foo"&gt;&gt;, &lt;&lt;"Hello, world!"&gt;&gt;).
ok</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Failed attempt to add a key that already exists:
</p><pre class="screen">&gt; brick_simple:add(tab1, &lt;&lt;"foo"&gt;&gt;, &lt;&lt;"Goodbye, world!"&gt;&gt;).
{key_exists,1271542959131192}</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Successful adding of a new key-value pair, with value to be stored in
RAM regardless of brick’s default storage setting:
</p><pre class="screen">&gt; brick_simple:add(tab1, "foo1", "this is value1", ['value_in_ram']).
ok</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Successful adding of a new key-value pair, using a non-default
operation timeout:
</p><pre class="screen">&gt; brick_simple:add(tab1, "foo2", "this is value2", 20000).
ok</pre></dd></dl></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="brick-simple-replace"></a>3.3. brick_simple:replace/6</h3></div></div></div><p>SYNOPSIS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
<span class="strong"><strong>brick_simple:replace(Tab, Key, Value, ExpTime, Flags, Timeout).</strong></span>
</dd></dl></div><p>DESCRIPTION</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
Replace <code class="literal">Key</code> and <code class="literal">Value</code> pair (and optional <code class="literal">Flags</code>) in the table
<code class="literal">Tab</code> if the key already exists.  The operation will fail if <code class="literal">Key</code>
does not already exist.
</dd></dl></div><p>PARAMETERS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Tab</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Name of the table in which to replace the key-value pair.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Tab = table()</code>
</li><li>
<code class="literal">table() = atom()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Key</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Key to replace in the table, in association with a new paired value.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Key = key()</code>
</li><li>
<code class="literal">key() = iodata()</code>
</li><li>
<code class="literal">iodata() = iolist() | binary()</code>
</li><li><p>
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>While the <code class="literal">Key</code> may be specified as either <code class="literal">iolist()</code> or
<code class="literal">binary()</code>, it will be converted into binary before operation
execution. The same is true of <code class="literal">Value</code>.</p></td></tr></table></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Value</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
New value to associate with the key.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Value = val()</code>
</li><li>
<code class="literal">val() = iodata()</code>
</li><li>
<code class="literal">iodata() = iolist() | binary()</code>
</li><li>
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>ExpTime</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Time at which the key will expire, expressed as a Unix time_t().
</li><li>
Optional; defaults to 0 (no expiration).
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">ExpTime = exp_time()</code>
</li><li>
<code class="literal">exp_time() = time_t()</code>
</li><li>
<code class="literal">time_t() = integer()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Flags</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
List of operational flags to apply to the ‘replace’ operation,
  and/or custom property flags to associate with the key-value pair in
  the database. Heavy use of custom property flags is discouraged due
  to RAM-based storage.
</li><li>
Optional; defaults to empty list.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Flags = flags_list()</code>
</li><li>
<code class="literal">flags_list() = [do_op_flag() | property()]</code>
</li><li>
<code class="literal">do_op_flag() = {'testset', timestamp()} |'value_in_ram'</code>
</li><li>
<code class="literal">timestamp() = integer()</code>
</li><li>
<code class="literal">property() = atom() | {term(), term()}</code>
</li></ul></div></li><li><p>
Operational flag usage
</p><div class="itemizedlist"><ul type="circle"><li><p>
<code class="literal">{'testset', timestamp()}</code>
</p><div class="itemizedlist"><ul type="square"><li>
Fail the operation if the existing key’s timestamp is not
       exactly equal to <code class="literal">timestamp()</code>.  If used inside a
       <a class="ulink" href="#brick-simple-do" target="_top">micro-transaction</a>, abort the transaction
       if the key’s timestamp is not exactly equal to <code class="literal">timestamp()</code>.
</li></ul></div></li><li><p>
<code class="literal">'value_in_ram'</code>
</p><div class="itemizedlist"><ul type="square"><li><p>
Store the value blob in RAM, overriding the default storage
       location of the brick.
</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>This flag has not yet been extensively tested by Gemini QA.</p></td></tr></table></div></li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Timeout</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Operation timeout in milliseconds.
</li><li>
Optional; defaults to 15000.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Timeout = timeout()</code>
</li><li>
<code class="literal">timeout() = integer() | 'infinity'</code>
</li></ul></div></li></ul></div></dd></dl></div><p>RETURNS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
Success return
</p><div class="itemizedlist"><ul type="disc"><li>
<code class="literal">'ok'</code>
</li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
Error returns
</p><div class="itemizedlist"><ul type="disc"><li><p>
<code class="literal">'key_not_exist'</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the key does not exist.
</li></ul></div></li><li><p>
<code class="literal">{'ts_error', timestamp()}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the <code class="literal">{'testset', timestamp()}</code> flag
    was used and there was a timestamp mismatch. The <code class="literal">timestamp()</code> in
    the return is the current value of the existing key’s timestamp.
</li><li>
<code class="literal">timestamp() = integer()</code>
</li></ul></div></li><li><p>
<code class="literal">'invalid_flag_present'</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because an invalid <code class="literal">do_op_flag()</code> was found
    in the <code class="literal">Flags</code> argument.
</li></ul></div></li><li><p>
<code class="literal">'brick_not_available'</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the chain that is responsible for
    this key is currently length zero and therefore unavailable.
</li></ul></div></li><li><p>
<code class="literal">{{'nodedown',node()},{'gen_server','call',term()}}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the server brick handling the request
    has crashed or else a network partition has occurred between the
    client and server. The client should resend the query after a
    short delay, on the assumption that the Admin Server will have
    detected the failure and taken steps to repair the chain.
</li><li>
<code class="literal">node() = atom()</code>
</li></ul></div></li></ul></div></dd></dl></div><p>ALIASES</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><div class="itemizedlist"><ul type="disc"><li><p>
brick_simple:replace/3
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">brick_simple:replace(Tab, Key, Value).</code>
</li></ul></div></li><li><p>
brick_simple:replace/4
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">brick_simple:replace(Tab, Key, Value, Flags).</code>
</li><li>
<code class="literal">brick_simple:replace(Tab, Key, Value, Timeout).</code>
</li></ul></div></li></ul></div></dd></dl></div><p>EXAMPLES</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
Successful replacement of a key-value pair:
</p><pre class="screen">&gt; brick_simple:replace(tab1, &lt;&lt;"foo"&gt;&gt;, &lt;&lt;"Goodbye, world!"&gt;&gt;).
ok</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Failed attempt to replace a key that does not yet exist:
</p><pre class="screen">&gt; brick_simple:replace(tab1, &lt;&lt;"key3"&gt;&gt;, &lt;&lt;"new and improved value"&gt;&gt;).
key_not_exist</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Successful replacement of a key-value pair, with value to be stored in
RAM regardless of brick’s default storage setting:
</p><pre class="screen">&gt; brick_simple:replace(tab1, "foo", "You again, world!", ['value_in_ram']).
ok</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Failed attempt to replace a key for which we have incorrectly
specified its current timestamp:
</p><pre class="screen">&gt; brick_simple:replace(tab1, "foo", "Whole new value", [{'testset', 12345}]).
{ts_error,1271543165272987}</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Successful replacement of a key-value pair for which we have correctly
specified its current timestamp:
</p><pre class="screen">&gt; brick_simple:replace(tab1, "foo", "Whole new value", [{'testset', 1271543165272987}]).
ok</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Successful replacement of a key-value pair, using a non-default
operation timeout:
</p><pre class="screen">&gt; brick_simple:replace(tab1, "foo", "Foo again?", 30000).
ok</pre></dd></dl></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="brick-simple-set"></a>3.4. brick_simple:set/6</h3></div></div></div><p>SYNOPSIS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
<span class="strong"><strong>brick_simple:set(Tab, Key, Value, ExpTime, Flags, Timeout).</strong></span>
</dd></dl></div><p>DESCRIPTION</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
Set <code class="literal">Key</code> and <code class="literal">Value</code> pair (and optional <code class="literal">Flags</code>) in the table <code class="literal">Tab</code>,
regardless of whether or not the key already exists.
</dd></dl></div><p>PARAMETERS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Tab</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Name of the table in which to set the key-value pair.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Tab = table()</code>
</li><li>
<code class="literal">table() = atom()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Key</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Key to set in the table, in association with a paired value.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Key = key()</code>
</li><li>
<code class="literal">key() = iodata()</code>
</li><li>
<code class="literal">iodata() = iolist() | binary()</code>
</li><li><p>
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>While the <code class="literal">Key</code> may be specified as either <code class="literal">iolist()</code> or
<code class="literal">binary()</code>, it will be converted into binary before operation
execution. The same is true of <code class="literal">Value</code>.</p></td></tr></table></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Value</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Value to associate with the key.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Value = val()</code>
</li><li>
<code class="literal">val() = iodata()</code>
</li><li>
<code class="literal">iodata() = iolist() | binary()</code>
</li><li>
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>ExpTime</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Time at which the key will expire, expressed as a Unix time_t().
</li><li>
Optional; defaults to 0 (no expiration).
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">ExpTime = exp_time()</code>
</li><li>
<code class="literal">exp_time() = time_t()</code>
</li><li>
<code class="literal">time_t() = integer()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Flags</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
List of operational flags to apply to the ‘set’ operation, and/or
  custom property flags to associate with the key-value pair in the
  database. Heavy use of custom property flags is discouraged due to
  RAM-based storage.
</li><li>
Optional; defaults to empty list.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Flags = flags_list()</code>
</li><li>
<code class="literal">flags_list() = [do_op_flag() | property()]</code>
</li><li>
<code class="literal">do_op_flag() = {'testset', timestamp()} |'value_in_ram'</code>
</li><li>
<code class="literal">timestamp() = integer()</code>
</li><li>
<code class="literal">property() = atom() | {term(), term()}</code>
</li></ul></div></li><li><p>
Operational flag usage
</p><div class="itemizedlist"><ul type="circle"><li><p>
<code class="literal">{'testset', timestamp()}</code>
</p><div class="itemizedlist"><ul type="square"><li>
Fail the operation if the existing key’s timestamp is not
       exactly equal to <code class="literal">timestamp()</code>.  If used inside a
       <a class="ulink" href="#brick-simple-do" target="_top">micro-transaction</a>, abort the transaction
       if the key’s timestamp is not exactly equal to
       <code class="literal">timestamp()</code>. Using this flag with <code class="literal">set</code> will result in an
       error if the key does not already exist or if the key exists
       but has a non-matching timestamp.
</li></ul></div></li><li><p>
<code class="literal">'value_in_ram'</code>
</p><div class="itemizedlist"><ul type="square"><li><p>
Store the value blob in RAM, overriding the default storage
       location of the brick.
</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>This flag has not yet been extensively tested by Gemini QA.</p></td></tr></table></div></li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Timeout</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Operation timeout in milliseconds.
</li><li>
Optional; defaults to 15000.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Timeout = timeout()</code>
</li><li>
<code class="literal">timeout() = integer() | 'infinity'</code>
</li></ul></div></li></ul></div></dd></dl></div><p>RETURNS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
Success return
</p><div class="itemizedlist"><ul type="disc"><li>
<code class="literal">'ok'</code>
</li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
Error returns
</p><div class="itemizedlist"><ul type="disc"><li><p>
<code class="literal">'key_not_exist'</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the <code class="literal">{'testset', timestamp()}</code> flag
    was used and the key does not exist.
</li></ul></div></li><li><p>
<code class="literal">{'ts_error', timestamp()}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the <code class="literal">{'testset', timestamp()}</code> flag
    was used and there was a timestamp mismatch. The <code class="literal">timestamp()</code> in
    the return is the current value of the existing key’s timestamp.
</li><li>
<code class="literal">timestamp() = integer()</code>
</li></ul></div></li><li><p>
<code class="literal">'invalid_flag_present'</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because an invalid <code class="literal">do_op_flag()</code> was found
    in the <code class="literal">Flags</code> argument.
</li></ul></div></li><li><p>
<code class="literal">'brick_not_available'</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the chain that is responsible for
    this key is currently length zero and therefore unavailable.
</li></ul></div></li><li><p>
<code class="literal">{{'nodedown',node()},{'gen_server','call',term()}}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the server brick handling the request
    has crashed or else a network partition has occurred between the
    client and server. The client should resend the query after a
    short delay, on the assumption that the Admin Server will have
    detected the failure and taken steps to repair the chain.
</li><li>
<code class="literal">node() = atom()</code>
</li></ul></div></li></ul></div></dd></dl></div><p>ALIASES</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><div class="itemizedlist"><ul type="disc"><li><p>
brick_simple:set/3
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">brick_simple:set(Tab, Key, Value).</code>
</li></ul></div></li><li><p>
brick_simple:set/4
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">brick_simple:set(Tab, Key, Value, Flags).</code>
</li><li>
<code class="literal">brick_simple:set(Tab, Key, Value, Timeout).</code>
</li></ul></div></li></ul></div></dd></dl></div><p>EXAMPLES</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
Successful setting of a key-value pair:
</p><pre class="screen">&gt; brick_simple:set(tab1, &lt;&lt;"key4"&gt;&gt;, &lt;&lt;"cool value"&gt;&gt;).
ok</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Successful setting of a key-value pair, with value to be stored in RAM
regardless of brick’s default storage setting:
</p><pre class="screen">&gt; brick_simple:set(tab1, "goo", "value6", ['value_in_ram']).
ok</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Failed attempt to set a key-value pair, when we have used the
<code class="literal">testset</code> flag but the key does not yet exist:
</p><pre class="screen">&gt; brick_simple:set(tab1, "boo", "hoo", [{'testset', 1271543165272987}]).
key_not_exist</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Successful setting of a key-value pair, when we have used the
<code class="literal">testset</code> flag and the key does already exist and its timestamp
matches our specified timestamp:
</p><pre class="screen">&gt; brick_simple:set(tab1, "goo", "value7", [{'testset', 1271543165272432}]).
ok</pre></dd></dl></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="brick-simple-get"></a>3.5. brick_simple:get/4</h3></div></div></div><p>SYNOPSIS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
<span class="strong"><strong>brick_simple:get(Tab, Key, Flags, Timeout).</strong></span>
</dd></dl></div><p>DESCRIPTION</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
From table <code class="literal">Tab</code>, retrieve <code class="literal">Key</code> and specified attributes of the key
(as determined by <code class="literal">Flags</code>).
</dd></dl></div><p>PARAMETERS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Tab</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Name of the table from which to retrieve the key.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Tab = table()</code>
</li><li>
<code class="literal">table() = atom()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Key</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Key to retrieve from the table.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Key = key()</code>
</li><li>
<code class="literal">key() = iodata()</code>
</li><li>
<code class="literal">iodata() = iolist() | binary()</code>
</li><li><p>
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>While the <code class="literal">Key</code> may be specified as either <code class="literal">iolist()</code> or
<code class="literal">binary()</code>, it will be converted into binary before operation
execution.</p></td></tr></table></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Flags</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
List of operational flags to apply to the ‘get’ operation.
</li><li>
Optional; defaults to empty list.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Flags = flags_list()</code>
</li><li>
<code class="literal">flags_list() = [do_op_flag()]</code>
</li><li>
<code class="literal">do_op_flag() = 'get_all_attribs' | 'witness' | {'testset',
    timestamp()} | 'must_exist' | 'must_not_exist'</code>
</li><li>
<code class="literal">timestamp() = integer()</code>
</li></ul></div></li><li><p>
Operational flag usage
</p><div class="itemizedlist"><ul type="circle"><li><p>
<code class="literal">'get_all_attribs'</code>
</p><div class="itemizedlist"><ul type="square"><li>
Return all attributes of the key. May be used in combination
       with the <code class="literal">witness</code> flag.
</li></ul></div></li><li><p>
<code class="literal">'witness'</code>
</p><div class="itemizedlist"><ul type="square"><li>
Do not return the value blob in the result. This flag will
       guarantee that the brick does not require disk access to
       satisfy this request.
</li></ul></div></li><li><p>
<code class="literal">{'testset', timestamp()}</code>
</p><div class="itemizedlist"><ul type="square"><li>
Fail the operation if the key’s timestamp is not exactly equal
       to <code class="literal">timestamp()</code>. If used inside a
       <a class="ulink" href="#brick-simple-do" target="_top">micro-transaction</a>, abort the transaction
       if the key’s timestamp is not exactly equal to <code class="literal">timestamp()</code>.
       This flag has priority over the <code class="literal">'must_exist'</code> and
       <code class="literal">'must_not_exist'</code> flags.
</li></ul></div></li><li><p>
<code class="literal">'must_exist'</code>
</p><div class="itemizedlist"><ul type="square"><li>
For use inside a <a class="ulink" href="#brick-simple-do" target="_top">micro-transaction</a>:
       abort the transaction if the key does not exist.
</li></ul></div></li><li><p>
<code class="literal">'must_not_exist'</code>
</p><div class="itemizedlist"><ul type="square"><li>
For use inside a <a class="ulink" href="#brick-simple-do" target="_top">micro-transaction</a>:
       abort the transaction if the key exists. This flag may be useful
       when the relationship between two or more keys is important to
       the client application.
</li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Timeout</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Operation timeout in milliseconds.
</li><li>
Optional; defaults to 15000.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Timeout = timeout()</code>
</li><li>
<code class="literal">timeout() = integer() | 'infinity'</code>
</li></ul></div></li></ul></div></dd></dl></div><p>RETURNS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
Success returns
</p><div class="itemizedlist"><ul type="disc"><li><p>
<code class="literal">{'ok', timestamp(), val()}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Success return when the get request uses neither the <code class="literal">'witness'</code>
    flag nor the <code class="literal">'get_all_attribs'</code> flag.
</li><li>
<code class="literal">timestamp() = integer()</code>
</li><li>
<code class="literal">val() = iodata()</code>
</li><li>
<code class="literal">iodata() = iolist() | binary()</code>
</li><li>
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</li></ul></div></li><li><p>
<code class="literal">{'ok', timestamp()}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Success return when the get uses <code class="literal">'witness'</code> but not <code class="literal">'get_all_attribs'</code>.
</li></ul></div></li><li><p>
<code class="literal">{'ok', timestamp(), proplist()}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Success return when the get uses both <code class="literal">'witness'</code> and <code class="literal">'get_all_attribs'</code>.
</li><li>
<code class="literal">proplist() = [property()]</code>
</li><li>
<code class="literal">property() = atom() | {term(), term()}</code>
</li></ul></div></li><li><p>
<code class="literal">{'ok', timestamp(), val(), exp_time(), proplist()}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Success return when the get uses <code class="literal">'get_all_attribs'</code> but not <code class="literal">'witness'</code>.
</li><li><p>
<code class="literal">exp_time() = time_t()</code>
</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>When a <code class="literal">proplist()</code> is returned, one of the properties in the
list will always be <code class="literal">{val_len,Size::integer()}</code>, where <code class="literal">Size</code> is the
size of the value blob in bytes.</p></td></tr></table></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
Error returns
</p><div class="itemizedlist"><ul type="disc"><li><p>
<code class="literal">'key_not_exist'</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the key does not exist.
</li></ul></div></li><li><p>
<code class="literal">{'ts_error', timestamp()}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the <code class="literal">{'testset', timestamp()}</code> flag
    was used and there was a timestamp mismatch. The <code class="literal">timestamp()</code> in
    the return is the current value of the existing key’s timestamp.
</li></ul></div></li><li><p>
<code class="literal">'invalid_flag_present'</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because an invalid <code class="literal">do_op_flag()</code> was found
    in the <code class="literal">Flags</code> argument.
</li></ul></div></li><li><p>
<code class="literal">'brick_not_available'</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the chain that is responsible for
    this key is currently length zero and therefore unavailable.
</li></ul></div></li><li><p>
<code class="literal">{{'nodedown',node()},{'gen_server','call',term()}}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the server brick handling the request
    has crashed or else a network partition has occurred between the
    client and server. The client should resend the query after a
    short delay, on the assumption that the Admin Server will have
    detected the failure and taken steps to repair the chain.
</li><li>
<code class="literal">node() = atom()</code>
</li></ul></div></li></ul></div></dd></dl></div><p>ALIASES</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><div class="itemizedlist"><ul type="disc"><li><p>
brick_simple:get/2
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">brick_simple:get(Tab, Key).</code>
</li></ul></div></li><li><p>
brick_simple:get/3
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">brick_simple:get(Tab, Key, Flags).</code>
</li><li>
<code class="literal">brick_simple:get(Tab, Key, Timeout).</code>
</li></ul></div></li></ul></div></dd></dl></div><p>EXAMPLES</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
Successful retrieval of a key-value pair:
</p><pre class="screen">&gt; brick_simple:get(tab1, "goo").
{ok,1271543165272432,&lt;&lt;"value7"&gt;&gt;}</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Successful retrieval of a key without its associated value blob:
</p><pre class="screen">&gt; brick_simple:get(tab1, "goo", ['witness']).
{ok,1271543165272432}</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Failed attempt to retrieve a key that does not exist:
</p><pre class="screen">&gt; brick_simple:get(tab1, "moo").
key_not_exist</pre></dd></dl></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="brick-simple-get-many"></a>3.6. brick_simple:get_many/5</h3></div></div></div><p>SYNOPSIS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
<span class="strong"><strong>brick_simple:get_many(Tab, Key, MaxNum, Flags, Timeout).</strong></span>
</dd></dl></div><p>DESCRIPTION</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
Get many keys from a single chain in the table <code class="literal">Tab</code>, up to a maximum
of <code class="literal">MaxNum</code> keys. Keys are returned in lexicographic sorting order
starting with the first key <span class="emphasis"><em>after</em></span> the key specified by the <code class="literal">Key</code>
argument. The return list includes a boolean value indicating whether
or not there are more keys after the last key of the return results.
</p><div class="important" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./images/icons/important.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>A single <code class="literal">get_many()</code> function call cannot be used to retrieve
keys from across multiple storage chains. The consistent hash of <code class="literal">Key</code>
will send the <code class="literal">get_many</code> operation to the tail brick in a single
chain; all keys returned will come from that single brick only.</p></td></tr></table></div><p>PARAMETERS</p></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Tab</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Name of the table from which to retrieve the keys.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Tab = table()</code>
</li><li>
<code class="literal">table() = atom()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Key</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Key after which to start the <code class="literal">get_many</code> retrieval, proceeding in
  lexicographic order with the first key after the specified <code class="literal">Key</code>.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Key = key()</code>
</li><li>
<code class="literal">key() = iodata()</code>
</li><li>
<code class="literal">iodata() = iolist() | binary()</code>
</li><li><p>
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>While the <code class="literal">Key</code> may be specified as either <code class="literal">iolist()</code> or
<code class="literal">binary()</code>, it will be converted into binary before operation
execution.</p></td></tr></table></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>MaxNum</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Maximum number of keys to return.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">MaxNum = integer()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Flags</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
List of operational flags to apply to the ‘get_many’ operation.
</li><li>
Optional; defaults to empty list.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Flags = flags_list()</code>
</li><li>
<code class="literal">flags_list() = [do_op_flag()]</code>
</li><li>
<code class="literal">do_op_flag() = 'get_all_attribs' | 'witness' | {'binary_prefix',
    binary()} | {'max_bytes', integer()}</code> | <code class="literal">{'max_num', integer()}</code>
</li></ul></div></li><li><p>
Operational flag usage
</p><div class="itemizedlist"><ul type="circle"><li><p>
<code class="literal">'get_all_attribs'</code>
</p><div class="itemizedlist"><ul type="square"><li>
Return all attributes of each key. May be used in combination
       with the <code class="literal">witness</code> flag.
</li></ul></div></li><li><p>
<code class="literal">'witness'</code>
</p><div class="itemizedlist"><ul type="square"><li>
Do not return the value blobs in the result. This flag will
       guarantee that the brick does not require disk access to
       satisfy this request.
</li></ul></div></li><li><p>
<code class="literal">{'binary_prefix', binary()}</code>
</p><div class="itemizedlist"><ul type="square"><li>
Return only keys that have a binary prefix that is exactly
       equal to <code class="literal">binary()</code>.
</li></ul></div></li><li><p>
<code class="literal">{'max_bytes', integer()}</code>
</p><div class="itemizedlist"><ul type="square"><li>
Return only as many keys as the sum of the sizes of their
       corresponding value blobs does not exceed <code class="literal">integer()</code> bytes.
       If this flag is not explicity specified in a client request,
       the value defaults to 2GB.
</li></ul></div></li><li><p>
<code class="literal">{'max_num', integer()}</code>
</p><div class="itemizedlist"><ul type="square"><li>
Maxinum number of keys to return. Defaults to 10. Note: This
       flag is duplicative of the MaxNum argument in purpose.
</li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Timeout</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Operation timeout in milliseconds.
</li><li>
Optional; defaults to 15000.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Timeout = timeout()</code>
</li><li>
<code class="literal">timeout() = integer() | 'infinity'</code>
</li></ul></div></li></ul></div></dd></dl></div><p>RETURNS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
Success returns
</p><div class="itemizedlist"><ul type="disc"><li><p>
<code class="literal">{ok, {[{key(), timestamp(), val()}], boolean()}}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Success return when the <code class="literal">get_many</code> request uses neither the
    <code class="literal">'witness'</code> flag nor the <code class="literal">'get_all_attribs'</code> flag.
</li><li>
<code class="literal">timestamp() = integer()</code>
</li><li>
<code class="literal">val() = iodata()</code>
</li><li>
<code class="literal">iodata() = iolist() | binary()</code>
</li><li>
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</li></ul></div></li><li><p>
<code class="literal">{ok, {[{key(), timestamp()}], boolean()}}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Success return when the <code class="literal">get_many</code> uses <code class="literal">'witness'</code> but not
    <code class="literal">'get_all_attribs'</code>.
</li></ul></div></li><li><p>
<code class="literal">{ok, {[{key(), timestamp(), proplist()}], boolean()}}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Success return when the <code class="literal">get_many</code> uses both <code class="literal">'witness'</code> and
    <code class="literal">'get_all_attribs'</code>.
</li><li>
<code class="literal">proplist() = [property()]</code>
</li><li>
<code class="literal">property() = atom() | {term(), term()}</code>
</li></ul></div></li><li><p>
<code class="literal">{ok, {[{key(), timestamp(), val(), exp_time(), proplist()}],
  boolean()}}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Success return when the <code class="literal">get_many</code> uses <code class="literal">'get_all_attribs'</code> but
    not <code class="literal">'witness'</code>.
</li><li><p>
<code class="literal">exp_time() = time_t()</code>
</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The boolean at the end of the success return indicates whether
or not the chain has more keys lexicographically after the
last key in the return (<code class="literal">true</code> for yes, <code class="literal">false</code> for no). When a <code class="literal">proplist()</code>
is returned, one of the properties in the list will always be
<code class="literal">{val_len,Size::integer()}</code>, where <code class="literal">Size</code> is the size of the value blob
in bytes.</p></td></tr></table></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
Error returns
</p><div class="itemizedlist"><ul type="disc"><li><p>
<code class="literal">'invalid_flag_present'</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because an invalid <code class="literal">do_op_flag()</code> was found
    in the <code class="literal">Flags</code> argument.
</li></ul></div></li><li><p>
<code class="literal">'brick_not_available'</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the chain that is responsible for
    this key is currently length zero and therefore unavailable.
</li></ul></div></li><li><p>
<code class="literal">{{'nodedown',node()},{'gen_server','call',term()}}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the server brick handling the request
    has crashed or else a network partition has occurred between the
    client and server. The client should resend the query after a
    short delay, on the assumption that the Admin Server will have
    detected the failure and taken steps to repair the chain.
</li><li>
<code class="literal">node() = atom()</code>
</li></ul></div></li></ul></div></dd></dl></div><p>ALIASES</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><div class="itemizedlist"><ul type="disc"><li><p>
brick_simple:get_many/3
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">brick_simple:get_many(Tab, Key, MaxNum).</code>
</li></ul></div></li><li><p>
brick_simple:get_many/4
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">brick_simple:get_many(Tab, Key, MaxNum, Flags).</code>
</li><li>
<code class="literal">brick_simple:get_many(Tab, Key, MaxNum, Timeout).</code>
</li></ul></div></li></ul></div></dd></dl></div><p>EXAMPLES</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
Successful retrieval of all keys from a table that currently has only
two keys. The boolean <code class="literal">false' indicates that there are no keys
following the `foo</code> key:
</p><pre class="screen">&gt; brick_simple:get_many(tab1, "", 5).
{ok,{[{&lt;&lt;"another"&gt;&gt;,1271543102911775,&lt;&lt;"yes!"&gt;&gt;},
      {&lt;&lt;"foo"&gt;&gt;,1271543165272987,&lt;&lt;"Foo again?"&gt;&gt;}],
     false}}</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Successful retrieval of all keys from a table that currently has only
two keys, using the <code class="literal">witness</code> flag in the request.
</p><pre class="screen">&gt; brick_simple:get_many(tab1, "", 5, ['witness']).
{ok,{[{&lt;&lt;"another"&gt;&gt;,1271543102911775},
      {&lt;&lt;"foo"&gt;&gt;,1271543165272987}],
     false}}</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Successful retrieval of all keys from a table that currently has only
two keys, using the <code class="literal">get_all_attribs</code> flag in the request.
</p><pre class="screen">&gt; brick_simple:get_many(tab1, "", 5).
{ok,{[{&lt;&lt;"another"&gt;&gt;,1271543102911775,&lt;&lt;"yes!"&gt;&gt;,0,
       [{val_len,4}]},
      {&lt;&lt;"foo"&gt;&gt;,1271543165272987,&lt;&lt;"Foo again?"&gt;&gt;,0,[{val_len,6}]}],
     false}}</pre></dd></dl></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="brick-simple-delete"></a>3.7. brick_simple:delete/4</h3></div></div></div><p>SYNOPSIS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
<span class="strong"><strong>brick_simple:delete(Tab, Key, Flags, Timeout).</strong></span>
</dd></dl></div><p>DESCRIPTION</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
Delete key <code class="literal">Key</code> from the table <code class="literal">Tab</code>.
</dd></dl></div><p>PARAMETERS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Tab</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Name of the table from which to delete the key and its associated
  value.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Tab = table()</code>
</li><li>
<code class="literal">table() = atom()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Key</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Key to delete from the table.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Key = key()</code>
</li><li>
<code class="literal">key() = iodata()</code>
</li><li>
<code class="literal">iodata() = iolist() | binary()</code>
</li><li><p>
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>While the <code class="literal">Key</code> may be specified as either <code class="literal">iolist()</code> or
<code class="literal">binary()</code>, it will be converted into binary before operation
execution.</p></td></tr></table></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Flags</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
List of operational flags to apply to the ‘delete’ operation.
</li><li>
Optional; defaults to empty list.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Flags = flags_list()</code>
</li><li>
<code class="literal">flags_list() = [do_op_flag()]</code>
</li><li>
<code class="literal">do_op_flag() = {'testset', timestamp()} |'must_exist' | 'must_not_exist'</code>
</li><li>
<code class="literal">timestamp() = integer()</code>
</li></ul></div></li><li><p>
Operational flag usage
</p><div class="itemizedlist"><ul type="circle"><li><p>
<code class="literal">{'testset', timestamp()}</code>
</p><div class="itemizedlist"><ul type="square"><li>
Fail the operation if the existing key’s timestamp is not
       exactly equal to <code class="literal">timestamp()</code>.  If used inside a
       <a class="ulink" href="#brick-simple-do" target="_top">micro-transaction</a>, abort the transaction
       if the key’s timestamp is not exactly equal to
       <code class="literal">timestamp()</code>. This flag has priority over the <code class="literal">'must_exist'</code> and
       <code class="literal">'must_not_exist'</code> flags
</li></ul></div></li><li><p>
<code class="literal">'must_exist'</code>
</p><div class="itemizedlist"><ul type="square"><li>
For use inside a <a class="ulink" href="#brick-simple-do" target="_top">micro-transaction</a>:
       abort the transaction if the key does not exist.
</li></ul></div></li><li><p>
<code class="literal">'must_not_exist'</code>
</p><div class="itemizedlist"><ul type="square"><li>
For use inside a <a class="ulink" href="#brick-simple-do" target="_top">micro-transaction</a>:
       abort the transaction if the key exists. This flag may be useful
       when the relationship between two or more keys is important to
       the client application.
</li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Timeout</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Operation timeout in milliseconds.
</li><li>
Optional; defaults to 15000.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Timeout = timeout()</code>
</li><li>
<code class="literal">timeout() = integer() | 'infinity'</code>
</li></ul></div></li></ul></div></dd></dl></div><p>RETURNS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
Success return
</p><div class="itemizedlist"><ul type="disc"><li>
<code class="literal">'ok'</code>
</li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
Error returns
</p><div class="itemizedlist"><ul type="disc"><li><p>
<code class="literal">'key_not_exist'</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the key does not exist.
</li></ul></div></li><li><p>
<code class="literal">{'ts_error', timestamp()}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the <code class="literal">{'testset', timestamp()}</code> flag
    was used and there was a timestamp mismatch. The <code class="literal">timestamp()</code> in
    the return is the current value of the existing key’s timestamp.
</li><li>
<code class="literal">timestamp() = integer()</code>
</li></ul></div></li><li><p>
<code class="literal">'invalid_flag_present'</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because an invalid <code class="literal">do_op_flag()</code> was found
    in the <code class="literal">Flags</code> argument.
</li></ul></div></li><li><p>
<code class="literal">'brick_not_available'</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the chain that is responsible for
    this key is currently length zero and therefore unavailable.
</li></ul></div></li><li><p>
<code class="literal">{{'nodedown',node()},{'gen_server','call',term()}}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the server brick handling the request
    has crashed or else a network partition has occurred between the
    client and server. The client should resend the query after a
    short delay, on the assumption that the Admin Server will have
    detected the failure and taken steps to repair the chain.
</li><li>
<code class="literal">node() = atom()</code>
</li></ul></div></li></ul></div></dd></dl></div><p>ALIASES</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><div class="itemizedlist"><ul type="disc"><li><p>
brick_simple:delete/2
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">brick_simple:delete(Tab, Key).</code>
</li></ul></div></li><li><p>
brick_simple:delete/3
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">brick_simple:delete(Tab, Key, Flags).</code>
</li><li>
<code class="literal">brick_simple:delete(Tab, Key, Timeout).</code>
</li></ul></div></li></ul></div></dd></dl></div><p>EXAMPLES</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
Successful deletion of a key and its associated value and attributes:
</p><pre class="screen">&gt; brick_simple:delete(tab1, &lt;&lt;"foo"&gt;&gt;).
ok</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Failed attempt to delete a key that does not exist:
</p><pre class="screen">&gt; brick_simple:delete(tab1, "key6").
key_not_exist</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Failed attempt to delete a key for which we have incorrectly specified
its current timestamp:
</p><pre class="screen">&gt; brick_simple:delete(tab1, "goo", [{'testset', 12345}]).
{ts_error,1271543165272987}</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Successful deletion of a key for which we have correctly specified its
current timestamp:
</p><pre class="screen">&gt; brick_simple:delete(tab1, "goo", [{'testset', 1271543165272987}]).
ok</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Successful deletion of a key, using a non-default operation timeout:
</p><pre class="screen">&gt; brick_simple:delete(tab1, "key3", 30000).
ok</pre></dd></dl></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="brick-simple-do"></a>3.8. brick_simple:do/4</h3></div></div></div><p>SYNOPSIS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
<span class="strong"><strong>brick_simple:do(Tab, OpList, OpFlags, Timeout).</strong></span>
</dd></dl></div><p>DESCRIPTION</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
Send a list of primitive operations to the table <code class="literal">Tab</code>. They will be
executed at the same time by a Hibari brick. If the first item in the
<code class="literal">OpList</code> is <code class="literal">brick_server:make_txn()</code> then the list of operations is
executed in the context of a micro-transaction: either all operations
will be executed successfully or none will be executed. We term these
"micro"-transactions because they are subject to certain limitations
that apply to all operations that use the <code class="literal">brick_simple:do()</code> API:
</p><div class="itemizedlist"><ul type="disc"><li>
All impacted keys must be in the same table.
</li><li>
All impacted keys must be in the same chain.
</li><li>
All operations in the transaction must be sent in a single
  <code class="literal">brick_simple:do()</code> call. Unlike some other databases, it is not
  possible to request a transaction handle and to add operations to
  that transaction in an one-by-one, "ad hoc" manner.
</li></ul></div></dd><dt><span class="term">
 
</span></dt><dd>
For further information about micro-transactions, see
<a class="ulink" href="hibari-sysadmin-guide.en.html#micro-transactions" target="_top">Hibari System
Administrator’s Guide, "Micro-Transactions" section</a>.
</dd></dl></div><p>PARAMETERS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Tab</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Name of the table in which to perform the operations.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Tab = table()</code>
</li><li>
<code class="literal">table() = atom()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>OpList</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
List of primitive operations to perform. Each primitive is invoked
  using the <code class="literal">brick_server:make_*()</code> API.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">OpList = do_op_list()</code>
</li><li>
<code class="literal">do_op_list() = [do1_op()]</code>
</li><li><p>
<code class="literal">do1_op() =</code>
</p><div class="itemizedlist"><ul type="square"><li>
<code class="literal">brick_server:make_add(Key, Value, ExpTime, Flags)</code>
</li><li>
<code class="literal">brick_server:make_replace(Key, Value, ExpTime, Flags)</code>
</li><li>
<code class="literal">brick_server:make_set(Key, Value, ExpTime, Flags)</code>
</li><li>
<code class="literal">brick_server:make_get(Key, Flags)</code>
</li><li>
<code class="literal">brick_server:make_get_many(Key, Flags)</code>
</li><li>
<code class="literal">brick_server:make_delete(Key, Flags)</code>
</li><li><p>
<code class="literal">brick_server:make_txn()</code>
</p><div class="itemizedlist"><ul type="disc"><li>
Include <code class="literal">brick_server:make_txn()</code> as the first item in your
           <code class="literal">OpList</code> if you want the <code class="literal">do</code> operation to be executed as
           an atomic transaction.
</li></ul></div></li><li>
Note that the arguments for each primitive are the same as
       those for the primitives when they are executed on their own,
       with the exclusion of the <code class="literal">Tab</code> and <code class="literal">Timeout</code> arguments, both
       of which serve as arguments to the overall <code class="literal">do</code> operation
       rather than as arguments to the primitives. For example, an
       <code class="literal">add</code> on its own is <code class="literal">brick_simple:add(Tab, Key, Value, ExpTime,
       Flags, Timeout)</code>, whereas in the context of a <code class="literal">do</code> operation an
       <code class="literal">add</code> primitive is <code class="literal">brick_server:make_add(Key, Value, ExpTime,
       Flags)</code>.
</li><li>
For further information about each primitive, see
       <a class="ulink" href="#brick-simple-add" target="_top">brick_simple:add/6</a>,
       <a class="ulink" href="#brick-simple-replace" target="_top">brick_simple:replace/6</a>,
       <a class="ulink" href="#brick-simple-set" target="_top">brick_simple:set/6</a>,
       <a class="ulink" href="#brick-simple-get" target="_top">brick_simple:get/4</a>,
       <a class="ulink" href="#brick-simple-get-many" target="_top">brick_simple:get_many/5</a>, and
       <a class="ulink" href="#brick-simple-delete" target="_top">brick_simple:delete/4</a>.
</li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>OpFlags</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
List of operational flags to apply to the overall ‘do’ operation.
</li><li>
Optional; defaults to empty list.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">OpFlags = do_flags_list()</code>
</li><li>
<code class="literal">do_flags_list() = [do_flag()]</code>
</li><li>
<code class="literal">do_flag() = 'fail_if_wrong_role' | 'ignore_role'</code>
</li></ul></div></li><li><p>
Operational flag usage
</p><div class="itemizedlist"><ul type="circle"><li><p>
<code class="literal">'fail_if_wrong_role'</code>
</p><div class="itemizedlist"><ul type="square"><li>
If the <span class="emphasis"><em>do</em></span> operation is sent to the wrong brick in the target
       chain (e.g. a <span class="emphasis"><em>read</em></span> request mistakenly sent to the <span class="emphasis"><em>head</em></span> brick or
       a <span class="emphasis"><em>write</em></span> request mistakenly sent to the <span class="emphasis"><em>tail</em></span> brick), fail the
       transaction immediately. If this flag is not used, the default
       behavior is for the incorrect brick to forward the request to the
       correct brick.
</li></ul></div></li><li><p>
<code class="literal">'ignore_role'</code>
</p><div class="itemizedlist"><ul type="square"><li>
If this flag is used, then whichever brick receives the request
       will reply to the request directly, regardless of the brick’s assigned
       role.
</li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Timeout</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Operation timeout in milliseconds.
</li><li>
Optional; defaults to 15000.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Timeout = timeout()</code>
</li><li>
<code class="literal">timeout() = integer() | 'infinity'</code>
</li></ul></div></li></ul></div></dd></dl></div><p>RETURNS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
Success return
</p><div class="itemizedlist"><ul type="disc"><li><p>
<code class="literal">[do1_res_ok]</code>
</p><div class="itemizedlist"><ul type="circle"><li>
List of <code class="literal">do1_res_ok</code>, one for each primitive operation specified
    in the <code class="literal">do</code> request. Return list order corresponds to the order in
    which primitive operations are listed in the request’s
    <code class="literal">OpList</code>. Note that if the <code class="literal">do</code> request does not use transaction
    semantics, then some individual primitive operations may fail
    without the overall <code class="literal">do</code> operation failing.
</li><li>
Within the return list, possible <code class="literal">do1_res_ok</code> returns to each
    individual primitive operation are the same as the possible
    returns that the primitive operation type could generate if it
    were executed on its own. For example, within the <code class="literal">do</code> operation’s
    success return list, the possible returns for a primitive <code class="literal">add</code>
    operation are the same as the returns described in the
    <a class="ulink" href="#brick-simple-add" target="_top">brick_simple:add/6</a> section; potential
    returns to a primitive <code class="literal">replace</code> operation are the same as those
    described in the
    <a class="ulink" href="#brick-simple-replace" target="_top">brick_simple:replace/6</a> section; and
    likewise for <a class="ulink" href="#brick-simple-set" target="_top">set</a>,
    <a class="ulink" href="#brick-simple-get" target="_top">get</a>,
    <a class="ulink" href="#brick-simple-get-many" target="_top">get_many</a>, and
    <a class="ulink" href="#brick-simple-delete" target="_top">delete</a>.
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
Error returns
</p><div class="itemizedlist"><ul type="disc"><li><p>
<code class="literal">{txn_fail, [{integer(), do1_res_fail()}]}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
Operation failed because transaction semantics were used in the
    <code class="literal">do</code> request and one or more primitive operations within the
    transaction failed. The <code class="literal">integer()</code> identifies the failed
    primitive operation by its position within the request’s
    <code class="literal">OpList</code>. For example, a 2 indicates that the second primitive
    listed in the request’s <code class="literal">OpList</code> failed. Note that this position
    identifier does not count the <code class="literal">txn()</code> specifier at the start of
    the <code class="literal">OpList</code>.
</li><li><p>
<code class="literal">do1_res_fail()</code> indicates the type of failure for the failed
    primitive operation. Possibilities are:
</p><div class="itemizedlist"><ul type="square"><li><p>
<code class="literal">{'key_exists', timestamp()}</code>
</p><div class="itemizedlist"><ul type="disc"><li>
<code class="literal">timestamp() = integer()</code>
</li></ul></div></li><li>
<code class="literal">'key_not_exist'</code>
</li><li>
<code class="literal">{'ts_error', timestamp()}</code>
</li><li>
<code class="literal">'invalid_flag_present'</code>
</li></ul></div></li></ul></div></li><li><p>
<code class="literal">'invalid_flag_present'</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because an invalid <code class="literal">do_flag()</code> was found in
    the <code class="literal">do</code> request’s <code class="literal">OpFlags</code> argument. Note this is a different
    error than an invalid flag being found within an individual
    primitive.
</li></ul></div></li><li><p>
<code class="literal">'brick_not_available'</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the chain that is responsible for
    this key is currently length zero and therefore unavailable.
</li></ul></div></li><li><p>
<code class="literal">{{'nodedown',node()},{'gen_server','call',term()}}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
The operation failed because the server brick handling the request
    has crashed or else a network partition has occurred between the
    client and server. The client should resend the query after a
    short delay, on the assumption that the Admin Server will have
    detected the failure and taken steps to repair the chain.
</li><li>
<code class="literal">node() = atom()</code>
</li></ul></div></li></ul></div></dd></dl></div><p>ALIASES</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><div class="itemizedlist"><ul type="disc"><li><p>
brick_simple:do/2
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">brick_simple:do(Tab, OpList).</code>
</li></ul></div></li><li><p>
brick_simple:do/3
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">brick_simple:do(Tab, OpList, Timeout).</code>
</li></ul></div></li></ul></div></dd></dl></div><p>EXAMPLES</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
Successful <code class="literal">do</code> operation adding two new keys to table <code class="literal">tab1</code>, without
transaction semantics:
</p><pre class="screen">&gt; brick_simple:do(tab1, [brick_server:make_add("foo3", "bar3"),brick_server:make_add("foo4", "bar4")]).
[ok,ok]</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Successful creation of two <code class="literal">get</code> primitives <code class="literal">Do1</code> and <code class="literal">Do2</code>, and their
subsequent combination into a <code class="literal">do</code> request, without transaction
semantics:
</p><pre class="screen">&gt; Do1 = brick_server:make_get("foo").
{get,&lt;&lt;"foo"&gt;&gt;,[]}
&gt; Do2 = brick_server:make_get("foo2").
{get,&lt;&lt;"foo2"&gt;&gt;,[]}
&gt; brick_simple:do(tab1, [Do1, Do2]).
[{ok,1271543102911775,&lt;&lt;"Foo again?"&gt;&gt;},key_not_exist]</pre></dd><dt><span class="term">
 
</span></dt><dd><p>
Failed operation with transaction semantics. Because transaction
semantics are used, the failure of the primitive <code class="literal">Do2b</code> causes the
entire operation to fail.
</p><pre class="screen">&gt; Do1b = brick_server:make_get("foo").
{get,&lt;&lt;"foo"&gt;&gt;,[]}
&gt; Do2b = brick_server:make_get("foo2", [must_exist]).
{get,&lt;&lt;"foo2"&gt;&gt;,[must_exist]}
&gt; brick_simple:do(tab1, [brick_server:make_txn(), Do1b, Do2b]).
{txn_fail,[{2,key_not_exist}]}</pre></dd></dl></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="brick-simple-fold-table"></a>3.9. brick_simple:fold_table/7</h3></div></div></div><p>SYNOPSIS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
<span class="strong"><strong>brick_simple:fold_table(Tab, Fun, Acc, NumItems, Flags, MaxParallel, Timeout).</strong></span>
</dd></dl></div><p>DESCRIPTION</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
Attempt a fold operation across all keys in a table. For general information
about the Erlang fold function that underlies this operations, see <a class="ulink" href="http://www.erlang.org/doc/man/lists.html#foldl-3" target="_top">http://www.erlang.org/doc/man/lists.html#foldl-3</a>.
</dd></dl></div><div class="important" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./images/icons/important.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Do not execute this operation while a data migration is
being performed.</p></td></tr></table></div><p>PARAMETERS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Tab</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Name of the table across which to perform the fold operation.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Tab = table()</code>
</li><li>
<code class="literal">table() = atom()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Fun</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Function to apply to successive elements of the list.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Fun  = fun_arity_2()</code>
</li><li><p>
<code class="literal">fun_arity_2()</code> arguments =
</p><div class="itemizedlist"><ul type="square"><li><p>
<code class="literal">{ChainName, Tuple_from_get_many}</code>
</p><div class="itemizedlist"><ul type="disc"><li>
<code class="literal">Tuple_From_get_many</code> is a single result tuple from a
         <a class="ulink" href="#brick-simple-get-many" target="_top">brick_simple:get_many()</a>
         result. Its format can vary according to the <code class="literal">Flags</code>
         argument, which is passed as-is to a <code class="literal">get_many()</code> call. For
         example, if <code class="literal">Flags</code> = <code class="literal">[]</code>, then <code class="literal">Tuple_From_get_many</code> will
         match <code class="literal">{Key, TS, Value}</code>. If <code class="literal">Flags</code> = <code class="literal">[witness]</code>, then
         <code class="literal">Tuple_From_get_many</code> will match <code class="literal">{Key, TS}</code>.
</li></ul></div></li><li><p>
<code class="literal">Acc</code>
</p><div class="itemizedlist"><ul type="disc"><li>
The accumulator term.
</li></ul></div></li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Acc</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Initial value of the accumulator term.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Acc  = term()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>NumItems</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Batch size used for <code class="literal">get_many</code> operations used by the fold function.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">NumItems  = integer()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Flags</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
List of operational flags to apply to the ‘fold_table’
  operation. The supported flags are the same as those for
  <a class="ulink" href="#brick-simple-get-many" target="_top">brick_simple:get_many()</a>.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Flags = flags_list()</code>
</li><li>
<code class="literal">flags_list() = [do_op_flag() | property()]</code>
</li><li>
<code class="literal">do_op_flag() = 'get_all_attribs' | 'witness' | {'binary_prefix',
    binary()} | {'max_bytes', integer()}</code>
</li><li>
<code class="literal">property() = atom() | {term(), term()}</code>
</li></ul></div></li><li><p>
Operational flag usage
</p><div class="itemizedlist"><ul type="circle"><li><p>
<code class="literal">'get_all_attribs'</code>
</p><div class="itemizedlist"><ul type="square"><li>
Return all attributes of each key. May be used in combination
       with the <code class="literal">witness</code> flag.
</li></ul></div></li><li><p>
<code class="literal">'witness'</code>
</p><div class="itemizedlist"><ul type="square"><li>
Do not return the value blobs in the result. This flag will
       guarantee that the brick does not require disk access to
       satisfy this request.
</li></ul></div></li><li><p>
<code class="literal">{'binary_prefix', binary()}</code>
</p><div class="itemizedlist"><ul type="square"><li>
Return only keys that have a binary prefix that is exactly
       equal to <code class="literal">binary()</code>.
</li></ul></div></li><li><p>
<code class="literal">{'max_bytes', integer()}</code>
</p><div class="itemizedlist"><ul type="square"><li>
Return only as many keys as the sum of the sizes of their
       corresponding value blobs does not exceed <code class="literal">integer()</code> bytes.
</li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>MaxParallel</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
If <code class="literal">MaxParallel</code> = 0, a true fold will be performed. If
  <code class="literal">MaxParallel</code> &gt;= 1, then an independent fold will be performed on
  each chain, with up to <code class="literal">MaxParallel</code> number of folds running in
  parallel. The result from each chain fold will be returned to the
  caller as-is, i.e. will <span class="strong"><strong>not</strong></span> be combined like in a "reduce" phase
  of a map-reduce cycle.
</li><li>
Optional; defaults to 0.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">MaxParallel = integer()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Timeout</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Operation timeout in milliseconds.
</li><li>
Optional; defaults to 5000.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Timeout = timeout()</code>
</li><li>
`timeout() = integer()
</li></ul></div></li></ul></div></dd></dl></div><p>RETURNS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
Success return
</p><div class="itemizedlist"><ul type="disc"><li><p>
<code class="literal">{ok, Acc, Iterations}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Acc = term()</code>
</li><li>
<code class="literal">Iterations = integer()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
Error return
</p><div class="itemizedlist"><ul type="disc"><li><p>
<code class="literal">{error, GdssError, Acc, Iterations}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">GdssError = term()</code>
</li><li>
<code class="literal">Acc = term()</code>
</li><li>
<code class="literal">Iterations = integer()</code>
</li></ul></div></li></ul></div></dd></dl></div><p>ALIASES</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><div class="itemizedlist"><ul type="disc"><li><p>
brick_simple:fold_table/5
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">brick_simple:fold_table(Tab, Fun, Acc, NumItems, Flags).</code>
</li></ul></div></li><li><p>
brick_simple:fold_table/6
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">brick_simple:fold_table(Tab, Fun, Acc, NumItems, Flags,
    MaxParallel).</code>
</li></ul></div></li></ul></div></dd></dl></div><p>EXAMPLES</p><p><span class="emphasis"><em>to be added</em></span></p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="brick-simple-fold-key"></a>3.10. brick_simple:fold_key_prefix/9</h3></div></div></div><p>SYNOPSIS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
<span class="strong"><strong>brick_simple:fold_key_prefix(Tab, Prefix, StartKey, Fun, Acc, Flags0,
 NumItems,SleepTime,Timeout).</strong></span>
</dd></dl></div><p>DESCRIPTION</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
For a binary key prefix <code class="literal">Prefix</code>, fold over all keys in table <code class="literal">Tab</code>
starting with <code class="literal">StartKey</code>, sleeping for <code class="literal">SleepTime</code> milliseconds
between iterations and using <code class="literal">Flags</code> and <code class="literal">NumItems</code> as arguments to
<a class="ulink" href="#brick-simple-get-many" target="_top">brick_simple:get_many()</a>. For general
information about the Erlang fold function that underlies this operations,
see <a class="ulink" href="http://www.erlang.org/doc/man/lists.html#foldl-3" target="_top">http://www.erlang.org/doc/man/lists.html#foldl-3</a>.
</dd></dl></div><div class="important" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./images/icons/important.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Do not execute this operation while a data migration is
being performed.</p></td></tr></table></div><p>PARAMETERS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Tab</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Name of the table in which to perform the fold operation.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Tab = table()</code>
</li><li>
<code class="literal">table() = atom()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Prefix</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Key prefix for which to perform the fold operation.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Prefix = binary()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>StartKey</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Key at which to initiate the fold operation.
</li><li>
Optional; defaults to equal your specified <code class="literal">Prefix</code>.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">StartKey = binary()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Fun</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Function to apply to successive elements of the list.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Fun  = fun_arity_2()</code>
</li><li><p>
<code class="literal">fun_arity_2()</code> arguments =
</p><div class="itemizedlist"><ul type="square"><li><p>
<code class="literal">Tuple_from_get_many</code>
</p><div class="itemizedlist"><ul type="disc"><li>
<code class="literal">Tuple_From_get_many</code> is a single result tuple from a
         <a class="ulink" href="#brick-simple-get-many" target="_top">brick_simple:get_many()</a>
         result. Its format can vary according to the <code class="literal">Flags0</code>
         argument, which is passed as-is to a <code class="literal">get_many()</code> call. For
         example, if <code class="literal">Flags0</code> = <code class="literal">[]</code>, then <code class="literal">Tuple_From_get_many</code> will
         match <code class="literal">{Key, TS, Value}</code>. If <code class="literal">Flags0</code> = <code class="literal">[witness]</code>, then
         <code class="literal">Tuple_From_get_many</code> will match <code class="literal">{Key, TS}</code>.
</li></ul></div></li><li><p>
<code class="literal">UserAccumulatorTerm</code>
</p><div class="itemizedlist"><ul type="disc"><li>
<span class="emphasis"><em>description to be added</em></span>
</li></ul></div></li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Acc</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
<span class="emphasis"><em>description to be added</em></span>.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Acc  = term()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Flags0</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
List of operational flags to apply to the <code class="literal">fold_key_prefix</code>
  operation. The supported flags are the same as those for
  <a class="ulink" href="#brick-simple-get-many" target="_top">brick_simple:get_many()</a>, excluding the
  <code class="literal">{'binary_prefix', binary()}</code> flag. This flag is inappropriate since
  the key prefix is passed directly through the <code class="literal">Prefix</code> argument of
  <code class="literal">brick_simple:fold_key_prefix()</code>.
</li><li>
Mandatory.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Flags0 = 'get_all_attribs' | 'witness' | {'max_bytes', integer()}</code>
</li></ul></div></li><li><p>
Operational flag usage
</p><div class="itemizedlist"><ul type="circle"><li><p>
<code class="literal">'get_all_attribs'</code>
</p><div class="itemizedlist"><ul type="square"><li>
Return all attributes of each key. May be used in combination
       with the <code class="literal">witness</code> flag.
</li></ul></div></li><li><p>
<code class="literal">'witness'</code>
</p><div class="itemizedlist"><ul type="square"><li>
Do not return the value blobs in the result. This flag will
       guarantee that the brick does not require disk access to
       satisfy this request.
</li></ul></div></li><li><p>
<code class="literal">{'max_bytes', integer()}</code>
</p><div class="itemizedlist"><ul type="square"><li>
Return only as many keys as the sum of the sizes of their
       corresponding value blobs does not exceed <code class="literal">integer()</code> bytes.
</li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>NumItems</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
<span class="emphasis"><em>description to be added</em></span>.
</li><li>
Optional; defaults to 100.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">NumItems  = integer()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>SleepTime</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Sleep time between interations, in milliseconds.
</li><li>
Optional; defaults to 0.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">SleepTime = integer()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
<span class="strong"><strong>Timeout</strong></span>
</p><div class="itemizedlist"><ul type="disc"><li>
Operation timeout in milliseconds.
</li><li>
Optional; defaults to 15000.
</li><li><p>
Type:
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Timeout = timeout()</code>
</li><li>
`timeout() = integer()
</li></ul></div></li></ul></div></dd></dl></div><p>RETURNS</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p>
Success return
</p><div class="itemizedlist"><ul type="disc"><li><p>
<code class="literal">{ok, Acc, Iterations}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">Acc = term()</code>
</li><li>
<code class="literal">Iterations = integer()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p>
Error return
</p><div class="itemizedlist"><ul type="disc"><li><p>
<code class="literal">{error, GdssError, Acc, Iterations}</code>
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">GdssError = term()</code>
</li><li>
<code class="literal">Acc = term()</code>
</li><li>
<code class="literal">Iterations = integer()</code>
</li></ul></div></li></ul></div></dd></dl></div><p>ALIASES</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><div class="itemizedlist"><ul type="disc"><li><p>
brick_simple:fold_key_prefix/5
</p><div class="itemizedlist"><ul type="circle"><li>
<code class="literal">brick_simple:fold_key_prefix(Tab, Prefix, Fun, Acc, Flags).</code>
</li></ul></div></li></ul></div></dd></dl></div><p>EXAMPLES</p><p><span class="emphasis"><em>to be added</em></span></p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="client-api-ubf"></a>4. Client API: UBF</h2></div></div></div><p><a class="ulink" href="http://github.com/norton/ubf" target="_top">The UBF protocol</a> is a
formally-specified family of protocols that are supported by a large
number of client languages.  This section attempts to describe the
layers of the UBF protocol stack, how to use the UBF client in Erlang
and other languages, and how to use that client to access a Hibari
storage cluster.</p><p>The Hibari source distribution includes UBF/EBF protocol support for the
following languages:</p><div class="itemizedlist"><ul type="disc"><li>
Erlang, see <a class="xref" href="#using-ubf-erlang-client" title="4.5. Using the UBF Client Library for Erlang">Section 4.5, “Using the UBF Client Library for Erlang”</a>
</li><li>
Java, see <a class="xref" href="#using-ubf-java-client" title="4.6. Using the UBF Client Library for Java">Section 4.6, “Using the UBF Client Library for Java”</a>
</li><li>
Python, see <a class="xref" href="#using-ubf-python-client" title="4.7. Using the EBF Client Library for Python">Section 4.7, “Using the EBF Client Library for Python”</a>
</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="hibari-server-impl-of-ubf-proto-stack"></a>4.1. The Hibari Server’s Implementation of the UBF Protocol Stack</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">
UBF(A): Bottom Layer, transport and session protocol layer
</span></dt><dd><p>
This layer plays the same basic role as many other serialized data
transport protocols that use TCP for host-to-host transport, such as
<a class="ulink" href="http://en.wikipedia.org/wiki/Open_Network_Computing_Remote_Procedure_Call" target="_top">ONC-RPC</a>,
<a class="ulink" href="http://en.wikipedia.org/wiki/IIOP" target="_top">CORBA IIOP</a>,
<a class="ulink" href="http://en.wikipedia.org/wiki/Protocol_buffers" target="_top">Protocol Buffers</a>,
and <a class="ulink" href="http://en.wikipedia.org/wiki/Thrift_(protocol)" target="_top">Thrift</a>.
</p><p>Hibari servers support several of these session protocols on top
of a TCP/IP transport protocol.  The choice of session protocol is
a matter of convenience and/or support for the application
developer. Hibari should be as easy for an app developer to use
Ruby and JSON-RPC as it is to use Python and Protocol Buffers.</p><div class="itemizedlist"><ul type="disc"><li>
UBF(A), Joe Armstrong’s original session layer protocol
</li><li>
EBF, the Erlang Binary Format.  The session layer protocol is a
  thin, efficient that uses the Erlang BIFs <code class="literal">term_to_binary()</code> and
  <code class="literal">binary_to_term()</code> to serialize Erlang data terms.  This protocol
  is very closely related to the <a class="ulink" href="http://bert-rpc.org/" target="_top">BERT protocol</a>.
</li><li>
JSON over TCP, also called JSF (the JavaScript
  Format).  Erlang terms are encoded as
  <a class="ulink" href="http://en.wikipedia.org/wiki/JSON" target="_top">JSON terms</a>
  and transmitted directly over a TCP transport.  This
  protocol is not in common use but is easy to implement in the UBF
  server framework.
</li><li>
HTTP, the <a class="ulink" href="http://en.wikipedia.org/wiki/HTTP" target="_top">Hypertext
  Transfer Protocol</a>.  This protocol is used to support Hibari’s
  <a class="ulink" href="http://en.wikipedia.org/wiki/JSON-RPC" target="_top">JSON-RPC</a> server.
</li><li>
<a class="ulink" href="http://en.wikipedia.org/wiki/Thrift_(protocol)" target="_top">Thrift</a>.
  Similar to EBF, except that Thrift’s binary encoding is used for
  the wire protocol instead of UBF(A) or Erlang’s native wire
  formats.
</li><li>
<a class="ulink" href="http://en.wikipedia.org/wiki/Protocol_buffers" target="_top">Protocol Buffers</a>.
  Similar to EBF, except that Google’s Protocol Buffers binary
  encoding is used for the wire protocol instead of UBF(A) or
  Erlang’s native wire formats.
  <span class="strong"><strong>Hibari support is experimental (i.e. not yet implemented).</strong></span>
</li><li>
<a class="ulink" href="http://hadoop.apache.org/avro/docs/current/" target="_top">Avro</a>.
  Similar to EBF, except that Avro’s binary encoding is used for the
  wire protocol instead of UBF(A) or Erlang’s native wire formats.
  <span class="strong"><strong>Hibari support is experimental (i.e. not yet implemented).</strong></span>
</li></ul></div></dd><dt><span class="term">
UBF(B): Middle Layer, the "contract"
</span></dt><dd><p>
UBF(B) is a programming language for describing types in UBF(A)
and protocols between clients and servers. UBF(B) is roughly
equivalent to to Verified XML, XML-schemas, SOAP and WDSL.
</p><p>This layer enforces a protocol "contract", a formal specification of
all data sent by the client and by the server.  Any data that does not
precisely conform to the protocol is rejected by the contract checker
(which is embedded in the server).  If the client wishes, it may also
use the contract checker to validate data sent by the server, though
this not commonly done.</p></dd><dt><span class="term">
UBF( C): Top Layer, the UBF Metaprotocol
</span></dt><dd>
The metaprotocol is used at the beginning of a UBF session to select
one of the UBF(B) contracts that the TCP listener is capable of
offering.  At the moment, Hibari servers support only the "gdss"
contract, but other contracts may be added in the future.
</dd></dl></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ubf-representation-of-strings"></a>4.2. UBF representation of strings vs. binaries</h3></div></div></div><p>The Erlang language does not have a data type specifically for
strings.  Instead, strings are typically represented as lists of
integers (ASCII byte values) and/or binaries.</p><p>A UBF contract makes a distinction between a string, list, and
binary.  In the case of a string, UBF(A) encodes a string using the
notation <code class="literal">{'#S', "Hello, world!"}</code> to represent the string "Hello,
world!".</p><p>This string encoding is cumbersome to use for developers; in Erlang,
the <code class="literal">ubf.hrl</code> header file includes a macro <code class="literal">?S("Hello, world!")</code> as a
slightly less ugly shortcut.  When using other languages, the 2-tuple
and the atom <code class="literal">'#S'</code>  would be created as any other 2-tuple and atom.</p><p>Fortunately, there is only one case where the string type is
necessary: using the <code class="literal">startSession</code> metaprotocol command to start
using the Hibari data server contract.  An example will be shown
below.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="using-ubf-in-any-language"></a>4.3. Steps for Using a UBF-based Protocol in Any Language</h3></div></div></div><p>The steps to use a UBF-based protocol are the same in any language.</p><div class="orderedlist"><ol type="1"><li><p>
Create a connection to the UBF server.
</p><div class="itemizedlist"><ul type="disc"><li>
… or the EBF server, or the JSON-RPC server, or the Thrift
server, or the ….
</li></ul></div></li><li>
Use the UBF metaprotocol to start using the <code class="literal">gdss</code> contract,
   i.e. the Hibari server contract.
</li><li>
Send one or more Hibari server queries and decode the respective
   server responses.
</li><li>
Close the connection to the UBF server.
</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="the-hibari-ubf-protocol-contract"></a>4.4. The Hibari UBF Protocol Contract</h3></div></div></div><p>The Hibari UBF Protocol contract can be found in the file
<code class="literal">ubf_gdss_plugin.con</code>.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>See the Hibari source code for the most up-to-date version of
this file.  <a class="ulink" href="./misc-codes/ubf_gdss_plugin.con" target="_top">This documentation has a copy
of <code class="literal">ubf_gdss_plugin.con</code></a>, though it may be slightly out-of-date.</p></td></tr></table></div><p>The names of the UBF types specified in the contract may differ
slightly from the names of the types used in this document’s
<a class="xref" href="#client-api-erlang" title="3. Client API: Native Erlang">Section 3, “Client API: Native Erlang”</a>.  For example, the UBF contract calls the key
expiration time time <code class="literal">exp_time()</code>, while the type system in this
document calls it <code class="literal">expiry()</code>.  However, in all cases of slightly
different names, the fundamental data type that both names use is the
same: e.g. <code class="literal">integer()</code> for expiration time.</p><p>For each command, the UBF contract uses the following naming
conventions:</p><div class="itemizedlist"><ul type="disc"><li>
<code class="literal">CommandName_req()</code> for the request sent from client → server,
  e.g. <code class="literal">set_req()</code> for the <code class="literal">set</code> command.
</li><li>
<code class="literal">CommandName_res()</code> for the response sent from server → client,
  e.g. <code class="literal">set_res()</code> for the <code class="literal">set</code> response.
</li></ul></div><p>The general form of a UBF RPC call is a tuple.  The first element in
the tuple is the name of the command, and the following elements are
arguments for that command.  The response can be any Erlang term, but
the Hibari contract will only return the atom or tuple types.</p><p>The following is a mapping of UBF client request type to its Erlang
API function, in alphabetical order.:</p><div class="itemizedlist"><ul type="disc"><li>
<code class="literal">add_req()</code> → <code class="literal">brick_simple:add()</code>, see <a class="xref" href="#brick-simple-add" title="3.2. brick_simple:add/6">Section 3.2, “brick_simple:add/6”</a>.
</li><li>
<code class="literal">delete_req()</code> → <code class="literal">brick_simple:delete()</code>, see
  <a class="xref" href="#brick-simple-delete" title="3.7. brick_simple:delete/4">Section 3.7, “brick_simple:delete/4”</a>.
</li><li>
<code class="literal">do_req()</code> → <code class="literal">brick_simple:do()</code>, see <a class="xref" href="#brick-simple-do" title="3.8. brick_simple:do/4">Section 3.8, “brick_simple:do/4”</a>.
</li><li>
<code class="literal">get_req()</code> → <code class="literal">brick_simple:get()</code>, see <a class="xref" href="#brick-simple-get" title="3.5. brick_simple:get/4">Section 3.5, “brick_simple:get/4”</a>.
</li><li>
<code class="literal">get_many_req()</code> → <code class="literal">brick_simple:get_many()</code>, see
  <a class="xref" href="#brick-simple-get-many" title="3.6. brick_simple:get_many/5">Section 3.6, “brick_simple:get_many/5”</a>.
</li><li>
<code class="literal">replace_req()</code> → <code class="literal">brick_simple:replace()</code>, see
  <a class="xref" href="#brick-simple-replace" title="3.3. brick_simple:replace/6">Section 3.3, “brick_simple:replace/6”</a>.
</li><li>
<code class="literal">set_req()</code> → <code class="literal">brick_simple:set()</code>, see <a class="xref" href="#brick-simple-set" title="3.4. brick_simple:set/6">Section 3.4, “brick_simple:set/6”</a>.
</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="using-ubf-erlang-client"></a>4.5. Using the UBF Client Library for Erlang</h3></div></div></div><div class="important" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./images/icons/important.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><div class="orderedlist"><ol type="1"><li>
When using the Erlang shell for experimentation &amp; prototyping, that
   shell must have the path to the Erlang UBF client
   library in its search path.  The easiest way to do this is to use
   the arguments <code class="literal">-pz /path/to/ubf/library/ebin</code> to your Erlang
   shell’s <code class="literal">erl</code> command.
</li><li>
When writing code, the statement <code class="literal">-include("ubf.hrl").</code> at the top
   of your source module to gain access to the <code class="literal">?S()</code> macro.  Due to
   limitations in the Erlang shell, macros cannot be used in the shell.
</li></ol></div></td></tr></table></div><p>As outlined in <a class="xref" href="#using-ubf-in-any-language" title="4.3. Steps for Using a UBF-based Protocol in Any Language">Section 4.3, “Steps for Using a UBF-based Protocol in Any Language”</a>, the first step is to
create a connection to a Hibari server.  If the Hibari cluster has
multiple nodes, then it doesn’t matter which one that you connect to:
all nodes can handle any UBF request and will route the query to the
proper brick.</p><div class="example"><a id="id515042"></a><p class="title"><b>Example 1. Create a connection to the UBF server (on "localhost" TCP port 7581)</b></p><div class="example-contents"><pre class="screen">(asdf@bb3)54&gt; {ok, P1, _} = ubf_client:connect("localhost", 7581, [{proto, ubf}], 5000).
{ok,&lt;0.139.0&gt;,{'#S', "gdss_meta_server"}}</pre></div></div><br class="example-break" /><p>The second step is to use the UBF metaprotocol to select the Hibari
server, contract, called "gdss",
for all further commands for this connection.</p><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The Hibari server contract is "stateless".  All replies terms from the
<code class="literal">ubf_client:rpc/2</code> function use the form
<code class="literal">{reply,ServerReply,UBF_StateName}</code>.  Because the Hibari server
contract is stateless, the <code class="literal">UBF_StateName</code> will always be the atom
<code class="literal">none</code>.</p></td></tr></table></div><div class="example"><a id="id515088"></a><p class="title"><b>Example 2. Use the UBF metaprotocol to request the "gdss" contract</b></p><div class="example-contents"><pre class="screen">(asdf@bb3)55&gt; ubf_client:rpc(P1, {startSession, {'#S', "gdss"}, []}).
{reply,{ok,ok},none}</pre></div></div><br class="example-break" /><p>Now that the UBF connection is set up, we can use it to set a key "foo".</p><div class="example"><a id="id515104"></a><p class="title"><b>Example 3. Set the key "foo" in table <code class="literal">tab1</code> with the value "foo val", no</b></p><div class="example-contents"><pre class="literallayout">expiration time, no flags, and a timeout of 5 seconds</pre></div></div><br class="example-break" /><pre class="screen">(asdf@bb3)59&gt; ubf_client:rpc(P1, {set, tab1, &lt;&lt;"foo"&gt;&gt;, &lt;&lt;"foo val"&gt;&gt;, 0, [], 5000}).
{reply,ok,none}</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Note that the return value of both the
<code class="literal">set_req()</code> (in the example above) and <code class="literal">get_req()</code> (in the example
below) return the same types described in the <a class="xref" href="#brick-simple-set" title="3.4. brick_simple:set/6">Section 3.4, “brick_simple:set/6”</a>
and <a class="xref" href="#brick-simple-get" title="3.5. brick_simple:get/4">Section 3.5, “brick_simple:get/4”</a>, respectively.</p><p>The only difference is that the <code class="literal">ubf_client:rpc/2</code> function wraps the
server’s reply in a 3-tuple: <code class="literal">{reply,ServerReply,none}</code>.</p></td></tr></table></div><div class="example"><a id="id515168"></a><p class="title"><b>Example 4. Get the key "foo" in table <code class="literal">tab1</code>, timeout in 5 seconds</b></p><div class="example-contents"><pre class="screen">(asdf@bb3)66&gt; ubf_client:rpc(P1, {get, tab1, &lt;&lt;"foo"&gt;&gt;, [], 5000}).
{reply,{ok,1273009092549799,&lt;&lt;"foo val"&gt;&gt;},none}</pre></div></div><br class="example-break" /><p>If the client sends a request that violates the contract, the server
will tell you, as in this example:</p><div class="example"><a id="id515190"></a><p class="title"><b>Example 5. Send a contract-violating request</b></p><div class="example-contents"><pre class="screen">(asdf@bb3)89&gt; ubf_client:rpc(P1, {bbb, 3000}).
{reply,{clientBrokeContract,{bbb,3000},[]},none}</pre></div></div><br class="example-break" /><p>When you are done with the connection, it is polite to close the
connection explicitly.  The server will quietly clean up its side of
the connection if the client forgets to call or cannot call <code class="literal">stop/1</code>.</p><div class="example"><a id="id515213"></a><p class="title"><b>Example 6. Close the UBF connection</b></p><div class="example-contents"><pre class="screen">(asdf@bb3)92&gt; ubf_client:stop(P1).
ok</pre></div></div><br class="example-break" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="using-ubf-java-client"></a>4.6. Using the UBF Client Library for Java</h3></div></div></div><p>The source code for the UBF client library for Java is included in
the UBF source repository at
<a class="ulink" href="http://github.com/norton/ubf" target="_top">http://github.com/norton/ubf</a>, in
the <code class="literal">priv/java</code> subdirectory.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_compiling_the_ubf_client_library_for_java"></a>4.6.1. Compiling the UBF client library for Java</h4></div></div></div><div class="orderedlist"><ol type="1"><li>
Please update your UBF client library code to the "master" branch
   for a date after 10 May 2010, or use the Git tag "v1.14" or later.
   Versions of the library before 10 May 2010 and tag "v1.14" have
   several bugs that will prevent the UBF client from working
   correctly.
</li><li>
Change directory to the <code class="literal">priv/java</code> directory of the UBF client
   library source distribution.
</li><li>
Run <code class="literal">make</code>.
</li><li>
(Optional) Copy the class files in the <code class="literal">classes</code> subdirectory to
   a suitable directory for your Java development environment.
</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_compiling_the_ubf_client_library_test_program_hibaritest_java"></a>4.6.2. Compiling the UBF client library test program HibariTest.java</h4></div></div></div><div class="orderedlist"><ol type="1"><li>
Change directory to the <code class="literal">gdss-ubf-proto/priv/java</code> subdirectory in
   the Hibari source distribution.
</li><li>
Edit the <code class="literal">Makefile</code> to change the <code class="literal">UBF_CLASSES_DIR</code> variable to
   point to the <code class="literal">priv/java/classes</code> subdirectory of the UBF package’s
   source code (or the subdirectory where those classes have been
   formally installed on your system).
</li><li><p>
Run the following two <code class="literal">make</code> commands.  The second assumes that the
   Hibari server’s UBF server is on the local machine, "localhost".
</p><pre class="screen">% make HibariTest
% make run-HibariTest</pre></li><li>
If the Hibari server is not running on the local machine, then run
   <code class="literal">make -n run-HibariTest</code> to show the <code class="literal">java</code> command that is used to
   run the test program.  Cut-and-paste the command into your shell,
   then edit the last argument to specify the hostname of a Hibari
   server.
</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_examining_the_hibaritest_java_test_program"></a>4.6.3. Examining the HibariTest.java test program</h4></div></div></div><p>The <code class="literal">main()</code> function does three things:</p><div class="orderedlist"><ol type="1"><li>
Create a new UBF connection to a Hibari server (hostname/IP address
   is specified in the first command line argument) and requests the
   <code class="literal">gdss</code> contract via the UBF metaprotocol.
</li><li>
Run the small test cases in the <code class="literal">test_hibari_basics()</code> method.
</li><li>
Close the UBF session and exit.
</li></ol></div><div class="example"><a id="the-ubf-hibaritest-main-method"></a><p class="title"><b>Example 7. The ubf.HibariTest.main() method</b></p><div class="example-contents"><pre class="screen">public class HibariTest
{
    public static void main(String[] args)
        throws Exception
    {
        Socket sock = null;
        UBFClient ubf = null;

        try {
            sock = new Socket(args[0], 7581);
            ubf = UBFClient.new_via_sock(new UBFString("gdss"), new UBFList(),
                    new FooHandler(), sock);
        }
        catch (Exception e) {
            System.out.println(e);
            System.exit(1);
        }

        test_hibari_basics(ubf);

        ubf.stopSession();
        System.out.println("Success, it works");
        System.exit(0);
    }
/* ... */
}</pre></div></div><br class="example-break" /><p>The <code class="literal">test_hibari_basics()</code> method performs the same basic UBF
operations as the Python EBF demonstration script described in
<a class="xref" href="#using-ubf-python-client" title="4.7. Using the EBF Client Library for Python">Section 4.7, “Using the EBF Client Library for Python”</a>.  Unlike the Python demo script, the
demo program does not use the Hibari <code class="literal">do()</code> command but rather then
single-operation commands like <code class="literal">get()</code> and <code class="literal">set()</code>.</p><div class="orderedlist"><ol type="1"><li><p>
Delete the key <code class="literal">foo</code> from table <code class="literal">tab1</code>.
</p><pre class="screen">    public static void test_hibari_basics(UBFClient ubf)
        throws IOException, UBFException
    {
        // setup
        UBFObject res1 = ubf.rpc(
                UBF.tuple( new UBFAtom("delete"), new UBFAtom("tab1"),
                            new UBFBinary("foo"), new UBFList(),
                            new UBFInteger(4000)));
        System.out.println("Res 1:" + res1.toString());</pre></li><li><p>
Add the key <code class="literal">foo</code> to table <code class="literal">tab1</code>.
</p><pre class="screen">        // add - ok
        UBFObject res2 = ubf.rpc(
                UBF.tuple( new UBFAtom("add"), atom_tab1,
                            new UBFBinary("foo"), new UBFBinary("bar"),
                            new UBFInteger(0), new UBFList(),
                            new UBFInteger(4000)));
        System.out.println("Res 2:" + res2.toString());
        if (! res2.equals(atom_ok))
            System.exit(1);</pre></li><li><p>
Add the key <code class="literal">foo</code> to table <code class="literal">tab1</code> again, this time expecting a
failure.
</p><pre class="screen">        // add - ng
        UBFObject res3 = ubf.rpc(
                UBF.tuple( new UBFAtom("add"), atom_tab1,
                            new UBFBinary("foo"), new UBFBinary("bar"),
                            new UBFInteger(0), new UBFList(),
                            new UBFInteger(4000)));
        System.out.println("Res 3:" + res3.toString());
        if (! ((UBFTuple)res3).value[0].equals(atom_key_exists))
            System.exit(1);</pre></li><li><p>
Get the key <code class="literal">foo</code> from table <code class="literal">tab1</code>.
</p><pre class="screen">        // get - ok
        UBFObject res4 = ubf.rpc(
                UBF.tuple( new UBFAtom("get"), atom_tab1,
                            new UBFBinary("foo"), new UBFList(),
                            new UBFInteger(4000)));
        System.out.println("Res 4:" + res4.toString());
        if (! ((UBFTuple)res4).value[0].equals(atom_ok) ||
            ! ((UBFTuple)res4).value[2].equals("bar"))
            System.exit(1);</pre></li><li><p>
Set the key <code class="literal">foo</code> in table <code class="literal">tab1</code> to <code class="literal">bar bar</code>.
</p><pre class="screen">        // set - ok
        UBFObject res5 = ubf.rpc(
                UBF.tuple( new UBFAtom("set"), atom_tab1,
                            new UBFBinary("foo"), new UBFBinary("bar bar"),
                            new UBFInteger(0), new UBFList(),
                            new UBFInteger(4000)));
        System.out.println("Res 5:" + res5.toString());
        if (! res5.equals(atom_ok))
            System.exit(1);</pre></li><li><p>
Get <code class="literal">foo</code> again and verify that the value is <code class="literal">bar bar</code>
</p><pre class="screen">        // get - ok
        UBFObject res6 = ubf.rpc(
                UBF.tuple( new UBFAtom("get"), atom_tab1,
                            new UBFBinary("foo"), new UBFList(),
                            new UBFInteger(4000)));
        System.out.println("Res 6:" + res6.toString());
        if (! ((UBFTuple)res6).value[0].equals(atom_ok) ||
            ! ((UBFTuple)res6).value[2].equals("bar bar"))
            System.exit(1);</pre></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_the_ubf_event_handler_interface"></a>4.6.4. The UBF event handler interface</h4></div></div></div><p>Each <code class="literal">UBFClient</code> instance uses a separate thread to read data from the
server and do any of the following:</p><div class="orderedlist"><ol type="1"><li>
Signal to the other thread that a synchronous RPC response was
received from the server.
</li><li>
Run a callback function when an <code class="literal">event_out</code> asynchronous event is
received from the server.
</li><li>
The socket was closed unexpectedly.
</li></ol></div><p>In cases #2 and #3, a class that implements the <code class="literal">UBFEventHandler</code>
interface is used to define the action to be taken in those cases.</p><p>The <code class="literal">HibariTest.java</code> contains a sample implementation of callback
functions for asynchronous events.  A real application would probably
want to do something much more helpful than this example does.</p><pre class="screen">    public static class FooHandler implements UBFEventHandler {
        public FooHandler() {
        }
        public void handleEvent(UBFClient client, UBFObject event) {
            System.out.println("Hey, got an event: " + event.toString());
        }
        public void connectionClosed(UBFClient client) {
            System.out.println("Hey, connection closed, ignoring it\n");
        }
    }</pre><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>See <a class="xref" href="#the-ubf-hibaritest-main-method" title="Example 7. The ubf.HibariTest.main() method">Example 7, “The ubf.HibariTest.main() method”</a> for an example that
uses this <code class="literal">FooHandler</code> class.</p></td></tr></table></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="using-ubf-python-client"></a>4.7. Using the EBF Client Library for Python</h3></div></div></div><p>The source code for the EBF client library for Python is included in
the UBF source repository at
<a class="ulink" href="http://github.com/norton/ubf" target="_top">http://github.com/norton/ubf</a>, in
the <code class="literal">priv/python</code> subdirectory.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Recall that the EBF protocol is very closely related to UBF.  The
only significant difference is the "layer 5" session protocol layer:
instead of using the UBF(A) protocol, the EBF (Erlang Binary Format)
protocol is used instead.  See
<a class="xref" href="#hibari-server-impl-of-ubf-proto-stack" title="4.1. The Hibari Server’s Implementation of the UBF Protocol Stack">Section 4.1, “The Hibari Server’s Implementation of the UBF Protocol Stack”</a> for more details.</p></td></tr></table></div><p>In addition, you will need the "py_interface" package, developed by
Tomas Abrahamsson and others.  "py-interface" is distributed under the
<a class="ulink" href="http://www.fsf.org/licensing/education/licenses/lgpl.html" target="_top">GNU
Library General Public License</a>.  A git repository is hosted at
repo.or.cz. To clone it and build it, use:</p><pre class="screen">git clone git://repo.or.cz/py_interface.git
cd py_interface
autoconf
./configure
make
pwd</pre><p>Use the output of the last command, <code class="literal">pwd</code>, to remember the full
directory path to the "py-interface" library.  The example below
assumes that path is <code class="literal">/tmp/py-interface</code>.</p><p>The <code class="literal">pyebf.py</code> file contains a small unit test that makes several
calls to the Hibari UBF contract’s <code class="literal">do_req()</code> command.  The results of
(almost) every command are verified using the <code class="literal">assert</code> function.</p><pre class="screen">env PYTHONPATH=/path/to/py_interface python pyebf.py</pre><div class="orderedlist"><ol type="1"><li><p>
Connect to the Hibari server on "localhost" TCP port 7580 and use
the UBF metaprotocol to switch to the <code class="literal">gdss</code> contract.
</p><pre class="screen">    ## login
    ebf.login('gdss', 'gdss_meta_server')</pre></li><li><p>
Delete the key <code class="literal">'foo'</code> from table <code class="literal">tab1</code>.
</p><pre class="screen">    ## setup
    req0 = (Atom('do'), Atom('tab1'), [(Atom('delete'), 'foo', [])], [], 1000)
    res0 = ebf.rpc('gdss', req0)</pre></li><li><p>
Get the key <code class="literal">'foo'</code> from table <code class="literal">tab1</code>.
</p><pre class="screen">    ## get - ng
    req1 = (Atom('do'), Atom('tab1'), [(Atom('get'), 'foo', [])], [], 1000)
    res1 = ebf.rpc('gdss', req1)
    assert res1[0] == 'key_not_exist'</pre></li><li><p>
Add the key <code class="literal">'foo'</code> to table <code class="literal">tab1</code>.  The <code class="literal">do_req()</code> interface
requires managing the timestamp integers explicitly by the client; the
timestamp <code class="literal">1</code> is used here.
</p><pre class="screen">    ## add - ok
    req2 = (Atom('do'), Atom('tab1'), [(Atom('add'), 'foo', 1, 'bar', 0, [])], [
], 1000)
    res2 = ebf.rpc('gdss', req2)
    assert res2[0] == 'ok'</pre></li><li><p>
Add the key <code class="literal">'foo'</code> to table <code class="literal">tab1</code>.
</p><pre class="screen">    ## add - ng
    req3 = (Atom('do'), Atom('tab1'), [(Atom('add'), 'foo', 1, 'bar', 0, [])], [
], 1000)
    res3 = ebf.rpc('gdss', req3)
    assert res3[0][0] == 'key_exists'
    assert res3[0][1] == 1</pre></li><li><p>
Get the key <code class="literal">'foo'</code> from table <code class="literal">tab1</code>, verifying that the timestamp
is still <code class="literal">1</code> and value is still <code class="literal">'bar'</code>.
</p><pre class="screen">    ## get - ok
    req4 = (Atom('do'), Atom('tab1'), [(Atom('get'), 'foo', [])], [], 1000)
    res4 = ebf.rpc('gdss', req4)
    assert res4[0][0] == 'ok'
    assert res4[0][1] == 1
    assert res4[0][2] == 'bar'</pre></li><li><p>
Set the key <code class="literal">'foo'</code> from table <code class="literal">tab1</code>, using a new timestamp <code class="literal">2</code>.
</p><pre class="screen">    ## set - ok
    req5 = (Atom('do'), Atom('tab1'), [(Atom('set'), 'foo', 2, 'baz', 0, [])], [
], 1000)
    res5 = ebf.rpc('gdss', req5)
    assert res5[0] == 'ok'</pre></li><li><p>
Get the key <code class="literal">'foo'</code> from table <code class="literal">tab1</code>, verifying both the new
timestamp and new value.
</p><pre class="screen">    ## get - ok
    req6 = (Atom('do'), Atom('tab1'), [(Atom('get'), 'foo', [])], [], 1000)
    res6 = ebf.rpc('gdss', req6)
    assert res6[0][0] == 'ok'
    assert res6[0][1] == 2
    assert res6[0][2] == 'baz'</pre></li></ol></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="client-api-tbf"></a>5. Client API: Thrift</h2></div></div></div><p>"TBF" is a <a class="ulink" href="https://github.com/apache/thrift" target="_top">Thrift
protocol</a> defined by UBF contract
<a class="xref" href="#the-hibari-ubf-protocol-contract" title="4.4. The Hibari UBF Protocol Contract">Section 4.4, “The Hibari UBF Protocol Contract”</a>.  This section attempts to
describe the Hibari Thrift API which allows users to access Hibari with
Thrift clients in any Thrift supported programming languages, and how
to extend the API for application uses.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_the_hibari_thrift_api"></a>5.1. The Hibari Thrift API</h3></div></div></div><p>The Hibari Thrift API is defined as Hibari Service in
<a class="ulink" href="./misc-codes/hibari.thrift" target="_top">hibari.thrift</a>.  At the time this API
was developed, only Thrift 0.4.0 is available to us.  This version is
our first attempt to adopt Thrift.  Some of the functions and options
are not yet supported.</p><div class="important" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="./images/icons/important.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The Hibari Thrift API only supports Thrift 0.4.0 or above.</p></td></tr></table></div><pre class="screen">service Hibari {

  /**
   * Check connection availability / keepalive
   */
  oneway void keepalive()

  /**
   * Hibari Server Info
   */
  string info()

  /**
   * Hibari Description
   */
  string description()

  /**
   * Hibari Contract
   */
  string contract()

  /**
   * Add
   */
  HibariResponse Add(1: Add request)
      throws (1:HibariException ouch)

  /**
   * Replace
   */
  HibariResponse Replace(1: Replace request)
      throws (1:HibariException ouch)

  /**
   * Set
   */
  HibariResponse Set(1: Set request)
      throws (1:HibariException ouch)

  /**
   * Delete
   */
  HibariResponse Delete(1: Delete request)
      throws (1:HibariException ouch)

  /**
   * Get
   */
  HibariResponse Get(1: Get request)
      throws (1:HibariException ouch)
}</pre><p>For each primitive utility function, it has exactly one input
parameter.  The parameter is an object that has a name matching its
function. The object carries all mandatory and optional parameters to
Hibari. This object could also be used to implement micro-transactions
in the future.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_mapping_ubf_contract_types_to_thrift_types"></a>5.2. Mapping UBF Contract Types to Thrift Types</h3></div></div></div><p>You can find more details of the UBF / Thrift type conversion in
(<a class="ulink" href="https://github.com/norton/ubf-thrift" target="_top">UBF-Thrift</a>).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_mapping_ubf_contract_to_thrift_service"></a>5.3. Mapping UBF Contract to Thrift Service</h3></div></div></div><p>Mapping UBF types to thrift primitives is different from mapping UBF
contracts to service. Thrift mainly uses 2 different types to compose
a request (struct and field).</p><p>If you are using Thrift to generate client code, you probably don’t
need to worry about how the request being constructed. Visit
<a class="ulink" href="http://wiki.apache.org/thrift/ThriftGeneration" target="_top">Thrift Wiki</a> for
the instruction to install Thrift and to generate client code.  You
will also need <a class="ulink" href="./misc-codes/hibari.thrift" target="_top">hibari.thrift</a> to get
started.</p><p>If you are interested in the UBF contract, the Hibari NTBF contract
can be found in the file of <code class="literal">ntbf_gdss_plugin.con</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_examples_of_using_a_thrift_client"></a>5.4. Examples of using a Thrift client</h3></div></div></div><p>Once you get the generated code, connecting to Hibari is easy.  For
example, adding the key <code class="literal">'fookey'</code> to table <code class="literal">tab1</code> with a value of
<code class="literal">'Hello, world!'</code> in the following 3 languages.</p><p>In Erlang:</p><pre class="screen">  -include("hibari_thrift.hrl").

  % init
  {ok, Client} = thrift_client:start_link("127.0.0.1", 7600, hibari_thrift),

  % create the input parameter object
  Request = #add{table=&lt;&lt;"tab1"&gt;&gt;, key=&lt;&lt;"fookey"&gt;&gt;, value=&lt;&lt;"Hello, world!"&gt;},

  % send request
  try
    HibariResponse = thrift_client:call(Client, 'Add', [Request]),
  catch
    HibariException -&gt;
      HibariException
  end,

  ok = thrift_client:close(Client).</pre><p>In Java:</p><pre class="screen">  import com.hibari.rpc.*;

  // init
  TTransport transport = new TSocket("127.0.0.1", 7600);
  TProtocol proto = new TBinaryProtocol(transport);
  Hibari.Client client = new Hibari.Client(proto);
  transport.open();

  // create the input parameter object
  Add request = new Add("tab1", ByteBuffer.wrap("fookey".getBytes()),
    ByteBuffer.wrap("Hello, world!".getBytes())))

  // send request
  try {
    HibariResponse response = client.Add(request);
  } catch (HibariException e) {
    // ...
  }

  transport.close();</pre><p>In python:</p><pre class="screen">  from hibari import Hibari

  # init
  transport = TSocket.TSocket('localhost', 7600)
  transport.setTimeout(None)
  transport = TTransport.TBufferedTransport(transport)
  protocol = TBinaryProtocol.TBinaryProtocol(transport)
  client = Hibari.Client(protocol)
  transport.open()

  # create the input parameter object
  request = Add()
  request.table = "tab1"
  request.key = b"fookey"
  request.value = b"Hello, world!"

  # send request
  response = client.Add(request)

  transport.close()</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_mapping_tbf_contract_responses_from_thrift_client"></a>5.5. Mapping TBF Contract Responses From Thrift Client</h3></div></div></div><p>TBF only responses one of two generic types to all functions in Hibari
Thrift API, HibariResponse or HibariException.  One could expect a
HibariResponse in an any successful cases.  Otherwise a
HibariException should be thrown.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_developer_utilities"></a>6. Developer Utilities</h2></div></div></div><p><span class="emphasis"><em>Under Construction</em></span></p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_basho_bench"></a>6.1. Basho Bench</h3></div></div></div><p><span class="emphasis"><em>to be added</em></span></p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_yahoo_cloud_serving_benchmark"></a>6.2. Yahoo! Cloud Serving Benchmark</h3></div></div></div><p><span class="emphasis"><em>to be added</em></span></p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="HibariBuildingSource"></a>7. Building Hibari from Source</h2></div></div></div><p>This section describes the basic recipes to build the following items:</p><div class="itemizedlist"><ul type="disc"><li>
Hibari Release Package
</li><li>
Hibari Documentation
</li><li>
Erlang/OTP System
</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_required_third_party_software"></a>7.1. Required Third Party Software</h3></div></div></div><p>Before getting started, review this checklist of tools and
software. Please install and set up as needed.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_mandatory_items_required_for_building_hibari"></a>7.1.1. Mandatory Items (Required for Building Hibari)</h4></div></div></div><p>The following software is required in order to download Hibari and
build a release package:</p><div class="itemizedlist"><ul type="disc"><li><p>
Git - <a class="ulink" href="http://git-scm.com/" target="_top">http://git-scm.com/</a>
</p><div class="itemizedlist"><ul type="circle"><li><p>
Must be version 1.5.4 or newer.
</p><div class="itemizedlist"><ul type="square"><li>
1.7.3.4 is the version most recently tested for Hibari.
</li></ul></div></li><li><p>
If you haven’t yet done so, please configure your email address
    and name for Git:
</p><pre class="screen">$ git config --global user.email "you@example.com"
$ git config --global user.name "Your Name"</pre></li><li>
If you haven’t yet done so, you must sign up for a GitHub account
</li></ul></div></li><li><p>
<a class="ulink" href="https://github.com/" target="_top">https://github.com/</a>
</p><div class="itemizedlist"><ul type="circle"><li>
Anonymous read-only access using the GIT protocol is default.
</li><li>
Team members with read-write access: be sure to add your SSH
       public key under your GitHub account.
</li></ul></div></li><li><p>
Python - <a class="ulink" href="http://www.python.org" target="_top">http://www.python.org</a>
</p><div class="itemizedlist"><ul type="circle"><li><p>
Must be version 2.4 or newer
</p><div class="itemizedlist"><ul type="square"><li>
2.7 is the version most recently tested for Hibari.
</li><li>
CAUTION: Python 3.x might be too new.
</li></ul></div></li></ul></div></li><li><p>
Repo - <a class="ulink" href="http://source.android.com/source/git-repo.html" target="_top">http://source.android.com/source/git-repo.html</a>
</p><div class="itemizedlist"><ul type="circle"><li><p>
Install as follows:
</p><pre class="screen">$ mkdir -p ~/bin
$ wget -O - http://android.git.kernel.org/repo &gt; ~/bin/repo
$ chmod a+x ~/bin/repo</pre></li><li>
The downloading and packaging process also uses Rebar
    (<a class="ulink" href="https://github.com/basho/rebar/wiki" target="_top">https://github.com/basho/rebar/wiki</a>) but this tool is included in
    the Hibari Git repositories so you do not need to install it
    separately.
</li></ul></div></li><li><p>
OpenSSL - <a class="ulink" href="http://www.openssl.org/" target="_top">http://www.openssl.org/</a>
</p><div class="itemizedlist"><ul type="circle"><li>
Required for Erlang’s crypto module.
</li></ul></div></li><li><p>
Erlang/OTP - <a class="ulink" href="http://www.erlang.org/" target="_top">http://www.erlang.org/</a>
</p><div class="itemizedlist"><ul type="circle"><li><p>
Must be version R13B04 or newer.
</p><div class="itemizedlist"><ul type="square"><li>
R14B01 is the version most recently tested for Hibari.
</li></ul></div></li><li>
For information on building Erlang/OTP from source, see
    <a class="xref" href="#ErlangOTP" title="7.5. Building and Installing Erlang/OTP">Section 7.5, “Building and Installing Erlang/OTP”</a> in this document.
</li></ul></div></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="_optional_items_required_for_building_hibari_8217_s_documentation"></a>7.1.2. Optional Items (Required for Building Hibari’s Documentation)</h4></div></div></div><p>The following software is required only if you want to build Hibari’s
documentation from source. Note that an online version of the
documentation is available at <a class="ulink" href="http://hibari.github.com/hibari-doc/" target="_top">http://hibari.github.com/hibari-doc/</a>.</p><div class="itemizedlist"><ul type="disc"><li><p>
AsciiDoc - <a class="ulink" href="http://www.methods.co.nz/asciidoc/index.html" target="_top">http://www.methods.co.nz/asciidoc/index.html</a>
</p><div class="itemizedlist"><ul type="circle"><li><p>
Must be version 8.6.1 or newer
</p><div class="itemizedlist"><ul type="square"><li>
9.6.3 is the version most recently tested for Hibari
</li></ul></div></li><li><p>
Plus the following support tools:
</p><div class="itemizedlist"><ul type="square"><li>
ImageMagick - <a class="ulink" href="http://www.imagemagick.org/" target="_top">http://www.imagemagick.org/</a>
</li><li>
Graphviz - <a class="ulink" href="http://www.graphviz.org/" target="_top">http://www.graphviz.org/</a>
</li><li>
Mscgen - <a class="ulink" href="http://www.mcternan.me.uk/mscgen/" target="_top">http://www.mcternan.me.uk/mscgen/</a>
</li></ul></div></li></ul></div></li><li><p>
Docbook - <a class="ulink" href="http://www.docbook.org/" target="_top">http://www.docbook.org/</a>
</p><div class="itemizedlist"><ul type="circle"><li>
Optional for building a PDF version of Hibari’s documentation.
</li></ul></div></li><li><p>
xmlto - <a class="ulink" href="https://fedorahosted.org/xmlto/" target="_top">https://fedorahosted.org/xmlto/</a>
</p><div class="itemizedlist"><ul type="circle"><li>
Optional for building a text version of Hibari’s documentation.
</li></ul></div></li></ul></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_downloading_hibari"></a>7.2. Downloading Hibari</h3></div></div></div><p>Follow these steps to download the Hibari repositories from GitHub.</p><div class="orderedlist"><ol type="1"><li><p>
Create a working directory and retrieve the Hibari manifest files.
</p><pre class="screen">$ mkdir working-directory
$ cd working-directory
$ repo init -u git://github.com/hibari/manifests.git -m hibari-default.xml</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Your "Git" identity is needed during the repo init step.  Please
enter the name and email of your GitHub account if you have one.  Team
members having read-write access should use "repo init -u
<a class="ulink" href="mailto:git@github.com" target="_top">git@github.com</a>:hibari/manifests.git -m hibari-default-rw.xml".</p></td></tr></table></div><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>If you want to checkout the latest development version of Hibari,
please append " -b dev" to the repo init command.</p></td></tr></table></div></li><li><p>
Download Hibari’s Git repositories.
</p><pre class="screen">$ repo sync</pre><p>After the repo sync, your working directory has the following structure:</p></li></ol></div><pre class="screen">&lt;working-directory&gt;
  |- hibari/
    |- .git/
    |- .gitignore
    |- Makefile
    |- dialyze-ignore-warnings.txt
    |- dialyze-nospec-ignore-warnings.txt
    |- lib/                             <a id="CO1-1"></a><img src="./images/icons/callouts/1.png" alt="1" border="0" />
      |- &lt;application_name&gt;/
        |- .git/
        |- .gitignore
        |- ebin/
        |- include/
          |- *.hrl
        |- priv/
        |- rebar.config
        |- src/
          |- &lt;application_name&gt;.app.src
          |- *.erl
        |- test/
          |- eunit/
            |- *.erl
          |- eqc/
            |- *.erl
      :
    |- rebar
    |- rebar.config
    |- rel/                             <a id="CO1-2"></a><img src="./images/icons/callouts/2.png" alt="2" border="0" />
      |- files/
        |- app.config
        |- erl
        |- hibari
        |- hibari-admin
        |- nodetool
        |- nodetool-admin
        |- vm.args
      |- hibari/
        :
        |- releases/
          |- &lt;release_vsn&gt;/
            :
          :
        :
      |- reltool.config
  |- hibari-doc/                        <a id="CO1-3"></a><img src="./images/icons/callouts/3.png" alt="3" border="0" />
    :
  |- manifests/                         <a id="CO1-4"></a><img src="./images/icons/callouts/4.png" alt="4" border="0" />
    :
  |- patches/                           <a id="CO1-5"></a><img src="./images/icons/callouts/5.png" alt="5" border="0" />
    :
  |- rebar/                             <a id="CO1-6"></a><img src="./images/icons/callouts/6.png" alt="6" border="0" />
    :
  |- .repo/
    :</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO1-1"><img src="./images/icons/callouts/1.png" alt="1" border="0" /></a> </p></td><td valign="top" align="left">
Applications
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO1-2"><img src="./images/icons/callouts/2.png" alt="2" border="0" /></a> </p></td><td valign="top" align="left">
Releases
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO1-3"><img src="./images/icons/callouts/3.png" alt="3" border="0" /></a> </p></td><td valign="top" align="left">
Documentation
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO1-4"><img src="./images/icons/callouts/4.png" alt="4" border="0" /></a> </p></td><td valign="top" align="left">
Manifests
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO1-5"><img src="./images/icons/callouts/5.png" alt="5" border="0" /></a> </p></td><td valign="top" align="left">
Patches
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO1-6"><img src="./images/icons/callouts/6.png" alt="6" border="0" /></a> </p></td><td valign="top" align="left">
Rebar
</td></tr></table></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_building_the_hibari_release_package"></a>7.3. Building the Hibari Release Package</h3></div></div></div><p>Follow these steps to build a Hibari release package.</p><div class="orderedlist"><ol type="1"><li><p>
Building <span class="emphasis"><em>basic recipe</em></span>:
</p><pre class="screen">$ cd working-directory/hibari
$ make</pre><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>If the response is "make: erl: Command not found", please make
sure Erlang/OTP is installed and "otp-installing-directory-name/bin"
is added to your $PATH environment.</p></td></tr></table></div></li><li><p>
Release packaging <span class="emphasis"><em>basic recipe</em></span>:
</p><pre class="screen">$ cd working-directory/hibari
$ make package</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>A release package tarball "hibari-X.Y.Z-dev-ARCH-WORDSIZE.tgz"
and md5sum file "hibari-X.Y.Z-dev-ARCH-WORDSIZE-md5sum.txt" is written
into your working-directory. You can then use these files to perform a
single-node or multi-node Hibari installation as described in
<a class="xref" href="#getting-started" title="2. Getting Started">Section 2, “Getting Started”</a>.</p></td></tr></table></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="HibariAsciiDoc"></a>7.4. Building Hibari’s Documentation</h3></div></div></div><p>Follow these steps to build Hibari’s documentation.</p><div class="orderedlist"><ol type="1"><li><p>
Building Hibari’s "Guides" <span class="emphasis"><em>basic recipe</em></span>:
</p><pre class="screen">$ cd working-directory/hibari-doc/src/hibari
$ make clean -OR- make realclean
$ make</pre></li><li><p>
Building Hibari’s "Website" <span class="emphasis"><em>basic recipe</em></span>:
</p><pre class="screen">$ cd working-directory/hibari-doc/src/hibari/website
$ make clean -OR- make realclean
$ make</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>HTML documentation is written in the "./public_html" directory.</p></td></tr></table></div></li></ol></div><p>Hibari’s documentation is authored using AsciiDoc and a few auxillary
tools:</p><div class="itemizedlist"><ul type="disc"><li>
ImageMagick
</li><li>
Docbook
</li><li>
Graphviz
</li><li>
Mscgen
</li><li>
xmlto
</li></ul></div><p>Hibari’s documentation is generated with AsciiDoc and a manually
modified version of the a2x tool.</p><pre class="screen">$ diff -u /usr/local/Cellar/asciidoc/8.6.3/bin/a2x{.orig,}
--- /usr/local/Cellar/asciidoc/8.6.3/bin/a2x.orig       2011-01-02 18:09:35.000000000 +0900
+++ /usr/local/Cellar/asciidoc/8.6.3/bin/a2x    2011-01-02 18:11:19.000000000 +0900
@@ -156,7 +156,10 @@
 def shell_copy(src, dst):
     verbose('copying "%s" to "%s"' % (src,dst))
     if not OPTIONS.dry_run:
-        shutil.copy(src, dst)
+        try:
+            shutil.copy(src, dst)
+        except shutil.Error:
+            return

 def shell_rm(path):
     if not os.path.exists(path):</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ErlangOTP"></a>7.5. Building and Installing Erlang/OTP</h3></div></div></div><p>Follow these steps to download and build Erlang/OTP from source, and
to install the system. These steps provide a basic recipe; not all
options are addressed.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Please make sure to have the <span class="emphasis"><em>openssl-devel</em></span> package installed
on your system before configuring and building Erlang/OTP.</p></td></tr></table></div><div class="orderedlist"><ol type="1"><li><p>
Download the source code for your Erlang/OTP system:
</p><pre class="screen">$ cd working-directory
$ wget http://www.erlang.org/download/otp_src_R14B01.tar.gz</pre></li><li><p>
Untar the source code for your Erlang/OTP system:
</p><pre class="screen">$ tar -xzf otp_src_R14B01.tar.gz</pre></li><li><p>
Configure Erlang/OTP:
</p><pre class="screen">$ cd working-directory/otp_src_R14B01
$ ./configure --prefix=otp-installing-directory-name</pre></li><li><p>
Build Erlang/OTP:
</p><pre class="screen">$ make</pre></li><li><p>
Install Erlang/OTP:
</p><pre class="screen">$ sudo make install</pre></li></ol></div><div class="caution" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="./images/icons/caution.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Please make sure "otp-installing-directory-name/bin" is added
to your $PATH environment.</p></td></tr></table></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_sample_application"></a>8. Sample Application</h2></div></div></div><p><span class="emphasis"><em>Under Construction</em></span></p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_contributing_to_hibari"></a>9. Contributing to Hibari</h2></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_github_git_and_repo"></a>9.1. GitHub, Git, and Repo</h3></div></div></div><p><span class="emphasis"><em>to be added</em></span></p><p>List the working directories for all of Hibari’s "projects":</p><pre class="screen">$ repo forall -c "pwd"</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Each project has a corresponding Git repository and (default)
revision.  Check the "manifests/hibari-default.xml" file for details.</p></td></tr></table></div><p>Start a new topic (e.g. new-topic-name) branch:</p><pre class="screen">$ repo start new-topic-name `repo forall -c "pwd" | xargs echo`</pre><p>Abandon an existing topic (e.g. topic-name) branch:</p><pre class="screen">$ repo abandon topic-name `repo forall -c "pwd" | xargs echo`</pre><p>Track and checkout the master branch:</p><pre class="screen">$ repo forall -c "git branch --track master github/master"
$ repo forall -c "git checkout master"</pre><p>Track and checkout the dev (i.e. Development) branch:</p><pre class="screen">$ repo forall -c "git branch --track dev github/dev"
$ repo forall -c "git checkout dev"</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_code_branch_and_version_management"></a>9.2. Code, Branch, and Version Management</h3></div></div></div><p><span class="emphasis"><em>to be added</em></span></p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_documentation"></a>9.3. Documentation</h3></div></div></div><p><span class="emphasis"><em>to be added</em></span></p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="_submitting_patches"></a>9.4. Submitting Patches</h3></div></div></div><p><span class="emphasis"><em>to be added</em></span></p></div></div></div></body></html>
