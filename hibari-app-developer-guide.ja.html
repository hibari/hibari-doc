<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Hibari ® アプリケーション開発者ガイド</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /></head><body><div xml:lang="ja" class="article" title="Hibari &#xAE; &#x30A2;&#x30D7;&#x30EA;&#x30B1;&#x30FC;&#x30B7;&#x30E7;&#x30F3;&#x958B;&#x767A;&#x8005;&#x30AC;&#x30A4;&#x30C9;" lang="ja"><div class="titlepage"><div><div><h2 class="title"><a id="id36108574"></a>Hibari ® アプリケーション開発者ガイド</h2></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="2"><strong>改訂履歴</strong></th></tr><tr><td align="left">改訂 0.2.2(ja)</td><td align="left">2011/04/26</td></tr></table></div></div></div><hr /></div><div class="toc"><p><strong>目次</strong></p><dl><dt><span class="section"><a href="#_hibari&#x3068;&#x306F;">1. Hibariとは</a></span></dt><dd><dl><dt><span class="section"><a href="#_&#x306A;&#x305C;nosql&#x304B;">1.1. なぜNOSQLか？</a></span></dt><dt><span class="section"><a href="#_&#x306A;&#x305C;hibari&#x304B;">1.2. なぜHibariか？</a></span></dt></dl></dd><dt><span class="section"><a href="#getting-started">2. はじめに</a></span></dt><dd><dl><dt><span class="section"><a href="#system-requirements">2.1. システム要件</a></span></dt><dt><span class="section"><a href="#required-software">2.2. 必要なサードパーティのソフトウェア</a></span></dt><dt><span class="section"><a href="#download-hibari">2.3. Hibariをダウンロードする</a></span></dt><dt><span class="section"><a href="#installing-single-node">2.4. シングルノードにHibariをインストールする</a></span></dt><dt><span class="section"><a href="#starting-single-node">2.5. シングルノードのHibariを起動する／停止する</a></span></dt><dt><span class="section"><a href="#installing-multi-node">2.6. マルチノードのクラスターにHibariをインストールする</a></span></dt><dt><span class="section"><a href="#starting-multi-node">2.7. マルチノードのHibariクラスターを起動する／停止する</a></span></dt><dt><span class="section"><a href="#creating-tables">2.8. 新しいテーブルを作成する</a></span></dt></dl></dd><dt><span class="section"><a href="#client-api-erlang">3. クライアントAPI ： ネイティブErlang</a></span></dt><dd><dl><dt><span class="section"><a href="#_hibari&#x306E;&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;api&#x306E;&#x6982;&#x8981;">3.1. HibariのクライアントAPIの概要</a></span></dt><dt><span class="section"><a href="#brick-simple-add">3.2. brick_simple:add/6</a></span></dt><dt><span class="section"><a href="#brick-simple-replace">3.3. brick_simple:replace/6</a></span></dt><dt><span class="section"><a href="#brick-simple-set">3.4. brick_simple:set/6</a></span></dt><dt><span class="section"><a href="#brick-simple-get">3.5. brick_simple:get/4</a></span></dt><dt><span class="section"><a href="#brick-simple-get-many">3.6. brick_simple:get_many/5</a></span></dt><dt><span class="section"><a href="#brick-simple-delete">3.7. brick_simple:delete/4</a></span></dt><dt><span class="section"><a href="#brick-simple-do">3.8. brick_simple:do/4</a></span></dt><dt><span class="section"><a href="#brick-simple-fold-table">3.9. brick_simple:fold_table/7</a></span></dt><dt><span class="section"><a href="#brick-simple-fold-key">3.10. brick_simple:fold_key_prefix/9</a></span></dt></dl></dd><dt><span class="section"><a href="#client-api-ubf">4. クライアントAPI：UBF</a></span></dt><dd><dl><dt><span class="section"><a href="#hibari-server-impl-of-ubf-proto-stack">4.1. HibariサーバーにおけるUBFプロトコル層の実装</a></span></dt><dt><span class="section"><a href="#ubf-representation-of-strings">4.2. UBFにおけるストリングとバイナリの表現</a></span></dt><dt><span class="section"><a href="#using-ubf-in-any-language">4.3. すべての言語におけるUBFベースのプロトコルの使用手順</a></span></dt><dt><span class="section"><a href="#the-hibari-ubf-protocol-contract">4.4. HibariのUBFプロトコル・コントラクト</a></span></dt><dt><span class="section"><a href="#using-ubf-erlang-client">4.5. Erlang用のUBFクライアント・ライブラリの使用法</a></span></dt><dt><span class="section"><a href="#using-ubf-java-client">4.6. Java用のUBFクライアント・ライブラリの使用法</a></span></dt><dt><span class="section"><a href="#using-ubf-python-client">4.7. Python用のEBFクライアント・ライブラリの使用法</a></span></dt></dl></dd><dt><span class="section"><a href="#client-api-tbf">5. クライアントAPI： Thrift</a></span></dt><dd><dl><dt><span class="section"><a href="#_hibari&#x306E;thrift_api">5.1. HibariのThrift API</a></span></dt><dt><span class="section"><a href="#_ubf&#x30B3;&#x30F3;&#x30C8;&#x30E9;&#x30AF;&#x30C8;&#x578B;&#x3068;thrift&#x578B;&#x3068;&#x306E;&#x30DE;&#x30C3;&#x30D4;&#x30F3;&#x30B0;">5.2. UBFコントラクト型とThrift型とのマッピング</a></span></dt><dt><span class="section"><a href="#_ubf&#x30B3;&#x30F3;&#x30C8;&#x30E9;&#x30AF;&#x30C8;&#x3068;thrift&#x30B5;&#x30FC;&#x30D3;&#x30B9;&#x3068;&#x306E;&#x30DE;&#x30C3;&#x30D4;&#x30F3;&#x30B0;">5.3. UBFコントラクトとThriftサービスとのマッピング</a></span></dt><dt><span class="section"><a href="#_thrift&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;&#x306E;&#x4F7F;&#x7528;&#x4F8B;">5.4. Thriftクライアントの使用例</a></span></dt><dt><span class="section"><a href="#_thrift_&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;&#x304B;&#x3089;&#x306E;tbf&#x30B3;&#x30F3;&#x30C8;&#x30E9;&#x30AF;&#x30C8;&#x5FDC;&#x7B54;&#x306E;&#x30DE;&#x30C3;&#x30D4;&#x30F3;&#x30B0;">5.5. Thrift クライアントからのTBFコントラクト応答のマッピング</a></span></dt></dl></dd><dt><span class="section"><a href="#_&#x958B;&#x767A;&#x8005;&#x5411;&#x3051;&#x30E6;&#x30FC;&#x30C6;&#x30A3;&#x30EA;&#x30C6;&#x30A3;">6. 開発者向けユーティリティ</a></span></dt><dd><dl><dt><span class="section"><a href="#_basho_bench">6.1. Basho Bench</a></span></dt><dt><span class="section"><a href="#_yahoo_&#x30AF;&#x30E9;&#x30A6;&#x30C9;_&#x30B5;&#x30FC;&#x30D3;&#x30B9;_&#x30D9;&#x30F3;&#x30C1;&#x30DE;&#x30FC;&#x30AF;">6.2. Yahoo! クラウド・サービス・ベンチマーク</a></span></dt></dl></dd><dt><span class="section"><a href="#HibariBuildingSource">7. ソースコードからHibariをビルドする</a></span></dt><dd><dl><dt><span class="section"><a href="#_&#x5FC5;&#x8981;&#x306A;&#x30B5;&#x30FC;&#x30C9;&#x30D1;&#x30FC;&#x30C6;&#x30A3;&#x306E;&#x30BD;&#x30D5;&#x30C8;&#x30A6;&#x30A7;&#x30A2;">7.1. 必要なサードパーティのソフトウェア</a></span></dt><dt><span class="section"><a href="#_hibari&#x3092;&#x30C0;&#x30A6;&#x30F3;&#x30ED;&#x30FC;&#x30C9;&#x3059;&#x308B;">7.2. Hibariをダウンロードする</a></span></dt><dt><span class="section"><a href="#_hibari&#x306E;&#x30EA;&#x30EA;&#x30FC;&#x30B9;&#x30D1;&#x30C3;&#x30B1;&#x30FC;&#x30B8;&#x3092;&#x30D3;&#x30EB;&#x30C9;&#x3059;&#x308B;">7.3. Hibariのリリースパッケージをビルドする</a></span></dt><dt><span class="section"><a href="#HibariAsciiDoc">7.4. Hibariのドキュメントをビルドする</a></span></dt><dt><span class="section"><a href="#ErlangOTP">7.5. Erlang/OTPをビルドしてインストールする</a></span></dt></dl></dd><dt><span class="section"><a href="#_hibari&#x3092;&#x3088;&#x308A;&#x4F7F;&#x3044;&#x3053;&#x306A;&#x3059;&#x305F;&#x3081;&#x306B;">8. Hibariをより使いこなすために</a></span></dt><dd><dl><dt><span class="section"><a href="#_github&#x3068;git&#x3068;repo">8.1. GitHubとGitとRepo</a></span></dt><dt><span class="section"><a href="#_&#x30B3;&#x30FC;&#x30C9;&#x3068;&#x30D6;&#x30E9;&#x30F3;&#x30C1;&#x3068;&#x30D0;&#x30FC;&#x30B8;&#x30E7;&#x30F3;&#x306E;&#x7BA1;&#x7406;">8.2. コードとブランチとバージョンの管理</a></span></dt><dt><span class="section"><a href="#_&#x6587;&#x66F8;&#x5316;">8.3. 文書化</a></span></dt><dt><span class="section"><a href="#_&#x30D1;&#x30C3;&#x30C1;&#x306E;&#x63D0;&#x4F9B;">8.4. パッチの提供</a></span></dt></dl></dd></dl></div><p></p><div class="section" title="1. Hibari&#x3068;&#x306F;"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_hibari&#x3068;&#x306F;"></a>1. Hibariとは</h2></div></div></div><p>　Hibari®は、キー・バリュー・ストア（KVS）方式を用いた分散型データベースです。大規模化し続けるデータ、いわゆる“Big Data”に対応し、商用にすぐに活用できます。大量のデータをどのように保管するかが大きな問題となる現在、それに対処する「NOSQL」というソリューションが出てきました。Hibariはこの分野で、次のような多くの理由から注目を集めています。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Hibariは、<span class="strong"><strong>プログラミング言語Erlangと革新的なチェイン・レプリケーション技術を使った唯一のオープンソースのキー・バリュー型データベース（KVDB）</strong></span> です。Erlangは、堅牢で高性能な分散型ストレージ・ソリューションの構築には理想的なプログラミング基盤を提供します。一方、チェイン・レプリケーションは、データの一貫性を犠牲にすることなく、高いスループットと高可用性を提供します。
</li><li class="listitem">
Hibariは、<span class="strong"><strong>キャリアクラスの通信事業分野で要求される厳格な基準を満たすように作られた唯一のオープンソースのキー・バリュー型データベース</strong></span> です。通信事業分野の製品では、数百万ユーザーの利用実績を持ちます。
</li><li class="listitem"><p class="simpara">
Hibariは、次のような優れた特長を備えています。
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
ストレージ・オプションとして、RAM+ディスクベース、あるいは、ディスクのみの使用を、テーブル単位で選択できます。
</li><li class="listitem">
キー単位で有効期限およびカスタムのメタデータをサポートします。
</li><li class="listitem">
制限範囲内で複数キーのアトミック・トランザクションをサポートします。
</li><li class="listitem">
キーのタイムスタンプ機能によって「テスト・アンド・セット」型の操作が可能です。
</li><li class="listitem">
システムの規模に応じたデータ配置の自動バランシング機能を持ちます。
</li><li class="listitem">
コードのライブ・アップグレードをサポートします。
</li><li class="listitem">
複数のクライアントAPIを実装しています。
</li></ul></div></li></ul></div><p>　この最初の章では、「Big Data」の時代が投げかける問題に対処するために近年出現した「NOSQL」ソリューションについて簡単に説明します。その後、大規模データを扱うアプリケーションの開発者や管理者、あるいはユーザーにHibariが提供する大きな利点について、さらに詳しく紹介します。</p><div class="section" title="1.1. &#x306A;&#x305C;NOSQL&#x304B;&#xFF1F;"><div class="titlepage"><div><div><h3 class="title"><a id="_&#x306A;&#x305C;nosql&#x304B;"></a>1.1. なぜNOSQLか？</h3></div></div></div><p>　まず、NOSQLという新しい動向は、伝統的なRDBMS（リレーショナル・データベース管理システム）を無条件に否定するものではありません。この動向は、今日のデータ環境がSQLだけに留まらず（Not Only SQL：NOSQL）、ストレージに多様なツールが必要であるという認識が急速に広がっていることの表われです。リレーショナル型のデータ・ストレージとNOSQL型のデータ・ストレージは、それぞれ異なるアプローチを持ち、異なる種類のアプリケーションやサービスに適しています。これらは互いに補完するものであると理解してください。
　NOSQLが注目されるようになった背景には、TB（テラバイト）あるいはPB（ぺタバイト）級のデータを保管して使うアプリケーションやサービスの急増という現状があります。その分野では頻繁に「常時使用可能」な可用性を保証し、エンドユーザーの待ち時間を減らす努力が払われてきました。たとえば次のような多くの市場分野で、さまざまな組織がBig Data時代の到来に備えて取り組んでいます。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Webサービス：検索、eコマース、ソーシャルメディア、ユーザー作成コンテンツ等による大量データの要求への対応
</li><li class="listitem">
通信事業：何百万件もの加入者のネットワークログや通話データ記録の管理と分析
</li><li class="listitem">
公益事業：次世代送電網の巨大データ容量の管理と分析
</li><li class="listitem">
金融サービス：リスク分析とモデル化を目的とした顧客履歴データの保管およびマイニング
</li><li class="listitem">
小売分析：クリック・ストリーム分析とマイクロターゲティング
</li><li class="listitem">
バイオテクノロジー：ゲノム解析
</li></ul></div><p>　これらの分野に限らず、大量データを扱う環境にあるあらゆる組織が、いまや未曽有の大規模データを保管するシステムを構築する問題に直面しています。RDBMSとハイエンドの専用ハードウェアを軸とする伝統的なデータ保管アプローチではこうしたニーズに応えられないと、多くの組織は既に気づいています。特に問題になるのは、次の点です。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
単独のRDBMSインスタンスの「スケールアップ」は、どんなにハイエンドのシステムを用いても、また、どんなに多額の費用をかけても、必要な規模を到底達成できません。
</li><li class="listitem">
複数のRDBMSインスタンスに分割する「スケールアウト」は、巨額の費用を伴ううえに、運用が大幅に複雑になり、リレーショナル・モデルの利点を大きく損ないます。
</li></ul></div><p>　先進的な組織では、コストや複雑性にしわ寄せせずにBig Dataに適した容量を実現させようと、より良いスケーリングの方法を追求してきました。また、増加の一途をたどる使用シナリオのすべてが、RDBMSの複雑なクエリー機能や管理機能を必要とするわけではないことも、同時に明らかになってきました。アプリケーションやサービスによっては、SQL構造や厳密なACIDが必要ないものもあります。さらに環境によっては、これらの過剰機能が高価につき、柔軟性と即応性が要求される非常に厳しい市場競争の中で、サービス提供が妨げられる可能性すらあります。</p><p>　つまり、近年急増しているサービスで必要とするデータは、より大規模になる一方で、構造化の必要性はより少ないのです。</p><p>　そう考えると、業界を牽引するWeb企業がNOSQLの動きの最前線にいるのは不思議なことではありません。特に、Google社の
<a class="ulink" href="http://labs.google.com/papers/bigtable.html" target="_top">BigTable論文</a>（2006年）
と、Amazon社の
<a class="ulink" href="http://s3.amazonaws.com/AllThingsDistributed/sosp/amazon-dynamo-sosp2007.pdf" target="_top">Dynamo論文</a>（2007年）は、NOSQL市場に大きな影響を及ぼしました。BigTable やDynamo、あるいはその両方から構想を得たNOSQLソリューションが多数存在しており、ここ2年でいくつかのソリューションがオープンソースのコミュニティで発表されています。</p><p>　NOSQLを使ったデータ・ストレージソリューションは、それぞれ細かい点では異なりますが、基本的に次のような共通点があります。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
データモデルがシンプルである。データモデルはソリューションごとに異なり、それによってNOSQLシステムは次の3種類に分類できます。
　1) キー・バリュー型データストア（例：Dynamo、Hibari）
　2) 列指向型データストア（例：BigTable）
　3) ドキュメント指向型データストア（例：CouchDB）
  これらはすべて異なるものですが、伝統的なRDBMSと比較すると、データモデルがよりシンプルで高い柔軟性を持ちます。このシンプル指向は、クライアントAPIにも引き継がれています。
</li><li class="listitem">
汎用型のPCを基盤とした複数ノードに分散できます。何十、何百、何千とある汎用型のPCにスケールアウトすることにより、Big Dataの容量を低廉なコストで実現できます。受信した要求の並列処理と連動するデータ分割スキームにより、必要な高性能を得られます。
</li><li class="listitem">
データ・オブジェクトを複数ノードでレプリケーション（複製）することにより、コンポーネントの障害発生時にも高可用性を確保できます。
</li></ul></div><p>　NOSQLストレージ・ソリューションの歴史や長所、あるいは設計の問題等についてさらに詳しく知りたい場合は、Webで検索してください。</p></div><div class="section" title="1.2. &#x306A;&#x305C;Hibari&#x304B;&#xFF1F;"><div class="titlepage"><div><div><h3 class="title"><a id="_&#x306A;&#x305C;hibari&#x304B;"></a>1.2. なぜHibariか？</h3></div></div></div><p>　Hibariは、Gemini Mobile Technologies社が社内で開発したものです。Gemini Mobile Technologies社は、アジア、ヨーロッパ、アメリカで、Tier 1モバイル・オペレータ向けの大規模メッセージングおよびトランザクション・システム開発分野の先頭に立つ企業です。Gemini社が必要とするデータストアは、Tier 1通信事業分野向け製品の導入環境に必須の堅牢さに加えて、効率的で高速かつ柔軟性を備え、拡張可能なものです。ところが、当時利用できる選択肢の中には満足できるものはありませんでした。そこで2005年に、Gemini社はのちに「Hibari」となるシステムの開発に着手しました。Hibariという名称は、日本語でヒバリ（雲雀）、漢字では「クラウド（雲）の鳥」を意味します。その後、システムが成熟して製品化できるようになったのを機に、2010年7月、Gemini社はApache 2.0ライセンスの下でHibariをオープンソースのコミュニティにリリースしました。Hibariが成長を続けて完成度を高める場として最も適しているのはオープンソースのコミュニティであると、Gemini社は考えています。</p><p>　ここからは、Hibariの特長について説明します。これらの特長によって、Hibariは現代のBig Dataストレージ・システムを求めるビジネスおよび開発者にとって魅力的な選択肢となっています。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<a class="ulink" href="#engineered-erlang" target="_top">Erlangによる開発</a>
</li><li class="listitem">
<a class="ulink" href="#chain-replication" target="_top">チェイン・レプリケーションによる高い可用性と強い一貫性</a>
</li><li class="listitem">
<a class="ulink" href="#scalability" target="_top">簡単でコストが低廉な拡張性</a>
</li><li class="listitem">
<a class="ulink" href="#high-performance" target="_top">高性能、特に読み出しと大きいサイズのバリューの処理における高性能</a>
</li><li class="listitem">
<a class="ulink" href="#simple-powerful-api" target="_top">シンプルながら強力なクライアントAPI</a>
</li><li class="listitem">
<a class="ulink" href="#production-prove" target="_top">稼働実績</a>
</li><li class="listitem">
<a class="ulink" href="#hibari-benefits-by-user" target="_top">開発者、システム管理者、そしてビジネスに対するHibariの利点</a>
</li></ul></div><div class="section" title="Erlang&#x306B;&#x3088;&#x308B;&#x958B;&#x767A;"><div class="titlepage"><div><div><h4 class="title"><a id="engineered-erlang"></a>Erlangによる開発</h4></div></div></div><p>　Erlangは、高信頼性で高性能な分散型システムを構築するように設計された汎用プログラミング言語および実行環境です。Erlangは、まず1980年代に先進的通信事業のネットワーク・システム構築用にEricsson社によって開発され、その後1998年に、Erlang/OTP (Open Telecom Platform)としてオープンソース化されました。HibariはすべてErlangで記述されています。</p><p>　Erlangは次のような幅広い長所を持ち、分散型でキー・バリュー方式のストレージ・ソリューションにとって理想的な基盤を提供します。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<span class="strong"><strong>並列</strong></span>.Erlangのプロセスは、メッセージパッシングによる通信を行い、メモリを共有しないため、非常に軽く実行できます。スケジューリング、メモリ管理、その他並列処理に関するサービスを管理するのはErlang のVMであり、ホストのオペレーティング・システムに並列処理の要求を送ることはありません。
</li><li class="listitem">
<span class="strong"><strong>分散</strong></span>.Erlangは、分散環境に特化して設計されています。メッセージパッシングはTCP経由で透過的に行われるため、Erlangのプロセス同士が通信する際は、同一ノードでも違うノードでもまったく同じ方法です。シンプルかつ効率的な設計により、高性能の分散型ストレージ・システムに求められる高度な並列性と拡張性を達成しています。この優れた並列性と分散処理により、Erlangは複数ホスト上で連携しながら稼働する点を除いては、オペレーティング・システムに似た初めての
<a class="ulink" href="http://www.oreillygmt.eu/open-sourcefree-software/erlang-the-ceos-view/" target="_top">“アプリケーション・システム”</a>と言われています。
</li><li class="listitem">
<span class="strong"><strong>堅牢性</strong></span>.Erlangのプロセスは、互いに完全に独立しており、データを共有しません。各プロセスが個別に動作するため、プロセスが互いを監視してプロセス障害を検知した場合は、すぐに対応できます。これは、リモート・ノードにおいても可能です。
</li><li class="listitem">
<span class="strong"><strong>移植性</strong></span>.Erlangの VMは、Linux上だけでなく、UNIX、Windows、Macintosh、VxWorks上でもすべて同じものが稼働します。Erlangの分散プロセスは、異なるホスト・オペレーティング・システムが混在する環境でも、シームレスに相互の通信ができます。システム管理者は環境の変化に対応してホストをうまく組み合わせる必要があることを考えると、オペレーティング・システムを問わないこの移植性は、ストレージ・システムの弾力性の向上に大きく寄与します。
</li><li class="listitem">
<span class="strong"><strong>ホット・コードアップグレード</strong></span>.HibariのようなErlang ベースのアプリケーションは、ホット・コードアップグレードをサポートしています。そのため、システムを終了せずにアップグレードを適用できます。切り替え中は旧コードと新コードが同時に稼働します。これは、エンドユーザーに「常時使用可能」な可用性を提供する必要がある環境にとって重要な利点です。
</li></ul></div><p>　他にも、インクリメンタルなガベージ・コレクションやシングル・アサインメント変数、強固な例外処理機能などにより、Erlangは信頼性の高い分散型アプリケーションに最適なものとなっています。</p></div><div class="section" title="&#x30C1;&#x30A7;&#x30A4;&#x30F3;&#x30FB;&#x30EC;&#x30D7;&#x30EA;&#x30B1;&#x30FC;&#x30B7;&#x30E7;&#x30F3;&#x306B;&#x3088;&#x308B;&#x9AD8;&#x53EF;&#x7528;&#x6027;&#x3068;&#x5F37;&#x3044;&#x4E00;&#x8CAB;&#x6027;"><div class="titlepage"><div><div><h4 class="title"><a id="chain-replication"></a>チェイン・レプリケーションによる高可用性と強い一貫性</h4></div></div></div><p>　分散型でキー・バリュー・ストア方式を用いたHibariは、チェイン・レプリケーション方式を実装しています。チェイン・レプリケーションとは、データの一貫性を犠牲にせず、冗長性を確保して高可用性を得るために、
<a class="ulink" href="http://www.usenix.org/event/osdi04/tech/full_papers/renesse/renesse.pdf" target="_top">van Renesse and Schneider</a>が最初に提案したものです。Hibariのストレージ・クラスターにおけるチェイン・レプリケーションの動作を簡単に説明すると、次のようになります。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
コンシステント・ハッシュにより、キー・スペースを複数のストレージの「チェイン」に分割します。
</li><li class="listitem">
各チェインは、複数の論理ストレージである「ブリック」から構成されます。ブリックごとにそれぞれErlangのVMインスタンスが稼働します。
</li><li class="listitem">
各チェイン内では、複数のブリックがそれぞれ相異なる役割を果たします。クライアントからキーとバリューのペアに対する書き込み要求が送信されると、まず「ヘッド」ブリックに書き込まれ、続いてそれが1個以上の下流の「ミドル」ブリックに自動的にレプリケーションされて、最終的に「テイル」ブリックまでレプリケーションされます。このテイル・ブリックが、クライアントの書き込み要求に対する応答を返します。一方、読み出し要求はテイル・ブリックに送信され、テイル・ブリックがクライアントに応答を返します。
</li></ul></div><p><span class="inlinemediaobject"><img src="images/chain_replication.png" alt="images/chain_replication.png" /></span></p><p>　多くの分散ストレージ・システムでは、レプリケーションしたデータ間に弱い一貫性、または結果整合性しか保証できないことが多く、しかも一貫性が損なわれた場合の管理をクライアント・アプリケーション（とクライアント・アプリケーションの開発者）に押し付けることがよくあります。それに対して、Hibariはチェイン・レプリケーションを実装しているため、強い一貫性を保証します。データの書き込みは、チェインをたどってテイル・ブリックまでレプリケーションされた時点で初めて完了したと見なされ、その後でクライアントに応答を返します。また、読み出し要求を処理するのはテイル・ブリックだけです。したがって、Hibariのクライアントにオブジェクトの書き込み応答が返された後は、そのオブジェクトを他のクライアントから見ると、必ず最新の状態であることが保証されます。この強い一貫性は、“結果整合性”ではエンドユーザーが期待するサービス・レベルを満たせない環境、あるいは、システム設計者が、データの不整合を管理するために必要なロジックをクライアント・アプリケーションの中にばらまきたくないと望む環境では、貴重なものです。</p><p>　チェインの「長さ」は、必要とするレプリケーションの程度と冗長性のレベルによって変更できます。たとえばチェインの長さを4とすると、ヘッド・ブリック1個に、ミドル・ブリック2個、テイル・ブリック1個となります。また3ブリック・チェインとすると、ヘッド・ブリック1個、ミドル・ブリック1個、テイル・ブリック1個です。長さ2のチェイン（ヘッド・ブリックとテイル・ブリックが1個でミドル・ブリックなし）で稼働させることも、あるいは長さ1にすることもできます（1個のブリックがヘッドの役割とテイルの役割の両方を果たします）。</p><p>　どんな長さのチェインでも稼働させることができます。また、システムがチェイン内の障害を検知した場合は、その後のメンバー・ブリックの役割を調整することもできます。これによってHibariは強い一貫性とともに、高可用性を提供できるのです。たとえば3ブリック・チェインのヘッド・ブリックに障害が発生すると、自動的にミドル・ブリックがヘッド・ブリックの役割を引き継ぐため、チェインは正常に機能し続けます。</p><p><span class="inlinemediaobject"><img src="images/automatic_failover.png" alt="images/automatic_failover.png" /></span>
　
　さらに、新しいヘッド・ブリックに障害が発生した場合でも、残る1個のブリックがヘッドの役割とテイルの役割の両方を果たし、あたかも単独ブリック「チェイン」のように機能して、すべての書き込みおよび読み出し要求を処理します。</p><p>　複数の論理ブリックを単一の物理ノードで稼働させることもできますが、高可用性を得るためには、特定のチェインのメンバー・ブリックを別々のマシン上に配置することが望ましいのは当然です。もし各マシン上で複数のブリックを稼働させたいと望み、なおかつ各チェインの高可用性を保証したいなら、チェインをマシン間で「ストライプ」構造に配置する選択肢も魅力的です。</p><p><span class="inlinemediaobject"><img src="images/load_balanced_chains.png" alt="images/load_balanced_chains.png" /></span>　
　
　書き込み要求を受けるヘッド・ブリックと、書き込み要求に応答して読み出し要求を処理するテイル・ブリックには、ミドル・ブリックより多くの負荷がかかることに注意してください。上図に示すように、異なる役割のブリックを均等に割り振ることも、マシン間の負荷分散の一助となります。</p><p>　物理ノードに障害が発生した場合は、影響を受ける各チェイン内のブリックが自動的に役割を変更して、各チェインはクライアントに対して正常にサービスを続行します。</p><p><span class="inlinemediaobject"><img src="images/automatic_failover_2.png" alt="images/automatic_failover_2.png" /></span></p><p>　Hibariのストレージ・システムにおけるチェイン・レプリケーション、フェイル・オーバー、および修復に関する詳しい情報について、さらにHibariのAdminサーバーと呼ぶ冗長構成クラスター・メンバー・アプリケーションに関する情報については、「Hibari®システム管理者ガイド」の以下の節を参照してください。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<a class="ulink" href="hibari-sysadmin-guide.en.html#hibari-architecture" target="_top">Hibariのアーキテクチャー</a>
</li><li class="listitem">
<a class="ulink" href="hibari-sysadmin-guide.en.html#life-of-brick" target="_top">（論理）ブリックのライフサイクル</a>
</li><li class="listitem">
<a class="ulink" href="hibari-sysadmin-guide.en.html#dynamic-cluster-reconfiguration" target="_top">動的クラスター再構成</a>
</li><li class="listitem">
<a class="ulink" href="hibari-sysadmin-guide.en.html#admin-server-app" target="_top">Admin Serverアプリケーション</a>
</li></ul></div></div><div class="section" title="&#x7C21;&#x5358;&#x3067;&#x30B3;&#x30B9;&#x30C8;&#x304C;&#x4F4E;&#x5EC9;&#x306A;&#x62E1;&#x5F35;&#x6027;"><div class="titlepage"><div><div><h4 class="title"><a id="scalability"></a>簡単でコストが低廉な拡張性</h4></div></div></div><p>　Hibariは次に示すように、クラスターの増加に伴うコストと運用上の複雑性を最小限に抑えながらBig Dataに拡張性を提供します。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Hibariは、物理ノードを追加して、そこに追加チェインを配置することによって、水平に拡張できます。Hibariのクラスターにマシンを追加するごとに、クラスターのストレージ容量の合計と処理性能は線形に増加します。
</li><li class="listitem">
クラスターにチェインを追加（または削減）する場合、システムは中断時間なしでストレージの自動データ配置バランシングを行うため、サービスを中断せずにHibariのストレージ・クラスターを拡大（または縮小）できます。
</li><li class="listitem">
Hibariは、汎用のPC上で稼働します。またシステムは、異なるハードウェア・リソースに容易に対応できます。ストレージ・クラスター内のブリックは、異なる容量のRAMやディスクを使用でき、CPUのさまざまな処理速度にも対応できます。異なるハードウェアを組み合わせてクラスターを構成する場合、Hibariのコンシステント・ハッシュ機能をチューニングしてクラスターの使用状況を最適化することも可能です。各チェインに重み付けファクターを指定して、キー・スペース全体に占めるチェインの割り当てを、他のチェインに比べて増加または減少させることもできます。
</li></ul></div><p>　Hibariは、異種のハードウェアの混在をサポートするだけでなく、Erlangをベースとしているため、ほとんどすべてのオペレーティング・システム上で稼働します。異種のハードウェアおよびオペレーティング・システムに容易に対応できるので、利用できるあらゆるリソースを用いてHibariをインクリメンタルに拡張できます。すべてのリソースを同時に、また同一の種類に揃えて購入する必要はありません。</p><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Hibariの水平拡張の上限値は、明確には決まっていませんが、Erlangに組み込まれたネットワーク分散機能の実装の限界から見て、200〜250ノードが実質的な限界になります。また、Hibariのチェインは、理論的には複数のデータ・センターをまたがって延長しで地理的な冗長性を確保することも可能ですが、現在のところ、単一のデータ・センター内の配置しかテストしておらず、稼働実績はありません。</p></td></tr></table></div><p>　Hibariのクラスター・サイズの変更に関する詳細情報は、「Hibari®システム管理者ガイド」の
<a class="ulink" href="hibari-sysadmin-guide.en.html#dynamic-cluster-reconfiguration" target="_top">動的なクラスター構成変更</a>の節を参照してください。</p></div><div class="section" title="&#x9AD8;&#x6027;&#x80FD; &#x2014; &#x7279;&#x306B;&#x8AAD;&#x307F;&#x51FA;&#x3057;&#x3068;&#x5927;&#x30B5;&#x30A4;&#x30BA;&#x306E;&#x30D0;&#x30EA;&#x30E5;&#x30FC;&#x306E;&#x51E6;&#x7406;&#x306E;&#x5834;&#x5408;"><div class="titlepage"><div><div><h4 class="title"><a id="high-performance"></a>高性能 — 特に読み出しと大サイズのバリューの処理の場合</h4></div></div></div><p>　Hibariのストレージ・クラスターでは、Big Dataの環境においても高性能を発揮できるよう、複数の機能が連携して働きます。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Hibariを支えるErlang技術は、分散並行処理に特化して設計されており、分散並行処理環境で優れた実力を発揮します。
</li><li class="listitem">
Hibariに実装されているコンシステント・ハッシュとチェイン・レプリケーションは、複数のチェインが分割されたキー・スペースをまたがって使用することによって、個々のチェインが受ける要求を同時に並行処理できます。チェイン間のデータの配置をチューニングして、異種のハードウェア・リソースの使用状況を最適化することも可能です。
</li><li class="listitem">
Hibariのチェイン・レプリケーションは、ストレージ・ブリックに、ヘッド、ミドル、テイルという役割の異なる処理を割り当てることによって性能を上げています。この役割分担により、特に読み出し時の性能が向上します。読み出し要求を処理するのはテイル・ブリックで、このブリックは書き込み要求に対する最初の処理の負荷を担っていないからです（この処理はヘッド・ブリックが行います）。
</li><li class="listitem">
Hibariは、多数のテーブル単位の性能チューニングのオプションをサポートしています。たとえば分散型KVDBは、バリューBLOBを保持するストレージとして、ディスクベースか、RAMベースか、どちらか一方をサポートするものしかありません。それに対してHibariは、RAM＋ディスクベース、あるいは、ディスクのみかを、アプリケーションのニーズに応じてテーブル単位で選択できます。どちらのストレージ・オプションを選んでも、データ変更のログはすべてディスクに保持されるので、電源障害発生時にもデータ復旧が可能です。ディスクI/Oは、バッチ・コミット技術を使用して最小化しています。
</li></ul></div><p>　Hibariは、こうした機能を活用することにより、現在の主流であるオープンソースのNOSQLストレージ・システムに匹敵する拡張可能な高性能を提供しています。それと同時に、多くのシステムに欠けているデータの信頼性と強い一貫性を提供します。Hibariの性能を他のNOSQLシステムと比較すると、特に読み出しと、大きいサイズ（200KB超）のバリューの処理の点で優れています。大きいサイズのバリューに対しても一貫性を確保できるHibariの高い性能は、小さいサイズのバリューの処理に適応したソリューションとは一線を画すものです。</p><p>　いかに高性能か、その実例を紹介します。数百万ユーザーが利用するWebメール・システムで、Hibariが処理したトランザクションは秒あたり2,200件、その際の読み出しの平均待ち時間は1〜20ミリ秒、書き込みの平均待ち時間は20〜80ミリ秒という実績を残しています。</p></div><div class="section" title="&#x30B7;&#x30F3;&#x30D7;&#x30EB;&#x306A;&#x304C;&#x3089;&#x5F37;&#x529B;&#x306A;&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;API"><div class="titlepage"><div><div><h4 class="title"><a id="simple-powerful-api"></a>シンプルながら強力なクライアントAPI</h4></div></div></div><p>　Hibariの中核をなすデータモデルとクライアントAPIは、キー・バリュー・ストア方式としてシンプルな設計がなされています。BLOBベースのキーとバリューのペアが、辞書のようにソートされたテーブルに対して、追加、検索、削除を行います。Hibariは、キー・バリュー・ストア方式に伴う柔軟性と拡張性を提供していますが、それと同時に、クライアント・アプリケーションと開発者のパワーを増強する次のような大きな特長を備えています。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
オプションとして、クライアントがオブジェクト単位に有効期限を設定できます。
</li><li class="listitem">
オプションとして、クライアントがオブジェクト単位にカスタム・フラグを設定できます。この柔軟性を備えたカスタム・メタデータの更新は、関連するバリューBLOBの更新の有無によらずに可能であり、検索もバリューBLOBの有無によらず可能です。
</li><li class="listitem">
オブジェクトの更新のつど、自動的にタイムスタンプを取得します。このタイムスタンプの仕組みにより、「テスト・アンド・セット」型の命令の実行が可能になります。つまりクライアントは、対象のキーのタイムスタンプが期待したものである場合にのみ、要求した命令を実行するように指定できます。
</li><li class="listitem">
HibariのクライアントAPIは、キーの制限範囲内で（具体的にはチェイン全体ではなく特定のチェイン内で）、アトミック・トランザクションをサポートします。この「マイクロ・トランザクション」のサポートは、他のオープンソースのKVDBにはないHibariの特長であり、これによって堅牢なクライアント・アプリケーションの作成がずっと簡単になります。
</li></ul></div><p>　Hibariは、複数のクライアントAPIの実装をサポートしています。たとえば、次のようなものがあります。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
ネイティブErlang
</li><li class="listitem">
ユニバーサル・バイナリ・フォーマット（UBF）
</li><li class="listitem">
Thrift
</li><li class="listitem">
Amazon S3
</li><li class="listitem">
JSON-RPC
</li></ul></div><p>　Hibariのクライアント・アプリケーションは、Java、 C/C++、Python、Ruby、Erlangなど幅広い言語で開発できます。</p><p>　HibariのクライアントAPIに関する詳細情報は、<a class="ulink" href="#client-api-erlang" target="_top">Client API: Native Erlang</a>および当ガイドでこのあと説明するクライアントAPIの章を参照してください。</p></div><div class="section" title="&#x7A3C;&#x50CD;&#x5B9F;&#x7E3E;"><div class="titlepage"><div><div><h4 class="title"><a id="production-proven"></a>稼働実績</h4></div></div></div><p>当初、Hibariを開発したのは、主にTier 1通信事業分野におけるデータ保管の要望に応えるためでした。ところがシステムが進化すると、アジアのある大手キャリアから、GB（ギガバイト）級のWebメール・サービスを開始したいという要望が寄せられました。Hibariに対するこの顧客の要求は、次のように厳しいものでした。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
開始時点で数百万ユーザー
</li><li class="listitem">
開始から数ヶ月で、保管するメッセージは数十億件
</li><li class="listitem">
ストレージ容量は数百TB（テラバイト）
</li><li class="listitem">
継続的な成長を支える柔軟性
</li><li class="listitem">
システムの低廉なコスト（サービスが「フリーミアム」モデルを採用するため）
</li><li class="listitem">
個々のメッセージのサイズは、添付情報を含めて数バイトから数MB（メガバイト）
</li><li class="listitem">
オブジェクト単位のメタデータ要求のサポート
</li><li class="listitem">
対話型セッションの強い一貫性
</li><li class="listitem">
データの信頼性（メッセージやメタデータの損失は許されない）
</li><li class="listitem">
高可用性（「常時使用可能」を第一とするサービス）
</li><li class="listitem">
短い待ち時間（エンドユーザー・トランザクションで1秒未満の応答時間）
</li></ul></div><p>　私たちは、この厳しい要求を満たすようにHibariを構築し、広範囲なテストと試行を通じて鍛え上げ、2010年初頭に、この大規模Webメール・システムのサポートを開始しました。現在このシステムは、数百万人のエンドユーザーの数十億件のメッセージを保管し、可用性、待ち時間、一貫性、信頼性、低価格という顧客の要求に応えています。</p><p>　この間に、Hibariの開発と、GB級Webメール・サービス向けの細かいチューニングと並行して、アジアの大手キャリア2社のモバイル・ソーシャル・ネットワーク・サービス向けのストレージ・ソリューションとしても導入されました。この環境で、Hibariは多様な種類とサイズのデジタルデータとともにユーザー・プロファイル・データを保管しています。</p></div><div class="section" title="&#x958B;&#x767A;&#x8005;&#x3068;&#x30B7;&#x30B9;&#x30C6;&#x30E0;&#x7BA1;&#x7406;&#x8005;&#x3001;&#x305D;&#x3057;&#x3066;&#x30D3;&#x30B8;&#x30CD;&#x30B9;&#x306B;&#x5BFE;&#x3059;&#x308B;Hibari&#x306E;&#x5229;&#x70B9;"><div class="titlepage"><div><div><h4 class="title"><a id="hibari-benefits-by-user"></a>開発者とシステム管理者、そしてビジネスに対するHibariの利点</h4></div></div></div><p>　Hibariは、アプリケーション開発者に対して、次のように大きな利点を提供します。これは、分散型キー・バリュー・ストア方式ではめったに得られない利点です。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
データの強い一貫性を保証することにより、一貫性が損なわれた場合の管理の重荷をクライアント・アプリケーションから取り除きます。
</li><li class="listitem">
マイクロ・トランザクションをサポートすることにより、強固なアプリケーションの作成をより簡単にします。
</li><li class="listitem">
オブジェクト単位のカスタム・フラグをサポートすることにより、柔軟性の高いサービスに特化したアプリケーション設計を助けます。
</li><li class="listitem">
多様なクライアントAPIを実装し、多様な開発言語をサポートします。
</li></ul></div><p>　一方、Hibariがシステム管理者に提供する大きな利点として、次のような運用の自動化があります。これにより、変化の激しいストレージ環境におけるデータ管理が、より簡単になります。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
自動レプリケーション
</li><li class="listitem">
ノード障害発生時の自動フェイル・オーバー
</li><li class="listitem">
障害ノードが復旧する場合の自動修復
</li><li class="listitem">
クラスターの拡張または縮小時の自動データ配置バランシング
</li></ul></div><p>　そしてHibariはビジネス全体に対しても、サービスの高可用性と短い待ち時間に対するユーザーの要求を満たしながら、低廉なコストでBig Dataの拡張性を提供します。Hibariは、大量のデータを扱う幅広いサービスシナリオに対応できるストレージ・ソリューションです。そのシナリオは、大規模メッセージングやソーシャルメディア、アーカイブなどをはじめ、さまざまな可能性を持ちます。Hibariは、多種多様なオブジェクトすべてに対してデータの強い一貫性と高性能が求められる環境で、その真価を発揮します。</p></div></div></div><div class="section" title="2. &#x306F;&#x3058;&#x3081;&#x306B;"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="getting-started"></a>2. はじめに</h2></div></div></div><p>　この章では、Hibariを起動して稼働させる上で必要な以下のトピックを説明します。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<a class="ulink" href="#system-requirements" target="_top">システム要件</a>
</li><li class="listitem">
<a class="ulink" href="#required-software" target="_top">必要なサードパーティのソフトウェア</a>
</li><li class="listitem">
<a class="ulink" href="#download-hibari" target="_top">Hibariをダウンロードする</a>
</li><li class="listitem">
<a class="ulink" href="#installing-single-node" target="_top">シングルノードのHibariシステムをインストールする</a>
</li><li class="listitem">
<a class="ulink" href="#starting-single-node" target="_top">シングルノードのHibariを起動する／停止する</a>
</li><li class="listitem">
<a class="ulink" href="#installing-multi-node" target="_top">マルチノードのHibariクラスターをインストールする</a>
</li><li class="listitem">
<a class="ulink" href="#starting-multi-node" target="_top">マルチノードのHibariクラスターを起動する／停止する</a>
</li><li class="listitem">
<a class="ulink" href="#creating-tables" target="_top">新しいテーブルを作成する</a>
</li></ul></div><div class="section" title="2.1. &#x30B7;&#x30B9;&#x30C6;&#x30E0;&#x8981;&#x4EF6;"><div class="titlepage"><div><div><h3 class="title"><a id="system-requirements"></a>2.1. システム要件</h3></div></div></div><p>HibariはErlangの VMをサポートするUNIXとUNIX系、およびWindows、Mac OS Xなどのオペレーティング・システム（以下、OS）上で稼働します。詳しくは、Erlangの公式サイト
<a class="ulink" href="http://www.erlang.org/faq/implementations.html" target="_top">Implementation and Ports of Erlang</a> を参照してください。
　
また、稼働環境に必要なハードウェア要件については、「Hibariシステム管理者ガイド」の
<a class="ulink" href="hibari-sysadmin-guide.en.html#brick-hardware" target="_top">ブリックのハードウェアに関する注意</a>を参照してください。</p></div><div class="section" title="2.2. &#x5FC5;&#x8981;&#x306A;&#x30B5;&#x30FC;&#x30C9;&#x30D1;&#x30FC;&#x30C6;&#x30A3;&#x306E;&#x30BD;&#x30D5;&#x30C8;&#x30A6;&#x30A7;&#x30A2;"><div class="titlepage"><div><div><h3 class="title"><a id="required-software"></a>2.2. 必要なサードパーティのソフトウェア</h3></div></div></div><p>Hibariに必要なサードパーティのソフトウェアは、シングルノードのインストールか、マルチノードのインストールかによって、異なります。</p><div class="section" title="&#x30B7;&#x30F3;&#x30B0;&#x30EB;&#x30CE;&#x30FC;&#x30C9;&#x306E;&#x30A4;&#x30F3;&#x30B9;&#x30C8;&#x30FC;&#x30EB;&#x306B;&#x5FC5;&#x8981;&#x306A;&#x30BD;&#x30D5;&#x30C8;&#x30A6;&#x30A7;&#x30A2;"><div class="titlepage"><div><div><h4 class="title"><a id="_&#x30B7;&#x30F3;&#x30B0;&#x30EB;&#x30CE;&#x30FC;&#x30C9;&#x306E;&#x30A4;&#x30F3;&#x30B9;&#x30C8;&#x30FC;&#x30EB;&#x306B;&#x5FC5;&#x8981;&#x306A;&#x30BD;&#x30D5;&#x30C8;&#x30A6;&#x30A7;&#x30A2;"></a>シングルノードのインストールに必要なソフトウェア</h4></div></div></div><p>Hibariをシングルノードにインストールする場合は、以下のソフトウェアが必要です。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
OpenSSL - <a class="ulink" href="http://www.openssl.org/" target="_top">http://www.openssl.org/</a>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
Erlangの “crypto” モジュールに必要
</li></ul></div></li></ul></div></div><div class="section" title="&#x30DE;&#x30EB;&#x30C1;&#x30CE;&#x30FC;&#x30C9;&#x306E;&#x30A4;&#x30F3;&#x30B9;&#x30C8;&#x30FC;&#x30EB;&#x306B;&#x5FC5;&#x8981;&#x306A;&#x30BD;&#x30D5;&#x30C8;&#x30A6;&#x30A7;&#x30A2;"><div class="titlepage"><div><div><h4 class="title"><a id="_&#x30DE;&#x30EB;&#x30C1;&#x30CE;&#x30FC;&#x30C9;&#x306E;&#x30A4;&#x30F3;&#x30B9;&#x30C8;&#x30FC;&#x30EB;&#x306B;&#x5FC5;&#x8981;&#x306A;&#x30BD;&#x30D5;&#x30C8;&#x30A6;&#x30A7;&#x30A2;"></a>マルチノードのインストールに必要なソフトウェア</h4></div></div></div><p>Hibariをマルチノードにインストールする際にインストーラーツールを使用すると、クラスターのセットアッププロセスを簡略化できます。最初にHibariをインストールするホストさえ決めれば、あとはこのツールが管理して、Hibariをホストにインストールします。このツールは、Hibariのノードのマシンからでも、その他のマシンからでも起動できます。「インストールノード」（インストールツールを稼働させるマシン）とHibariノード（Hibariをインストールして稼働させるマシン）では、必要となるサードパーティのソフトウェアが異なります。</p><div class="section" title="&#x30A4;&#x30F3;&#x30B9;&#x30C8;&#x30FC;&#x30EB;&#x30CE;&#x30FC;&#x30C9;&#x306B;&#x5FC5;&#x8981;&#x306A;&#x30BD;&#x30D5;&#x30C8;&#x30A6;&#x30A7;&#x30A2;"><div class="titlepage"><div><div><h5 class="title"><a id="_&#x30A4;&#x30F3;&#x30B9;&#x30C8;&#x30FC;&#x30EB;&#x30CE;&#x30FC;&#x30C9;&#x306B;&#x5FC5;&#x8981;&#x306A;&#x30BD;&#x30D5;&#x30C8;&#x30A6;&#x30A7;&#x30A2;"></a>インストールノードに必要なソフトウェア</h5></div></div></div><p>インストールノードに必要なソフトウェアは以下のとおりです。必要に応じて、リンク先のインストールガイドに従ってダウンロードしてください。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Bash - <a class="ulink" href="http://www.gnu.org/software/bash/" target="_top">http://www.gnu.org/software/bash/</a>
</li><li class="listitem">
Expect - <a class="ulink" href="http://www.nist.gov/el/msid/expect.cfm" target="_top">http://www.nist.gov/el/msid/expect.cfm</a>
</li><li class="listitem">
Perl - <a class="ulink" href="http://www.perl.org/" target="_top">http://www.perl.org/</a>
</li><li class="listitem">
SSH (client) - <a class="ulink" href="http://www.openssh.com/" target="_top">http://www.openssh.com/</a>
</li><li class="listitem"><p class="simpara">
Git - <a class="ulink" href="http://git-scm.com/" target="_top">http://git-scm.com/</a>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
バージョン1.5.4以降を使用してください。
</li><li class="listitem"><p class="simpara">
Git用の電子メールアドレスと名前を設定していない場合は、以下のように設定してください。
</p><pre class="screen">$ git config --global user.email "you@example.com"
$ git config --global user.name "Your Name"</pre></li><li class="listitem">
GitHubアカウントを取得していない場合は、ここで取得してください。 - <a class="ulink" href="https://github.com/" target="_top">https://github.com/</a>
</li></ul></div></li></ul></div><p>現在、Bash、Expect、Perl、SSHにはバージョン指定はありません。</p></div><div class="section" title="Hibari&#x30CE;&#x30FC;&#x30C9;&#x306B;&#x5FC5;&#x8981;&#x306A;&#x30BD;&#x30D5;&#x30C8;&#x30A6;&#x30A7;&#x30A2;"><div class="titlepage"><div><div><h5 class="title"><a id="_hibari&#x30CE;&#x30FC;&#x30C9;&#x306B;&#x5FC5;&#x8981;&#x306A;&#x30BD;&#x30D5;&#x30C8;&#x30A6;&#x30A7;&#x30A2;"></a>Hibariノードに必要なソフトウェア</h5></div></div></div><p>Hibariをインストールするノード群に必要なソフトウェアは以下のとおりです。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
SSH (server) - <a class="ulink" href="http://www.openssh.com/" target="_top">http://www.openssh.com/</a>
</li><li class="listitem"><p class="simpara">
OpenSSL - <a class="ulink" href="http://www.openssl.org/" target="_top">http://www.openssl.org/</a>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
Erlangの“crypto”モジュールに必要
</li></ul></div></li></ul></div></div></div></div><div class="section" title="2.3. Hibari&#x3092;&#x30C0;&#x30A6;&#x30F3;&#x30ED;&#x30FC;&#x30C9;&#x3059;&#x308B;"><div class="titlepage"><div><div><h3 class="title"><a id="download-hibari"></a>2.3. Hibariをダウンロードする</h3></div></div></div><p>現在、Hibariはビルド済みで提供することができません。当面は、ソースコードからHibariをビルドしてください。第7章の TODO(「7. ソースコードからHibariをビルドする」) の説明に従ってビルドして、その後、本節に戻ってセットアップを行ってください。</p><p>Hibariをビルドすると、後でセットアップに使用する2つのファイルが出力されます。
- tarballパッケージ“hibari-X.Y.Z-DIST-ARCH-WORDSIZE.tgz”
- md5sumファイル“hibari-X.Y.Z-DIST-ARCH-WORDSIZE-md5sum.txt”</p><p>_X.Y.Z_はリリースバージョン、_DIST_はリリースのディストリビューション、_ARCH_はリリースのアーキテクチャ、_WORDSIZE_はリリースのワードサイズです。</p></div><div class="section" title="2.4. &#x30B7;&#x30F3;&#x30B0;&#x30EB;&#x30CE;&#x30FC;&#x30C9;&#x306B;Hibari&#x3092;&#x30A4;&#x30F3;&#x30B9;&#x30C8;&#x30FC;&#x30EB;&#x3059;&#x308B;"><div class="titlepage"><div><div><h3 class="title"><a id="installing-single-node"></a>2.4. シングルノードにHibariをインストールする</h3></div></div></div><p>シングルノードにHibariをインストールしたシステムには、マルチノードのHibariクラスターが提供するようなデータのレプリケーションや冗長性はありません。しかし、テストや開発上の目的で簡単にHibariをシングルノードにインストールして配置したいときは、この方法を利用します。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
Hibariを稼働させるディレクトリを作成します。
</p><pre class="screen">$ mkdir running-directory</pre></li><li class="listitem"><p class="simpara">
Hibariをソースコードからビルドする際に出力されたtarballパッケージを解凍します。
</p><pre class="screen">$ tar -C running-directory -xvf hibari-X.Y.Z-DIST-ARCH-WORDSIZE.tgz</pre></li></ol></div><div class="important" title="&#x91CD;&#x8981;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x91CD;&#x8981;]" src="images/icons/important.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Hibariノードでは、システムの <code class="literal">/etc/sysctl.conf</code> ファイルに <code class="literal">vm.swappiness=0</code> を設定してください。ErlangのVMにおいてswappinesssの指定は望ましくありません。</p></td></tr></table></div></div><div class="section" title="2.5. &#x30B7;&#x30F3;&#x30B0;&#x30EB;&#x30CE;&#x30FC;&#x30C9;&#x306E;Hibari&#x3092;&#x8D77;&#x52D5;&#x3059;&#x308B;&#xFF0F;&#x505C;&#x6B62;&#x3059;&#x308B;"><div class="titlepage"><div><div><h3 class="title"><a id="starting-single-node"></a>2.5. シングルノードのHibariを起動する／停止する</h3></div></div></div><div class="section" title="Hibari&#x306E;&#x8D77;&#x52D5;&#x3068;&#x30D6;&#x30FC;&#x30C8;&#x30B9;&#x30C8;&#x30E9;&#x30C3;&#x30D7;"><div class="titlepage"><div><div><h4 class="title"><a id="_hibari&#x306E;&#x8D77;&#x52D5;&#x3068;&#x30D6;&#x30FC;&#x30C8;&#x30B9;&#x30C8;&#x30E9;&#x30C3;&#x30D7;"></a>Hibariの起動とブートストラップ</h4></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
Hibariを起動します。
</p><pre class="screen">$ running-directory/hibari/bin/hibari start</pre></li><li class="listitem"><p class="simpara">
Hibariを初めて起動する場合は、システムのブートストラップを実行します。
</p><pre class="screen">$ running-directory/hibari/bin/hibari-admin bootstrap</pre><p class="simpara">Hibariのブートストラッププロセスでは、まずシングルノードのAdminサーバーを起動した後、Hibariのデフォルトテーブルとして機能する１つのテーブル「tab1」を作成します。追加テーブルの作成に関する詳細は、
<a class="ulink" href="#creating-tables" target="_top">新しいテーブルの作成</a>を参照してください。</p></li></ol></div></div><div class="section" title="Hibari&#x306E;&#x691C;&#x8A3C;"><div class="titlepage"><div><div><h4 class="title"><a id="_hibari&#x306E;&#x691C;&#x8A3C;"></a>Hibariの検証</h4></div></div></div><p>シングルノードのHibariシステムの稼働状況を検証するには、以下のようにクイックチェックを実行してください。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
“Hibari Web Administration”ページがオープンできることを確認します。
</p><pre class="screen">$ your-favorite-browser http://127.0.0.1:23080</pre></li><li class="listitem"><p class="simpara">
Hibariノードにpingが打てることを確認します。
</p><pre class="screen">$ running-directory/hibari/bin/hibari ping</pre></li></ol></div><div class="important" title="&#x91CD;&#x8981;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x91CD;&#x8981;]" src="images/icons/important.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>シングルノードのHibariシステムは、ローカルホストアドレス127.0.0.1のみに応答するようにハードコーディングされています。したがって、Hibari ノードにはそのノード自身からしか到達できません。</p></td></tr></table></div></div><div class="section" title="Hibari&#x306E;&#x505C;&#x6B62;"><div class="titlepage"><div><div><h4 class="title"><a id="_hibari&#x306E;&#x505C;&#x6B62;"></a>Hibariの停止</h4></div></div></div><p>Hibariを停止するには、以下を実行してください。</p><pre class="screen">$ running-directory/hibari/bin/hibari stop</pre></div></div><div class="section" title="2.6. &#x30DE;&#x30EB;&#x30C1;&#x30CE;&#x30FC;&#x30C9;&#x306E;&#x30AF;&#x30E9;&#x30B9;&#x30BF;&#x30FC;&#x306B;Hibari&#x3092;&#x30A4;&#x30F3;&#x30B9;&#x30C8;&#x30FC;&#x30EB;&#x3059;&#x308B;"><div class="titlepage"><div><div><h3 class="title"><a id="installing-multi-node"></a>2.6. マルチノードのクラスターにHibariをインストールする</h3></div></div></div><p>ターゲットノードにHibariをインストールする前に、以下の準備を実行してください。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
インストールノードおよびターゲットのHibariノード群に、必要なユーザー権限を設定してください。
</li><li class="listitem">
クラスター用のインストーラーツールをダウンロードしてください。
</li><li class="listitem">
クラスター用のインストーラーツールを設定してください。
</li></ul></div><div class="section" title="&#x30E6;&#x30FC;&#x30B6;&#x30FC;&#x6A29;&#x9650;&#x306E;&#x8A2D;&#x5B9A;"><div class="titlepage"><div><div><h4 class="title"><a id="_&#x30E6;&#x30FC;&#x30B6;&#x30FC;&#x6A29;&#x9650;&#x306E;&#x8A2D;&#x5B9A;"></a>ユーザー権限の設定</h4></div></div></div><p>インストール時に使用するシステムのユーザーIDは、Hibariの実行時のユーザーIDとは異なるものでなければなりません。インストールを実行するユーザーアカウント ($USER) は、以下のようにセットアップします。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
$USERは、インストールノードにも、ターゲットHibariノード群にも必要です。
</li><li class="listitem">
$USERは、インストールノードにおいてSSHの公開鍵と秘密鍵を持つ必要があります。パスワード認証なしにSSHでログインできるようにSSH agentを設定してください。
</li><li class="listitem">
$USERアカウントは、ターゲットのHibariノードでも、パスワード認証なしにSSHでログインできなければなりません。
</li><li class="listitem">
$USERアカウントは、ターゲットのHibariノード上で、パスワード認証なしにsudoコマンドでアクセスできなければなりません。
</li></ul></div><p>インストールを実行するユーザーのアカウントに上記の権限がない場合は、以下のステップを実行してください。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
rootユーザーとして、インストールノードにインストールユーザー ($USER) を追加します。その後、各Hibariノードにインストールユーザーを追加して、そのユーザーにパスワード認証なしのsudo権限を付与します。
</p><pre class="screen">$ useradd $USER
$ passwd $USER
$ visudo
# append the following line and save it
$USER  ALL=(ALL)       NOPASSWD: ALL</pre><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>sudoのテスト中に“sudo: sorry, you must have a tty to run sudo”というエラーメッセージが出た場合は、 <code class="literal">/etc/sudoers</code> ファイル内の次の行をコメントアウトしてください。</p></td></tr></table></div><pre class="screen">$ visudo
Defaults    requiretty</pre></li><li class="listitem"><p class="simpara">
インストールノードに、インストールユーザー用のSSHの公開鍵と秘密鍵を新たに作成します。
</p><pre class="screen">$ ssh-keygen
# enter your password for the private key
$ eval `ssh-agent`
$ ssh-add ~/.ssh/id_rsa
# re-enter your password for the private key</pre></li><li class="listitem"><p class="simpara">
各Hibariノードにおいて
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">\~/.ssh/known_hosts</code> ファイルに、インストールノードのエントリーを追加します。
</li><li class="listitem"><p class="simpara">
<code class="literal">~/.ssh/authorized_keys</code> ファイルに、SSHの公開鍵のエントリーを追加します。
</p><p class="simpara">以下の例では、dev1、dev2、dev3がターゲットのHibariノード群です。</p><pre class="screen">$ ssh-copy-id -i ~/.ssh/id_rsa.pub $USER@dev1
$ ssh-copy-id -i ~/.ssh/id_rsa.pub $USER@dev2
$ ssh-copy-id -i ~/.ssh/id_rsa.pub $USER@dev3</pre><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>インストールノードがHibariのクラスターノードの１つである場合は、インストールノードにもssh-copy-idを実行する必要があります。</p></td></tr></table></div></li></ul></div></li><li class="listitem"><p class="simpara">
各Hibariノードへのパスワード認証のないSSHのアクセスが、期待どおりに行われることを確認します。
</p><pre class="screen">$ ssh $USER@dev1
$ ssh $USER@dev2
$ ssh $USER@dev3</pre></li></ol></div><div class="tip" title="&#x30D2;&#x30F3;&#x30C8;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x30D2;&#x30F3;&#x30C8;]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>SSHのセットアップの詳細について知りたい場合は、 ( <a class="ulink" href="http://inside.mines.edu/~gmurray/HowTo/sshNotes.html" target="_top">http://inside.mines.edu/~gmurray/HowTo/sshNotes.html</a> )を参照してください。</p></td></tr></table></div></div><div class="section" title="Cluster&#x30A4;&#x30F3;&#x30B9;&#x30C8;&#x30FC;&#x30E9;&#x30FC;&#x30C4;&#x30FC;&#x30EB;&#x306E;&#x30C0;&#x30A6;&#x30F3;&#x30ED;&#x30FC;&#x30C9;"><div class="titlepage"><div><div><h4 class="title"><a id="download-cluster"></a>Clusterインストーラーツールのダウンロード</h4></div></div></div><p>“Cluster”とは、Hibariのノード群のクラスターのインストールと設定、およびブートストラップに使用する簡単なツールです。このツールはHibariパッケージの一部ではありませんが、GitHubから入手できます。</p><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Clusterは、多くのユーザーのニーズを満たすツールです。ただし現在、このツールの「ターゲットノード」のレシピはLinux主体に書かれています（たとえばuseraddや userdelなど）。その他のOSやプラットフォーム向けのパッチ類の提供が望まれます。Linux以外の配置の場合のClusterツールは比較的単純で、ツールのレシピどおりに操作すれば手動でインストールできます。</p></td></tr></table></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
Clusterツールをダウンロードするための作業用ディレクトリを作成します。
</p><pre class="screen">$ mkdir working-directory</pre></li><li class="listitem"><p class="simpara">
GitHubからClusterツールのGitリポジトリをダウンロードします。
</p><pre class="screen">$ cd working-directory
$ git clone git://github.com/hibari/clus.git</pre><p class="simpara">このダウンロードにより、<code class="literal">clus</code> というサブディレクトリが作成され、その下に、インストーラーツールと種々のサポートファイルが格納されます。</p></li></ol></div></div><div class="section" title="Cluster&#x30C4;&#x30FC;&#x30EB;&#x306E;&#x8A2D;&#x5B9A;"><div class="titlepage"><div><div><h4 class="title"><a id="config-cluster"></a>Clusterツールの設定</h4></div></div></div><p>Clusterツールには、Hibariのクラスターのセットアップ方法を示す基本的な設定情報が必要です。必要な設定を明記した簡単なテキストファイルを作り、Clusterツールを稼働させる際に、そのファイルをインプットとして使ってください。</p><p>設定情報ファイルは、Clusterツールをダウンロードした作業用ディレクトリ内に作成するのが最も簡単です。ファイル名は何でもかまいません。ここでは説明のために <code class="literal">hibari.config</code> というファイル名を使用します。</p><p>以下は <code class="literal">hibari.config</code> ファイルのサンプルです。作成するファイルには、ここに示したすべてのパラメータを記載する必要があります。またその値は、この例と同じ書式（括弧や引用符も）でなければなりません。パラメータの記述はサンプルに従ってください。</p><pre class="screen">ADMIN_NODES=(dev1 dev2 dev3)
BRICK_NODES=(dev1 dev2 dev3)
BRICKS_PER_CHAIN=2

ALL_NODES=(dev1 dev2 dev3)
ALL_NETA_ADDRS=("10.181.165.230" "10.181.165.231" "10.181.165.232")
ALL_NETB_ADDRS=("10.181.165.230" "10.181.165.231" "10.181.165.232")
ALL_NETA_BCAST="10.181.165.255"
ALL_NETB_BCAST="10.181.165.255"
ALL_NETA_TIEBREAKER="10.181.165.1"

ALL_HEART_UDP_PORT="63099"
ALL_HEART_XMIT_UDP_PORT="63100"</pre><div class="itemizedlist"><a id="eligible-admin-nodes"></a><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
<code class="literal">ADMIN_NODES</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
Hibari Adminサーバーを起動できるノード群のホスト名。Adminサーバーに関する詳細は、「Hibariシステム管理者ガイド」の
   <a class="ulink" href="hibari-sysadmin-guide.en.html#admin-server-app" target="_top">Adminサーバーアプリケーション</a>を参照してください。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">BRICK_NODES</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
Hibariのストレージ・ブリックとして機能するノード群のホスト名。上記設定ファイルのサンプルには3つのストレージ・ブリックのノード（dev1、dev2、dev3）があり、この3つのノードのそれぞれでAdminサーバーを稼働できます。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">BRICKS_PER_CHAIN</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
チェイン・レプリケーションごとのブリック数。たとえば、1チェインあたり2ブリックであれば、チェインに格納されるデータには2つのコピーが存在します（ブリックごとに1コピー）。1チェインあたり3ブリックであれば、3つのコピーが存在します。チェイン・レプリケーションの概要は、本ドキュメントの<a class="ulink" href="#chain-replication" target="_top">「1.2.2 チェイン・レプリケーションによる高可用性と強い一貫性」</a>を参照してください。チェイン・レプリケーションの詳細は、Hibariシステム管理者ガイドを参照してください。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">ALL_NODES</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">ADMIN_NODES</code> と <code class="literal">BRICK_NODES</code> の和集合によって得られるHibariの全ノードのリスト。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">ALL_NETA_ADDRS</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
「Hibariシステム管理者ガイド」の
<a class="ulink" href="hibari-sysadmin-guide.en.html#partition-detector" target="_top">パーティション化検出アプリケーション</a>に記述されているように、マルチノードのHibariのクラスター内の各ノードは、2つのネットワーク（ネットワークAおよびネットワークB）に接続されていなければなりません。これは、ネットワークのパーティションを検出および管理するためです。 <code class="literal">ALL_NETA_ADDRS</code> パラメータで、ネットワークA内の各HibariノードのIPアドレスを指定します。このネットワークAを介して、データ・レプリケーションおよびその他のErlangの通信が行われます。IPアドレスの一覧は、 <code class="literal">ALL_NODES</code> で指定したホスト名に対応している必要があります。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">ALL_NETB_ADDRS</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
ネットワークB内におけるHibariの各ノードのIP アドレス。ネットワークBは、ネットワークパーティションの検出に役立つハートビートブロードキャストのためだけに使用されます。IPアドレスの一覧の順番は、ALL_NODESで設定したホスト名の順番に対応している必要があります。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">ALL_NETA_BCAST</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
ネットワークAのIP ブロードキャストアドレス。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">ALL_NETB_BCAST</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
ネットワークBのIP ブロードキャストアドレス。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">ALL_NETA_TIEBREAKER</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
ネットワークAでパーティション問題が発生した場合に、「タイブレーカ」として使用するネットワーク監視アプリケーション用のIPアドレス。Hibariノードにおいて、ネットワークAにパーティションが発生し、ネットワークBにはパーティションが発生していないとネットワーク監視アプリケーションが判断した場合、ネットワークAのタイブレーカのIPアドレスがpingに応答すれば、ローカルノードはパーティションの「正しい」側に存在することになります。タイブレーカは、Erlangのすべてのネットワーク通信が配信されるレイヤ2のスイッチまたはレイヤ3のルータのアドレスであることが望まれます。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">ALL_HEART_UDP_PORT</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
ハートビート・リスナー用のUDPポート。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">ALL_HEART_XMIT_UDP_PORT</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
ハートビート・トランスミッター用のUDPポート。
</li></ul></div></li></ul></div><p>ネットワーク監視の設定に関する詳細は、パーティション検出のOTPアプリケーションのソースファイル (<a class="ulink" href="https://github.com/hibari/partition-detector/raw/master/src/partition_detector.app.src" target="_top">https://github.com/hibari/partition-detector/raw/master/src/partition_detector.app.src</a>) を参照してください。</p><div class="caution" title="&#x6CE8;&#x610F;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x610F;]" src="images/icons/caution.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>稼働時の設定では、ネットワークAとネットワークBを、物理的に異なるネットワークおよびネットワークインターフェイスにするべきです。しかし、テストおよび開発時には、ネットワークAとネットワークBを物理的に同じネットワークにすることができます（設定ファイルの上記サンプルと同様）。</p></td></tr></table></div><p>最終ステップとして、 <span class="strong"><strong>各Hibariノード</strong></span> で</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
<code class="literal">/etc/hosts</code> ファイルに、クラスター内のすべてのHibariノード群のエントリーがあることを確認します。
</p><pre class="screen">10.181.165.230  dev1.your-domain.com    dev1
10.181.165.231  dev2.your-domain.com    dev2
10.181.165.232  dev3.your-domain.com    dev3</pre></li><li class="listitem">
システムの <code class="literal">/etc/sysctl.conf</code> ファイルに <code class="literal">vm.swappiness=0</code> を設定してください。Erlangの VMにおいてswappinessを指定することは望ましくありません。
</li></ul></div></div><div class="section" title="Hibari&#x306E;&#x30A4;&#x30F3;&#x30B9;&#x30C8;&#x30FC;&#x30EB;"><div class="titlepage"><div><div><h4 class="title"><a id="_hibari&#x306E;&#x30A4;&#x30F3;&#x30B9;&#x30C8;&#x30FC;&#x30EB;"></a>Hibariのインストール</h4></div></div></div><p>インストールノードからインストールユーザーとしてログインし、以下の手順でHibariクラスターを作成します。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
<a class="ulink" href="#download-cluster" target="_top">Clusterツールのダウンロード</a>および
  <a class="ulink" href="#config-cluster" target="_top">クラスター設定情報ファイルの作成</a>を行った作業ディレクトリに、Hibariのtarballパッケージとmd5sumファイルがあることを確認します。
</p><pre class="screen">$ cd working-directory
$ ls -1
clus
hibari-X.Y.Z-DIST-ARCH-WORDSIZE-md5sum.txt
hibari-X.Y.Z-DIST-ARCH-WORDSIZE.tgz
hibari.config
$</pre></li><li class="listitem"><p class="simpara">
Hibariのすべてのノードに、”hibari”というユーザーを作成します。
</p><pre class="screen">$ for i in dev1 dev2 dev3 ; do ./clus/priv/clus.sh -f init hibari $i ; done
hibari@dev1
hibari@dev2
hibari@dev3</pre><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>“hibari”ユーザーがすでにそのノードに存在する場合は、-fオプションが“hibari”ユーザーを強制的に削除して、再度作成します。</p></td></tr></table></div></li><li class="listitem"><p class="simpara">
新たに作成した「hibari」ユーザーを通して、HibariのすべてのノードにHibariパッケージをインストールします。
</p><pre class="screen">$ ./clus/priv/clus-hibari.sh -f init hibari hibari.config hibari-X.Y.Z-DIST-ARCH-WORDSIZE.tgz
hibari@dev1
hibari@dev2
hibari@dev3</pre></li></ol></div><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>デフォルト設定では、Clusterツールはターゲットノード群の <code class="literal">/usr/local/var/lib</code> にHibariをインストールします。別の場所へインストールしたい場合は、インストールの前に <code class="literal">clus.sh</code> スクリプト（作業用ディレクトリの <code class="literal">/clus/priv/</code> の下）を開き、 <code class="literal">CT_HOMEBASEDIR</code> 変数を編集してください。</p></td></tr></table></div></div></div><div class="section" title="2.7. &#x30DE;&#x30EB;&#x30C1;&#x30CE;&#x30FC;&#x30C9;&#x306E;Hibari&#x30AF;&#x30E9;&#x30B9;&#x30BF;&#x30FC;&#x3092;&#x8D77;&#x52D5;&#x3059;&#x308B;&#xFF0F;&#x505C;&#x6B62;&#x3059;&#x308B;"><div class="titlepage"><div><div><h3 class="title"><a id="starting-multi-node"></a>2.7. マルチノードのHibariクラスターを起動する／停止する</h3></div></div></div><p>マルチノードのHibariクラスターの起動および停止は、インストールプロセスを管理したノードから、Clusterツールを使って行います。本節で説明するHibariの各コマンドは、インストール手続き中に作成した
<a class="ulink" href="#config-cluster" target="_top">Clusterツール設定情報ファイル</a>のファイル名を参照することに注意してください。</p><div class="section" title="Hibari&#x30AF;&#x30E9;&#x30B9;&#x30BF;&#x30FC;&#x306E;&#x8D77;&#x52D5;&#x304A;&#x3088;&#x3073;&#x30D6;&#x30FC;&#x30C8;&#x30B9;&#x30C8;&#x30E9;&#x30C3;&#x30D7;"><div class="titlepage"><div><div><h4 class="title"><a id="_hibari&#x30AF;&#x30E9;&#x30B9;&#x30BF;&#x30FC;&#x306E;&#x8D77;&#x52D5;&#x304A;&#x3088;&#x3073;&#x30D6;&#x30FC;&#x30C8;&#x30B9;&#x30C8;&#x30E9;&#x30C3;&#x30D7;"></a>Hibariクラスターの起動およびブートストラップ</h4></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
Clusterツールをダウンロードした作業用ディレクトリに移り、“hibari”ユーザーによって、HibariのすべてのノードでHibariを起動します。
</p><pre class="screen">$ cd working-directory
$ ./clus/priv/clus-hibari.sh -f start hibari hibari.config
hibari@dev1
hibari@dev2
hibari@dev3</pre></li><li class="listitem"><p class="simpara">
Hibariを初めて起動する場合は、“hibari”ユーザーを通じて、システムのブートストラップを実行します。
</p><pre class="screen">$ ./clus/priv/clus-hibari.sh -f bootstrap hibari hibari.config
hibari@dev1 =&gt; hibari@dev1
hibari@dev2
hibari@dev3</pre><p class="simpara">Hibariのブートストラッププロセスが、最初の
<a class="ulink" href="#eligible-admin-nodes" target="_top">適格なadminノード</a>で、HibariのAdminサーバーを起動し、Hibariのデフォルトテーブルとして機能する１つのテーブル「tab1」を作成します。追加テーブルの作成に関する詳細は、<a class="ulink" href="#creating-tables" target="_top">新しいテーブルを作成する</a>を参照してください。</p><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>ブートストラップで“another_admin_server_running”というエラーが出た場合は、そのネットワークで稼働中の他のHibariのクラスターを停止してください。あるいは他のHibariクラスターや他のアプリケーションで使われていない
<a class="ulink" href="#eligible-admin-nodes" target="_top">Hibariハートビートリスナーポート</a>をClusterツールに割り当てるように設定変更し、その後で、クラスターのインストール手続きを繰り返してください。</p></td></tr></table></div></li></ol></div></div><div class="section" title="Hibari&#x30AF;&#x30E9;&#x30B9;&#x30BF;&#x30FC;&#x306E;&#x691C;&#x8A3C;"><div class="titlepage"><div><div><h4 class="title"><a id="_hibari&#x30AF;&#x30E9;&#x30B9;&#x30BF;&#x30FC;&#x306E;&#x691C;&#x8A3C;"></a>Hibariクラスターの検証</h4></div></div></div><p>Hibariが立ち上がって稼働していることを検証するため、以下の簡単なチェックを行ってください。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
“Hibari Web Administration”ページをオープンできるかどうか確認します。
</p><pre class="screen">$ your-favorite-browser http://dev1:23080</pre></li><li class="listitem"><p class="simpara">
各Hibariノードにpingが打てることを確認します。
</p><pre class="screen">$ ./clus/priv/clus-hibari.sh -f ping hibari hibari.config
hibari@dev1 ... pong
hibari@dev2 ... pong
hibari@dev3 ... pong</pre></li></ol></div></div><div class="section" title="Hibari&#x30AF;&#x30E9;&#x30B9;&#x30BF;&#x30FC;&#x306E;&#x505C;&#x6B62;"><div class="titlepage"><div><div><h4 class="title"><a id="_hibari&#x30AF;&#x30E9;&#x30B9;&#x30BF;&#x30FC;&#x306E;&#x505C;&#x6B62;"></a>Hibariクラスターの停止</h4></div></div></div><p>“hibari”ユーザーを通じて、すべてのHibariノードでHibariを停止します。</p><pre class="screen">$ cd working-directory
$ ./clus/priv/clus-hibari.sh -f stop hibari hibari.config
ok
ok
ok
hibari@dev1
hibari@dev2
hibari@dev3</pre></div></div><div class="section" title="2.8. &#x65B0;&#x3057;&#x3044;&#x30C6;&#x30FC;&#x30D6;&#x30EB;&#x3092;&#x4F5C;&#x6210;&#x3059;&#x308B;"><div class="titlepage"><div><div><h3 class="title"><a id="creating-tables"></a>2.8. 新しいテーブルを作成する</h3></div></div></div><p>新しいテーブルは、AdminサーバーのGUIを通して作成するのが最も簡単です。“http://localhost:23080/” を開き、“Add a table” をクリックしてください。GUIに加えて、hibari-admin ツールで新しいテーブルを作成することも可能です。詳しい使用法は、hibari-admin ツールの説明を参照してください。</p><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>管理用のAPIを使ったテーブル作成の方法については、「Hibariシステム管理者ガイド」を参照してください。</p></td></tr></table></div><p>GUIを使ってテーブルを追加する場合、以下のようなテーブル設定のオプションがあります。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
<code class="literal">Local</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
Boolean型。真の場合、新しいテーブルのデータを保存するブリックは、ローカルノード（Adminサーバーが稼働しているノード）に作成されます。偽の場合、「NodeList」フィールドを使って新たなブリックを作成するクラスターノードを指定します。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">BigData</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
Boolean型。真の場合、バリューBLOBはディスク上に保存されます。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">DiskLogging</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
Boolean型。真の場合、すべての更新は、永続性を実現するため、先行書き込みログに記述されます。偽の場合、ブリックは高速処理されますが、クラスターにまたがる電力障害が発生した場合、データ損失にかかる費用負担が大きくなります。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">SyncWrites</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
Boolean型。真の場合、先行書き込みログへの書き込みは、システムコールfsync(2)を通じて安定記憶装置へ送られます。偽の場合、ブリックは高速処理されますが、クラスターにまたがる電力障害が発生した場合、データ損失にかかる費用負担が大きくなります。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">VarPrefix</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
Boolean型。真の場合、キーの可変長プレフィックス（接頭辞）が、コンシステント・ハッシュ関数へのインプットとして使われます。偽の場合は、キー全体が使われます。
</p><p class="simpara">可変長または固定長のプレフィックスを対象にしたハッシュ・スキームは、多くのアプリケーションにとってメリットがあります。一例として、さまざまなユーザーの状態を保持するアプリケーションを考えてみましょう。アプリケーションは、マイクロ・トランザクションを使用して、そのユーザーに関連する（同一テーブルの）さまざまなキーを更新できると都合が良いでしょう。テーブルを作成することで、VarPrefix=trueをVarPrefixSeparator=47(ASCII 47は「/」) およびVarPrefixNumSeparator=2と共に使用し、キー/FooUser/summaryと/FooUser/thing1と/FooUser/thing9が同じチェインに保存されることを保証するハッシュ・スキームを作成できます。</p><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>テーブルを作成するHTTPインターフェイスは、固定長のプレフィックススキームを公開していません。この場合、Erlangの APIを使用しなければなりません。</p></td></tr></table></div></li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">VarPrefixSeparator</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
Integer型。可変長のプレフィックス計算で使われる文字コードを定義します。デフォルト値のASCII 47 (文字「/」)やその他の文字は、UNIX/POSIX形式のファイルやディレクトリを意味するものではないことに注意してください。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">VarPrefixNumSeparators</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
Integer型。コンシステント・ハッシュで使われるVarPrefixSeparatorのバイト数、およびその間のすべてのバイトを定義します。たとえば/foo/bar/bazというキーについて、VarPrefixSeparator=47、VarPrefixNumSeparators=3であれば、コンシステント・ハッシュで使われるプレフィックスは/foo/bar/となります。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">Bricks</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
Integer型。Local=true（上記を参照）の場合、この整数は、ローカルノードに作成される論理ブリックの総数を定義します。Local=falseの場合、この値は無視されます。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">BPC</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
Integer型。チェインごとのブリック数を定義します。
</p><p class="simpara">チェインを作成するアルゴリズム → ブリック・マッピングは「ストライピング」の原則に基づいています。ブリックは十分な長さのチェインにストライプ状に置かれ、その結果、ヘッド、ミドル、テイルの役割をする同数の論理ブリックを持つことになります。「Hibariシステム管理者ガイド」の、
<a class="ulink" href="hibari-sysadmin-guide.en.html#3-chains-striped-across-3-bricks" target="_top">3ノードでストライプ構造を持つ3チェイン</a>の例を参照してください。</p><p class="simpara">Erlang のAPIは、他のチェイン・レイアウトパターンで、テーブルの作成に使用されます。</p></li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">NodeList</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
カンマ区切りの文字列。Local=falseの場合、新しいテーブルのために論理ブリックを稼働させるノードの一覧を指定します。カンマ区切りの一覧は、<code class="literal">NodeName@HostName</code> の形式で表記されます。たとえば、3ノードの指定には、<code class="literal">hibari1@machine-a、 hibari1@machine-b、 hibari1@machine-c</code> を使用します。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">NumNodesPerBlock</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
Integer型。Local=falseの場合、この整数がデフォルトのチェイン・ストライピング・アルゴリズムのストライピングの振る舞いに影響します。この値はゼロ（パラメータが無視されます）または複数のBPCパラメータです。
</p><p class="simpara">たとえば、NodeListにA、B、C、D、E、Fというノードがあれば、以下のストライピングパターンが使用されます。</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
NumNodesPerBlock=0の場合、6チェインが6ノードにわたってストライプします。
</li><li class="listitem">
NumNodesPerBlock=2かつBPC=2の場合、2チェインがノードA と B、2チェインがノードC と D、2チェインがノードEと Fにわたってストライプします。
</li><li class="listitem">
NumNodesPerBlock=3かつBPC=3の場合、3チェインがノード A と Bと C、3チェインがノードD と Eと Fにわたってストライプします。
</li></ul></div></li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">BlockMultFactor</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
Integer型。Local=falseの場合、この整数がデフォルトのチェイン・ストライピング・アルゴリズムのストライピングの振る舞いに影響します。この値はゼロ（パラメータが無視されます）またはゼロ以上にしなければなりません。
</p><p class="simpara">たとえば、NodeListにA、B、C、D、E、Fというノードがあれば、以下のストライピングパターンが使用されます。</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
NumNodesPerBlock=0かつBlockMultFactor=0の場合、6チェインが6ノードにわたってストライプします。
</li><li class="listitem">
NumNodesPerBlock=2かつBlockMultFactor=5かつBPC=2の場合、トータル30チェインについて、2×5=10チェインがノードA と Bに、2×5=10チェインがノードC と Dに、2×5=10チェインがノードE とFにわたってストライプします。
</li><li class="listitem">
NumNodesPerBlock=3かつBlockMultFactor=4かつBPC=3の場合、トータル24チェインについて、3×4=12チェインがノードA と Bと Cに、3×4=12チェインがノードD と Eと Fにわたってストライプします。
</li></ul></div></li></ul></div></li></ul></div></div></div><div class="section" title="3. &#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;API &#xFF1A; &#x30CD;&#x30A4;&#x30C6;&#x30A3;&#x30D6;Erlang"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="client-api-erlang"></a>3. クライアントAPI ： ネイティブErlang</h2></div></div></div><div class="section" title="3.1. Hibari&#x306E;&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;API&#x306E;&#x6982;&#x8981;"><div class="titlepage"><div><div><h3 class="title"><a id="_hibari&#x306E;&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;api&#x306E;&#x6982;&#x8981;"></a>3.1. HibariのクライアントAPIの概要</h3></div></div></div><p>キー・バリュー型データベースとしてHibariが提供するクライアントAPIは非常にシンプルです。APIによって、データの追加、検索、削除という基本的な操作ができます。制限はありますが、その範囲内で操作を組み合わせればアトミック・トランザクションも実行できます。</p><p>HibariのクライアントAPIで実行できる操作は、次のとおりです。ネイティブErlangのAPIの各操作の詳細に関しては、リンク先を参照してください。</p><p><span class="strong"><strong>データの追加　</strong></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
まだ存在していないキーとバリューのペアを新たに追加します。オプションでフラグを追加できます。
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<a class="ulink" href="#brick-simple-add" target="_top">brick_simple:add/6</a>
</li></ul></div></li><li class="listitem"><p class="simpara">
既に存在しているキーに対して、新しいバリューやフラグを割り当てます。
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<a class="ulink" href="#brick-simple-replace" target="_top">brick_simple:replace/6</a>
</li></ul></div></li><li class="listitem"><p class="simpara">
キーの存在の有無にかかわらず、キーとバリューのペアと、オプションでフラグを設定します。
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<a class="ulink" href="#brick-simple-set" target="_top">brick_simple:set/6</a>
</li></ul></div></li></ul></div><p><span class="strong"><strong>データの検索</strong></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
キーを検索します。オプションで、そのキーに関連付けられたバリューとフラグを検索します。
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<a class="ulink" href="#brick-simple-get" target="_top">brick_simple:get/4</a>
</li></ul></div></li><li class="listitem"><p class="simpara">
辞書の順に並んで連続している複数のキーを検索します。オプションで、そのキーに関連付けられたバリューとフラグを検索します。
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<a class="ulink" href="#brick-simple-get-many" target="_top">brick_simple:get_many/5</a>
</li></ul></div></li></ul></div><p><span class="strong"><strong>データの削除</strong></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
キーとバリューのペア、およびそれに関連付けられたフラグを削除します。
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<a class="ulink" href="#brick-simple-delete" target="_top">brick_simple:delete/4</a>
</li></ul></div></li></ul></div><p><span class="strong"><strong>複合操作</strong></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
指定した操作のリストを実行します。オプションで、アトミック・トランザクションとして実行します。
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<a class="ulink" href="#brick-simple-do" target="_top">brick_simple:do/4</a>
</li></ul></div></li></ul></div><p><span class="strong"><strong>フォールド操作</strong></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
テーブル内のすべてのキーに対して、フォールド操作を実行します。
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<a class="ulink" href="#brick-simple-fold-table" target="_top">brick_simple:fold_table/7</a>
</li></ul></div></li><li class="listitem"><p class="simpara">
指定したプレフィックスで始まるすべてのキーに対して、フォールド操作を実行します。
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<a class="ulink" href="#brick-simple-fold-key" target="_top">brick_simple:fold_key_prefix/9</a>
</li></ul></div></li></ul></div><p>クライアント側の必要に応じて、データの追加、検索、削除に「テスト・アンド・セット」ロジックを適用すると、指定したキーのタイムスタンプと一致する場合にのみ操作を実行させることができます。</p><div class="section" title="Erlang&#x306E;&#x57FA;&#x672C;&#x30C7;&#x30FC;&#x30BF;&#x578B;"><div class="titlepage"><div><div><h4 class="title"><a id="_erlang&#x306E;&#x57FA;&#x672C;&#x30C7;&#x30FC;&#x30BF;&#x578B;"></a>Erlangの基本データ型</h4></div></div></div><p>この章で参照するErlangの基本データ型について、簡単に紹介します。これは、
<a class="ulink" href="http://www.erlang.org/doc/reference_manual/data_types.html" target="_top">Erlangのデータ型に関する公式ドキュメント</a>からの抜粋を少し変更したものです。詳細な情報は、Erlangの公式ドキュメントを参照してください。</p><div class="important" title="&#x91CD;&#x8981;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x91CD;&#x8981;]" src="images/icons/important.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>すべてのErlangのコマンドは、最後にピリオド（’.’）をつけてください。</p></td></tr></table></div><div class="variablelist"><dl><dt><span class="term">
項（term）
</span></dt><dd>
すべてのデータ型のデータを <span class="strong"><strong>項(term)</strong></span> と呼びます。
</dd><dt><span class="term">
数値（number）
</span></dt><dd>
数値定数には、 <span class="strong"><strong>Integer(整数)型</strong></span> と <span class="strong"><strong>Float(浮動小数点)型</strong></span> の2種類があります。
</dd><dt><span class="term">
アトム（atom）
</span></dt><dd><p class="simpara">
アトム（atom）はリテラル（名前を持つ定数）です。英小文字以外で始まるアトム、および英数字と下線（’_’）と’@’以外を含むアトム場合は、次の例のように一重引用符（’）で囲んでください。
</p><pre class="screen">hello
phone_number
'Monday'
'phone number'
'hello'
'phone_number'</pre></dd><dt><span class="term">
Bit string（ビット列）とBinary（バイナリ）
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Bit string(ビット列)</strong></span> は、型指定のないメモリー領域にデータを保管するときに使用します。表記は、
<a class="ulink" href="http://www.erlang.org/doc/reference_manual/expressions.html#bit_syntax" target="_top">Erlangのビット構文</a>に従います。また、8の倍数のビット数からなるビット列を、 <span class="strong"><strong>Binary(バイナリ)</strong></span> と呼びます。たとえば次のように表します。
</p><pre class="screen">&lt;&lt;10,20&gt;&gt;
&lt;&lt;"ABC"&gt;&gt;</pre></dd><dt><span class="term">
Tuple（タプル）
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Tuple(タプル)</strong></span> は、固定数の項の組からなるデータ型です。次の例のように、中括弧（’{ }’）で囲んで表します。
</p><pre class="screen">{Term1,...,TermN}</pre></dd><dt><span class="term">
List（リスト）
</span></dt><dd><p class="simpara">
<span class="strong"><strong>List(リスト)</strong></span> は、可変数の項の組からなるデータ型です。次の例のように、大括弧（’[ ]’）で囲んで表します。
</p><pre class="screen">[Term1,...,TermN]</pre></dd><dt><span class="term">
String（文字列）
</span></dt><dd>
<span class="strong"><strong>String(文字列)</strong></span> は、二重引用符（”）で囲んで表します。これは、Erlangの正式のデータ型ではありません。リスト[$h,$e,$l,$l,$o]、つまり[104,101,108,108,111]の代わりに、簡略化した表現として”hello”という文字列を使用します。
</dd><dt><span class="term">
Boolean（ブール）
</span></dt><dd>
ErlangにBoolean型（論理型）はありません。ブール値を表す場合は、代わりにアトムの <code class="literal">真（true）</code> と <code class="literal">偽（false）</code> を使用します。
</dd></dl></div></div><div class="section" title="Hibari&#x306E;&#x30C7;&#x30FC;&#x30BF;&#x30E2;&#x30C7;&#x30EB;"><div class="titlepage"><div><div><h4 class="title"><a id="_hibari&#x306E;&#x30C7;&#x30FC;&#x30BF;&#x30E2;&#x30C7;&#x30EB;"></a>Hibariのデータモデル</h4></div></div></div><p>HibariのテーブルをSQLデータベースの方法で表現すると、次のようになります。</p><a id="sql-definition-hibari"></a><pre class="screen">CREATE TABLE foo (
    BLOB key;
    BLOB value;
    INTEGER timestamp;                  -- Monotonically increasing
    INTEGER expiration_time;            -- Usually zero
    LIST OF ATOMS_AND_TWO_TUPLES flags; -- Metadata stored in RAM for speed
) PRIMARY KEY key;</pre><p>Hibariのテーブル名は、Erlangのデータ型では「アトム」になります。キーに関連するすべての属性の型は、次の表のとおりです。</p><div class="informaltable"><table cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"> Attribute Name </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"> Erlang data type </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"> Storage Location </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>Key</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>binary</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>RAM</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>A binary blob of any size, though due to RAM storage the key should be small enough for all keys to fit in RAM.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>Value</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>binary</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>RAM or disk</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>A binary blob of any size, though practical constraints limit value blobs to 16MB or so.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>Timestamp</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>integer</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>RAM</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>A monotonically increasing counter, usually (but not always) based on the client’s wall-clock time.  Updating a key with a timestamp smaller than the key’s current timestamp is not permitted.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>Expiration Time</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>integer</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>RAM</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>A UNIX <code class="literal">time_t</code> representing the expiration time for a key.  A value of 0 means no expiration, and no RAM overhead is required.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="center" valign="top"><p>Flags</p></td><td style="border-right: 1px solid #527bbd; " align="center" valign="top"><p>list</p></td><td style="border-right: 1px solid #527bbd; " align="center" valign="top"><p>RAM</p></td><td style="" align="left" valign="top"><p>This attribute cannot be represented in plain SQL.  It is a list of atoms and/or {atom(), term()} pairs.  Heavy use of this attribute is discouraged due to RAM-based storage.</p></td></tr></tbody></table></div><p>ストレージがRAMの場合、通常のクエリー処理では、RAM上のコピーでデータを検索します。キーの属性を更新する場合は、クラスター全体の電源障害が発生した場合のデータの損失を防ぐために、どんな場合でも更新前に先行ログに書き込まれます。詳細については、???を参照してください。</p><p>ストレージがディスクの場合、属性の値はRAMには保管されていません。RAM内のメタデータは属性の場所として、ファイル番号、バイトオフセット値、およびバイト長に対するポインターを保持します。属性を検索するには、共通ログ内のログ・シーケンス・ファイルをオープンし、 <code class="literal">lseek(2)</code> をコールしてから、 <code class="literal">read(2)</code> をコールします。</p><p>最善のケース</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
対象データがすべてOSのページ・キャッシュ内にあるため、ディスクからキーのバリューBLOBを読み出す際に、ディスクのシークを必要としません。
</dd></dl></div><p>通常のケース</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
ファイルのinode情報はキャッシュにありますが、必要なファイル・ページがキャッシュにないため、シークと読み出しが1回だけ必要になります。
</dd></dl></div><p>最悪のケース</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
ファイルシステムは、中間ディレクトリ・データ、inode、inode内の間接ストレージ・ブロック・データを読み込むために、シークと読み出しをさらに実施する必要があります。
</dd></dl></div><p>バリューBLOBのサイズの現実的な上限値は、BLOB全体のサイズと、大きいサイズのBLOBのアクセス頻度によって異なります。たとえば、64MBのバリューBLOBをたまに保管する場合と、常に64MBのバリューBLOBを100％の負荷で書き込む場合とでは、話が違います。HibariのAPIを用いて更新またはフェッチを実行する場合は、バリューBLOB全体を対象とする以外の方法はありません。したがって極端な場合、4GBの単一BLOBを対象に操作を実行しようとすると、ブリックが何秒間もブロックされることがあります。さらに、大きいサイズのBLOBの処理中は、 <code class="literal">busy_dist_port</code> イベントが他のプロセスをブロックすることもあります。</p></div></div><div class="section" title="3.2. brick_simple:add/6"><div class="titlepage"><div><div><h3 class="title"><a id="brick-simple-add"></a>3.2. brick_simple:add/6</h3></div></div></div><p>書式</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
<span class="strong"><strong>brick_simple:add(Tab, Key, Value, ExpTime, Flags, Timeout).</strong></span>
</dd></dl></div><p>解説</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
テーブルTabにキーKeyがまだ存在していない場合、キー <code class="literal">Key</code> とバリュー <code class="literal">Value</code> のペアを追加します。さらにオプションでフラグFlagsも追加できます。キー <code class="literal">Key</code> が既に存在している場合、操作は失敗します。
</dd></dl></div><p>引数</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Tab</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
キーとバリューのペアを追加するテーブルの名前
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Tab = table()</code>
</li><li class="listitem">
<code class="literal">table() = atom()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Key</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
バリューとペアになり、テーブルに追加されるキー
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Key = key()</code>
</li><li class="listitem">
<code class="literal">key() = iodata()</code>
</li><li class="listitem">
<code class="literal">iodata() = iolist() | binary()</code>
</li><li class="listitem"><p class="simpara">
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</p><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Keyはiolist()またはbinary()で指定できますが、操作の実行前にBinary型に変換されます。これは、Valueに関しても同様です。</p></td></tr></table></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Value</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
キーのペアとなるバリュー
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型:
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Value = val()</code>
</li><li class="listitem">
<code class="literal">val() = iodata()</code>
</li><li class="listitem">
<code class="literal">iodata() = iolist() | binary()</code>
</li><li class="listitem">
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>ExpTime</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
キーの有効期限。UNIXのtime_t()で表現されます。
</li><li class="listitem">
任意：デフォルト値は0（有効期限なし）
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">ExpTime = exp_time()</code>
</li><li class="listitem">
<code class="literal">exp_time() = time_t()</code>
</li><li class="listitem">
<code class="literal">time_t() = integer()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Flags</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">add</code> 操作に適用する操作フラグのリスト、および（または）データベース中のキーとバリューのペアに関連付けるカスタム特性フラグのリスト。RAMベースのストレージを使用するため、カスタム特性フラグの多用はお勧めできません。
</li><li class="listitem">
任意：デフォルト値は空リスト
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Flags = flags_list()</code>
</li><li class="listitem">
<code class="literal">flags_list() = [do_op_flag() | property()]</code>
</li><li class="listitem">
<code class="literal">do_op_flag() = 'value_in_ram'</code>
</li><li class="listitem">
<code class="literal">property() = atom() | {term(), term()}</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
操作フラグの使用方法
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
<code class="literal">'value_in_ram'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p class="simpara">
ブリックのデフォルトのストレージの場所にオーバーライドして、バリューBLOBをRAMに保管します。
</p><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Gemini社の品質管理部門は、このフラグのテストを完全には終了していません。</p></td></tr></table></div></li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Timeout</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
操作のタイムアウト時間（単位はミリ秒）
</li><li class="listitem">
任意：デフォルト値は15,000（ミリ秒）
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Timeout = timeout()</code>
</li><li class="listitem">
<code class="literal">timeout() = integer() | 'infinity'</code>
</li></ul></div></li></ul></div></dd></dl></div><p>戻り値</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
正常終了の場合
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">'ok'</code>
</li></ul></div></dd></dl></div><p>エラー終了の場合</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
<code class="literal">{'key_exists',timestamp()}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
キーが既に存在しているため、操作が失敗しました。
</li><li class="listitem">
<code class="literal">timestamp() = integer()</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'invalid_flag_present'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
Flags引数に無効な <code class="literal">?do_op_flag()</code>  が検出されたため、操作が失敗しました。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'brick_not_available'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
該当キーに相当するチェインの現在の長さがゼロのため利用できないので、操作が失敗しました。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{{'nodedown',node()},{'gen_server','call',term()}}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
要求を処理するサーバーのブリックに障害が発生した、あるいはクライアントとサーバー間のネットワークのパーティションが発生したため、操作が失敗しました。Adminサーバーが障害を検知してチェインの復旧処置を実施することを考慮して、少し時間をおいた後にクライアントから要求を再送してください。
</li><li class="listitem">
<code class="literal">node() = atom()</code>
</li></ul></div></li></ul></div><p>エイリアス</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
brick_simple:add/3
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">brick_simple:add(Tab, Key, Value).</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
brick_simple:add/4
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">brick_simple:add(Tab, Key, Value, Flags).</code>
</li><li class="listitem">
<code class="literal">brick_simple:add(Tab, Key, Value, Timeout).</code>
</li></ul></div></li></ul></div></dd></dl></div><p>例</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
新しいキーとバリューのペアの追加に成功した場合
</p><pre class="screen">&gt; brick_simple:add(tab1, &lt;&lt;"foo"&gt;&gt;, &lt;&lt;"Hello, world!"&gt;&gt;).
ok</pre></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
追加しようとして、キーが既に存在しているため失敗した場合
</p><pre class="screen">&gt; brick_simple:add(tab1, &lt;&lt;"foo"&gt;&gt;, &lt;&lt;"Goodbye, world!"&gt;&gt;).
{key_exists,1271542959131192}</pre></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
ブリックのデフォルトのストレージ設定にかかわらず、バリューをRAMに保管するように指定して、新しいキーとバリューのペアの追加に成功した場合
</p><pre class="screen">&gt; brick_simple:add(tab1, "foo2", "this is value2", 20000).
ok</pre></dd></dl></div></div><div class="section" title="3.3. brick_simple:replace/6"><div class="titlepage"><div><div><h3 class="title"><a id="brick-simple-replace"></a>3.3. brick_simple:replace/6</h3></div></div></div><p>書式</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
<span class="strong"><strong>brick_simple:replace(Tab, Key, Value, ExpTime, Flags, Timeout).</strong></span>
</dd></dl></div><p>解説</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
テーブル<code class="literal">Tab</code> にキー <code class="literal">Key</code> が既に存在している場合に、キー <code class="literal">Key</code> とバリュー <code class="literal">Value</code> のペアを更新します。さらにオプションでフラグ <code class="literal">Flags</code> も更新します。キー <code class="literal">Key</code> が存在しない場合、操作は失敗します。
</dd></dl></div><p>引数</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Tab</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
キーとバリューのペアを更新するテーブルの名前
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Tab = table()</code>
</li><li class="listitem">
<code class="literal">table() = atom()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Key</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
新たにバリューとペアになって、テーブルを更新するキー
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Key = key()</code>
</li><li class="listitem">
<code class="literal">key() = iodata()</code>
</li><li class="listitem">
<code class="literal">iodata() = iolist() | binary()</code>
</li><li class="listitem"><p class="simpara">
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</p><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p><code class="literal">Key</code> は<code class="literal">iolist()</code> または<code class="literal">binary()</code> で指定できますが、操作の実行前にBinary型に変換されます。これは、<code class="literal">Value</code> に関しても同様です。</p></td></tr></table></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Value</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
キーのペアとなる新しいバリュー
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Value = val()</code>
</li><li class="listitem">
<code class="literal">val() = iodata()</code>
</li><li class="listitem">
<code class="literal">iodata() = iolist() | binary()</code>
</li><li class="listitem">
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>ExpTime</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
キーの有効期限。UNIXのtime_t()で表現されます。
</li><li class="listitem">
任意：デフォルト値は0（有効期限なし）
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">ExpTime = exp_time()</code>
</li><li class="listitem">
<code class="literal">exp_time() = time_t()</code>
</li><li class="listitem">
<code class="literal">time_t() = integer()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Flags</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">replace</code> 操作に適用する操作フラグのリスト、および（または）データベース中のキーとバリューのペアに関連付けるカスタム特性フラグのリスト。RAMベースのストレージを使用するので、カスタム特性フラグの多用はお勧めできません。
</li><li class="listitem">
任意：デフォルト値は空リスト
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Flags = flags_list()</code>
</li><li class="listitem">
<code class="literal">flags_list() = [do_op_flag() | property()]</code>
</li><li class="listitem">
<code class="literal">do_op_flag() = {'testset', timestamp()} |'value_in_ram'</code>
</li><li class="listitem">
<code class="literal">timestamp() = integer()</code>
</li><li class="listitem">
<code class="literal">property() = atom() | {term(), term()}</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
操作フラグの使用方法
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
<code class="literal">{'testset', timestamp()}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
既存のキーのタイムスタンプが<code class="literal">timestamp()</code> と正確に一致しない場合、操作は失敗します。
<a class="ulink" href="#brick-simple-do" target="_top">マイクロ・トランザクション</a>の中で使用するときは、キーのタイムスタンプが<code class="literal">timestamp()</code> と正確に一致しない場合、トランザクションは終了します。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'value_in_ram'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p class="simpara">
ブリックのデフォルトのストレージの場所指定を無効にして、バリューBLOBをRAMに保管します。
</p><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Gemini社の品質管理部門は、このフラグのテストを完全には終了していません。</p></td></tr></table></div></li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Timeout</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
操作のタイムアウト時間（単位はミリ秒）
</li><li class="listitem">
任意：省略値は15,000（ミリ秒）
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Timeout = timeout()</code>
</li><li class="listitem">
<code class="literal">timeout() = integer() | 'infinity'</code>
</li></ul></div></li></ul></div></dd></dl></div><p>戻り値</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
正常終了の場合
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">'ok'</code>
</li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
エラー終了の場合
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
<code class="literal">'key_not_exist'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
キーが存在しないため、操作が失敗しました。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{'ts_error', timestamp()}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">{'testset', timestamp()}</code> フラグが使用され、タイムスタンプが一致しないため、操作が失敗しました。戻り値の <code class="literal">timestamp()</code> は、該当のキーの現在のタイムスタンプの値です。
</li><li class="listitem">
<code class="literal">timestamp() = integer()</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'invalid_flag_present'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Flags</code> 引数に無効な <code class="literal">do_op_flag()</code> が検出されたため、操作が失敗しました。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'brick_not_available'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
該当キーに相当するチェインの最新の長さがゼロで利用できないため、操作が失敗しました。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{{'nodedown',node()},{'gen_server','call',term()}}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
要求を処理するサーバーのブリックに障害が発生した、あるいはクライアントとサーバー間のネットワークにパーティションが発生したため、操作が失敗しました。Adminサーバーが障害を検知してチェインの復旧処置を実施することを考慮して、少し時間をおいた後にクライアントから要求を再送してください。
</li><li class="listitem">
<code class="literal">node() = atom()</code>
</li></ul></div></li></ul></div></dd></dl></div><p>エイリアス</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
brick_simple:replace/3
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">brick_simple:replace(Tab, Key, Value).</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
brick_simple:replace/4
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">brick_simple:replace(Tab, Key, Value, Flags).</code>
</li><li class="listitem">
<code class="literal">brick_simple:replace(Tab, Key, Value, Timeout).</code>
</li></ul></div></li></ul></div></dd></dl></div><p>例</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
キーとバリューのペアの更新に成功した場合
</p><pre class="screen">&gt; brick_simple:replace(tab1, &lt;&lt;"foo"&gt;&gt;, &lt;&lt;"Goodbye, world!"&gt;&gt;).
ok</pre></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
更新しようとして、キーが存在しないために失敗した場合
</p><pre class="screen">&gt; brick_simple:replace(tab1, &lt;&lt;"key3"&gt;&gt;, &lt;&lt;"new and improved value"&gt;&gt;).
key_not_exist</pre></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
ブリックのデフォルトのストレージ設定に関わらず、バリューをRAMに保管することを指定して、キーとバリューのペアの更新に成功した場合
</p><pre class="screen">&gt; brick_simple:replace(tab1, "foo", "You again, world!", ['value_in_ram']).
ok</pre></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
キーを更新しようとして、現在のタイムスタンプの指定が正しくなかったために失敗した場合
</p><pre class="screen">&gt; brick_simple:replace(tab1, "foo", "Whole new value", [{'testset', 12345}]).
{ts_error,1271543165272987}</pre></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
現在のタイムスタンプを正しく指定して、キーとバリューのペアの更新に成功した場合
</p><pre class="screen">&gt; brick_simple:replace(tab1, "foo", "Whole new value", [{'testset', 1271543165272987}]).
ok</pre></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
デフォルトではない操作のタイムアウト時間を指定して、キーとバリューのペアの更新に成功た場合
</p><pre class="screen">&gt; brick_simple:replace(tab1, "foo", "Foo again?", 30000).
ok</pre></dd></dl></div></div><div class="section" title="3.4. brick_simple:set/6"><div class="titlepage"><div><div><h3 class="title"><a id="brick-simple-set"></a>3.4. brick_simple:set/6</h3></div></div></div><p>書式</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
<span class="strong"><strong>brick_simple:set(Tab, Key, Value, ExpTime, Flags, Timeout).</strong></span>
</dd></dl></div><p>解説</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
テーブル<code class="literal">Tab</code> にキー <code class="literal">Key</code> が既に存在しているかどうかに関わらず、キー <code class="literal">Key</code> とバリュー <code class="literal">Value</code> のペアをテーブル <code class="literal">Tab</code> に設定します。さらにオプションで、フラグ <code class="literal">Flags</code> もテーブル <code class="literal">Tab</code> に設定します。
</dd></dl></div><p>引数</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Tab</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
キーとバリューのペアを設定するテーブルの名前
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Tab = table()</code>
</li><li class="listitem">
<code class="literal">table() = atom()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Key</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
バリューとペアにしてテーブルに設定するキー
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Key = key()</code>
</li><li class="listitem">
<code class="literal">key() = iodata()</code>
</li><li class="listitem">
<code class="literal">iodata() = iolist() | binary()</code>
</li><li class="listitem"><p class="simpara">
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</p><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p><code class="literal">Key</code> は、 <code class="literal">iolist()</code> または<code class="literal">binary()</code> で指定することもできますが、操作の実行前にBinary型に変換されます。これは、<code class="literal">Value</code> に関しても同様です。</p></td></tr></table></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Value</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
キーとペアになるバリュー
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Value = val()</code>
</li><li class="listitem">
<code class="literal">val() = iodata()</code>
</li><li class="listitem">
<code class="literal">iodata() = iolist() | binary()</code>
</li><li class="listitem">
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>ExpTime</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
キーの有効期限。UNIXのtime_t()で表現されます。
</li><li class="listitem">
任意：省略値は0（有効期限なし）
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">ExpTime = exp_time()</code>
</li><li class="listitem">
<code class="literal">exp_time() = time_t()</code>
</li><li class="listitem">
<code class="literal">time_t() = integer()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Flags</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">set</code> 操作に適用される操作フラグ、および（または）データベース中のキーとバリューのペアに関連付けるカスタム特性フラグのリスト。RAMベースのストレージを使用するので、カスタム特性フラグの多用はお勧めできません。
</li><li class="listitem">
任意：省略値は空リスト
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Flags = flags_list()</code>
</li><li class="listitem">
<code class="literal">flags_list() = [do_op_flag() | property()]</code>
</li><li class="listitem">
<code class="literal">do_op_flag() = {'testset', timestamp()} |'value_in_ram'</code>
</li><li class="listitem">
<code class="literal">timestamp() = integer()</code>
</li><li class="listitem">
<code class="literal">property() = atom() | {term(), term()}</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
操作フラグの使用方法
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
<code class="literal">{'testset', timestamp()}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
現在のキーのタイムスタンプが <code class="literal">?timestamp()</code> と正確に一致しない場合、操作は失敗します。
<a class="ulink" href="#brick-simple-do" target="_top">マイクロ・トランザクション</a>の中で使用すると、キーのタイムスタンプが <code class="literal">timestamp()</code> と正確に一致しない場合、トランザクションは終了します。このフラグを <code class="literal">set</code> で用いると、キーが存在しない場合やキーが存在してもタイムスタンプが一致しない場合、エラーとなります。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'value_in_ram'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p class="simpara">
ブリックのデフォルトのストレージの場所にオーバーライドして、バリューBLOBをRAMに保管します。
</p><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Gemini社の品質管理部門は、このフラグのテストを完全には終了していません。</p></td></tr></table></div></li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Timeout</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
操作のタイムアウト時間（単位はミリ秒）
</li><li class="listitem">
任意：省略値は15,000（ミリ秒）
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Timeout = timeout()</code>
</li><li class="listitem">
<code class="literal">timeout() = integer() | 'infinity'</code>
</li></ul></div></li></ul></div></dd></dl></div><p>戻り値</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
正常終了の場合
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">'ok'</code>
</li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
エラー終了の場合
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
<code class="literal">'key_not_exist'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">{'testset', timestamp()}</code> フラグが使用され、キーが存在しないため、操作が失敗しました。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{'ts_error', timestamp()}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">{'testset', timestamp()}</code> フラグが使用され、タイムスタンプが一致しないため、操作が失敗しました。戻り値の <code class="literal">timestamp()</code> は、既存のキーの現在のタイムスタンプの値です。
</li><li class="listitem">
<code class="literal">timestamp() = integer()</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'invalid_flag_present'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
Flags引数に無効な <code class="literal">do_op_flag()</code> が検出されたため、操作が失敗しました。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'brick_not_available'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
該当キーに相当するチェインの現在の長さがゼロで利用できないため、操作が失敗しました。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{{'nodedown',node()},{'gen_server','call',term()}}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
要求を処理するサーバーのブリックに障害が発生した、あるいはクライアントとサーバー間のネットワークにパーティションが発生したため、操作が失敗しました。Adminサーバーが障害を検知してチェインの復旧処置を実施することを考慮して、少し時間をおいた後にクライアントから要求を再送してください。
</li><li class="listitem">
<code class="literal">node() = atom()</code>
</li></ul></div></li></ul></div></dd></dl></div><p>エイリアス</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
brick_simple:set/3
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">brick_simple:set(Tab, Key, Value).</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
brick_simple:set/4
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">brick_simple:set(Tab, Key, Value, Flags).</code>
</li><li class="listitem">
<code class="literal">brick_simple:set(Tab, Key, Value, Timeout).</code>
</li></ul></div></li></ul></div></dd></dl></div><p>例</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
キーとバリューのペアの設定に成功した場合
</p><pre class="screen">&gt; brick_simple:set(tab1, &lt;&lt;"key4"&gt;&gt;, &lt;&lt;"cool value"&gt;&gt;).
ok</pre></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
ブリックのデフォルトのストレージ設定に関わらず、バリューをRAMに保管することを指定して、キーとバリューのペアの設定に成功した場合
</p><pre class="screen">&gt; brick_simple:set(tab1, "goo", "value6", ['value_in_ram']).
ok</pre></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
キーとバリューのペアを設定しようとして<code class="literal">testset</code> フラグを指定したにもかかわらず、キーが存在しないために失敗した場合
</p><pre class="screen">&gt; brick_simple:set(tab1, "boo", "hoo", [{'testset', 1271543165272987}]).
key_not_exist</pre></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<code class="literal">testset</code> フラグを指定し、かつ既存のキーのタイムスタンプが指定したタイムスタンプと一致したため、キーとバリューのペアの設定に成功した場合
</p><pre class="screen">&gt; brick_simple:set(tab1, "goo", "value7", [{'testset', 1271543165272432}]).
ok</pre></dd></dl></div></div><div class="section" title="3.5. brick_simple:get/4"><div class="titlepage"><div><div><h3 class="title"><a id="brick-simple-get"></a>3.5. brick_simple:get/4</h3></div></div></div><p>書式
 ::
<span class="strong"><strong>brick_simple:get(Tab, Key, Flags, Timeout).</strong></span></p><p>解説</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
テーブル<code class="literal">Tab</code> から、キー <code class="literal">Key</code> とフラグ<code class="literal">Flags</code> で指定したキーの属性を検索します。
</dd></dl></div><p>引数</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Tab</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
キーを検索するテーブルの名前
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Tab = table()</code>
</li><li class="listitem">
<code class="literal">table() = atom()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Key</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
テーブルから検索したいキー
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Key = key()</code>
</li><li class="listitem">
<code class="literal">key() = iodata()</code>
</li><li class="listitem">
<code class="literal">iodata() = iolist() | binary()</code>
</li><li class="listitem"><p class="simpara">
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</p><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p><code class="literal">Key</code> を<code class="literal">iolist()</code> または<code class="literal">binary()</code> で指定することもできますが、操作の実行前にBinary型に変換されます。</p></td></tr></table></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Flags</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">get</code> 操作に適用される操作フラグのリスト
</li><li class="listitem">
任意：デフォルト値は空リスト
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Flags = flags_list()</code>
</li><li class="listitem">
<code class="literal">flags_list() = [do_op_flag()]</code>
</li><li class="listitem">
<code class="literal">do_op_flag() = 'get_all_attribs' | 'witness' | {'testset',
    timestamp()} | 'must_exist' | 'must_not_exist'</code>
</li><li class="listitem">
<code class="literal">timestamp() = integer()</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
操作フラグの使用方法
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
<code class="literal">'get_all_attribs'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
キーのすべての属性を返します。<code class="literal">witness</code> フラグと組み合わせて使用できます。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'witness'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
検索結果のバリューBLOBを返しません。このフラグを指定すると、ブリックが要求に対応するためにディスクにアクセスする必要がないことを保証できます。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{'testset', timestamp()}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
キーのタイムスタンプが<code class="literal">timestamp()</code> と正確に一致しない場合、操作は失敗します。
<a class="ulink" href="#brick-simple-do" target="_top">マイクロ・トランザクション</a>の中で使用すると、キーのタイムスタンプが<code class="literal">timestamp()</code> と正確に一致しない場合、トランザクションは終了します。このフラグは、<code class="literal">must_exist</code> と<code class="literal">must_not_exist</code> の両フラグに優先します。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'must_not_exist'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
<a class="ulink" href="#brick-simple-do" target="_top">マイクロ・トランザクション</a>の中で使用すると、キーが存在しない場合にトランザクションが終了します。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'must_not_exist'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
<a class="ulink" href="#brick-simple-do" target="_top">マイクロ・トランザクション</a>の中で使用すると、キーが存在する場合、トランザクションが終了します。このフラグは、クライアント・アプリケーションにとって2個以上のキーの間の関係が重要な場合に便利です。
</li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Timeout</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
操作のタイムアウト時間（単位はミリ秒）
</li><li class="listitem">
任意：省略値は15,000（ミリ秒）
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Timeout = timeout()</code>
</li><li class="listitem">
<code class="literal">timeout() = integer() | 'infinity'</code>
</li></ul></div></li></ul></div></dd></dl></div><p>戻り値</p><p>正常終了の場合</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
<code class="literal">{'ok', timestamp(), val()}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">witness</code> フラグも <code class="literal">get_all_attribs</code> フラグも、どちらも指定していない <code class="literal">get</code> 要求が成功しました。
</li><li class="listitem">
<code class="literal">timestamp() = integer()</code>
</li><li class="listitem">
<code class="literal">val() = iodata()</code>
</li><li class="listitem">
<code class="literal">iodata() = iolist() | binary()</code>
</li><li class="listitem">
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{'ok', timestamp()}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">witness</code> フラグを指定して、<code class="literal">get_all_attribs</code> フラグは指定していない<code class="literal">get</code> 要求が成功しました。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{'ok', timestamp(), proplist()}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">witness</code> フラグも<code class="literal">get_all_attribs</code> フラグもともに指定した<code class="literal">get</code> 要求が成功しました。
</li><li class="listitem">
<code class="literal">proplist() = [property()]</code>
</li><li class="listitem">
<code class="literal">property() = atom() | {term(), term()}</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{'ok', timestamp(), val(), exp_time(), proplist()}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">get_all_attribs</code> フラグを指定して、<code class="literal">witness</code> フラグは指定していない<code class="literal">get</code> 要求が成功しました。
</li><li class="listitem"><p class="simpara">
<code class="literal">exp_time() = time_t()</code>
</p><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p><code class="literal">proplist()</code> が返される場合、リスト中の特性のひとつは常に<code class="literal">{val_len,Size::integer()}</code> となります。ここで<code class="literal">Size</code> は、バリューBLOBのバイト数を表します。</p></td></tr></table></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
エラー終了の場合
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
<code class="literal">'key_not_exist'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
キーが存在しないため、操作が失敗しました。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{'ts_error', timestamp()}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">{'testset', timestamp()}</code> フラグを使用して、タイムスタンプが一致しないため、操作が失敗しました。戻り値の<code class="literal">timestamp()</code> は、既存のキーの現在のタイムスタンプの値です。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'invalid_flag_present'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
Flags引数に無効な <code class="literal">do_op_flag()</code> が検出されたため、操作が失敗しました。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'brick_not_available'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
該当キーに相当するチェインの現在の長さがゼロで利用できないため、操作が失敗しました。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{{'nodedown',node()},{'gen_server','call',term()}}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
要求を処理するサーバーのブリックに障害が発生した、あるいはクライアントとサーバー間のネットワークにパーティションが発生したため、操作が失敗しました。Adminサーバーが障害を検知してチェインの復旧処置を実施することを考慮して、少し時間をおいた後にクライアントから要求を再信してください。
</li><li class="listitem">
<code class="literal">node() = atom()</code>
</li></ul></div></li></ul></div></dd></dl></div><p>エイリアス</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
brick_simple:get/2
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">brick_simple:get(Tab, Key).</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
brick_simple:get/3
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">brick_simple:get(Tab, Key, Flags).</code>
</li><li class="listitem">
<code class="literal">brick_simple:get(Tab, Key, Timeout).</code>
</li></ul></div></li></ul></div></dd></dl></div><p>例</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
キーとバリューのペアの検索に成功した場合
</p><pre class="screen">&gt; brick_simple:get(tab1, "goo").
{ok,1271543165272432,&lt;&lt;"value7"&gt;&gt;}</pre></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
バリューBLOBなしでキーの検索に成功した場合
</p><pre class="screen">&gt; brick_simple:get(tab1, "goo", ['witness']).
{ok,1271543165272432}</pre></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
キーが存在しないため、検索に失敗した場合
</p><pre class="screen">&gt; brick_simple:get(tab1, "moo").
key_not_exist</pre></dd></dl></div></div><div class="section" title="3.6. brick_simple:get_many/5"><div class="titlepage"><div><div><h3 class="title"><a id="brick-simple-get-many"></a>3.6. brick_simple:get_many/5</h3></div></div></div><p>書式</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
<span class="strong"><strong>brick_simple:get_many(Tab, Key, MaxNum, Flags, Timeout).</strong></span>
</dd></dl></div><p>解説</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
テーブル<code class="literal">Tab</code> の単一チェインから、複数キーを検索します。引数<code class="literal">Key</code> で指定したキーの検索後、その次のキーから開始して、最大数<code class="literal">MaxNum</code> に達するまで検索を続け、辞書のように昇順で並べてキーを返します。戻り値のリストには、戻り値の最後のキーの後に続きがあるかどうかを示すブール値が付いてきます。
</p><div class="important" title="&#x91CD;&#x8981;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x91CD;&#x8981;]" src="images/icons/important.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p><code class="literal">get_many()</code> 関数を1回コールしただけでは、複数のストレージ・チェインをまたがってキーを検索することはできません。<code class="literal">Key</code> のコンシステント・ハッシュは、<code class="literal">get_many</code> 命令を単一チェインのテイル・ブリックに送り、その後は、その単一チェインからのみ、すべてのキーを検索します。</p></td></tr></table></div><p class="simpara">引数</p></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Tab</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
複数キーを検索するテーブルの名前
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Tab = table()</code>
</li><li class="listitem">
<code class="literal">table() = atom()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Key</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">get_many</code> の検索を開始するキー。指定した<code class="literal">Key</code> の検索後、その次のキーから開始して、辞書のように昇順で検索を続けます。
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Key = key()</code>
</li><li class="listitem">
<code class="literal">key() = iodata()</code>
</li><li class="listitem">
<code class="literal">iodata() = iolist() | binary()</code>
</li><li class="listitem"><p class="simpara">
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</p><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p><code class="literal">Key</code> を<code class="literal">iolist()</code> または<code class="literal">binary()</code> で指定することもできますが、操作の実行前にBinary型に変換されます。</p></td></tr></table></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>MaxNum</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
返すキーの数の最大値
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">MaxNum = integer()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Flags</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">get_many</code> 操作に適用される操作フラグのリスト
</li><li class="listitem">
任意：デフォルト値は空リスト
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Flags = flags_list()</code>
</li><li class="listitem">
<code class="literal">flags_list() = [do_op_flag()]</code>
</li><li class="listitem">
<code class="literal">do_op_flag() = 'get_all_attribs' | 'witness' | {'binary_prefix',
    binary()} | {'max_bytes', integer()}</code> | <code class="literal">{'max_num', integer()}</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
操作フラグの使用方法
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
<code class="literal">'get_all_attribs'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
各キーのすべての属性を返します。<code class="literal">witness</code> フラグと組み合わせて使用できます。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'witness'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
検索結果としてバリューBLOBを返しません。このフラグを指定すると、ブリックが要求に対応するためにディスクにアクセスする必要がないことを保証できます。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{'binary_prefix', binary()}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
<code class="literal">binary()</code> と正確に一致するバイナリ値のプレフィクスを持つキーのみを返します。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{'max_bytes', integer()}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
対応するバリューBLOBのサイズの合計が <code class="literal">integer()</code> バイトを超えない範囲のキーだけを返します。クライアントからの要求にこのフラグが明示的に指定されていない場合のデフォルト値は、2GBです。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{'max_num', integer()}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
返すキーの数の最大値（デフォルト値は10）です。このフラグの目的は、MaxNum引数と同じであることに注意してください。
</li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Timeout</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
操作のタイムアウト時間（単位はミリ秒）
</li><li class="listitem">
任意：省略値は15,000（ミリ秒）
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Timeout = timeout()</code>
</li><li class="listitem">
<code class="literal">timeout() = integer() | 'infinity'</code>
</li></ul></div></li></ul></div></dd></dl></div><p>戻り値</p><p>正常終了の場合</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
<code class="literal">{ok, {[{key(), timestamp(), val()}], boolean()}}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">witness</code> フラグも<code class="literal">get_all_attribs</code> フラグもどちらも指定していない<code class="literal">get_many</code> 要求が成功しました。
</li><li class="listitem">
<code class="literal">timestamp() = integer()</code>
</li><li class="listitem">
<code class="literal">val() = iodata()</code>
</li><li class="listitem">
<code class="literal">iodata() = iolist() | binary()</code>
</li><li class="listitem">
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{ok, {[{key(), timestamp()}], boolean()}}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">witness</code> フラグを指定し、<code class="literal">get_all_attribs</code> フラグは指定していない<code class="literal">get_many</code> 要求が成功しました。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{ok, {[{key(), timestamp(), proplist()}], boolean()}}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">witness</code> フラグも<code class="literal">get_all_attribs</code> フラグもともに指定した<code class="literal">get_many</code> 要求が成功しました。
</li><li class="listitem">
<code class="literal">proplist() = [property()]</code>
</li><li class="listitem">
<code class="literal">property() = atom() | {term(), term()}</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{ok, {[{key(), timestamp(), val(), exp_time(), proplist()}], boolean()}}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">get_all_attribs</code> フラグを指定し、<code class="literal">witness</code> フラグは指定していない<code class="literal">get_many</code> 要求が成功しました。
</li><li class="listitem"><p class="simpara">
<code class="literal">exp_time() = time_t()</code>
</p><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>正常終了の戻り値の最後のブール値は、戻り値の最後のキーの後にチェイン内にまだキーが存在するかどうかを示します。存在する場合は真（<code class="literal">true</code> ）、存在しない場合は偽（<code class="literal">false</code> ）となります。<code class="literal">proplist()</code> が返される場合、リスト中の特性のひとつは常に<code class="literal">{val_len,Size::integer()}</code> となります。ここで<code class="literal">Size</code> は、バリューBLOBのバイト数を表します。</p></td></tr></table></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
エラー終了の場合
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
<code class="literal">'invalid_flag_present'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Flags</code> 引数に無効な <code class="literal">do_op_flag()</code> が検出されたため、操作が失敗しました。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'brick_not_available'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
該当キーに相当するチェインの現在の長さがゼロで利用できないため、操作が失敗しました。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{{'nodedown',node()},{'gen_server','call',term()}}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
要求を処理するサーバーのブリックに障害が発生した、あるいはクライアントとサーバー間のネットワークにパーティションが発生したため、操作が失敗しました。Adminサーバーが障害を検知してチェインの復旧処置を実施することを考慮して、少し時間をおいた後にクライアントから要求を再送してください。
</li><li class="listitem">
<code class="literal">node() = atom()</code>
</li></ul></div></li></ul></div></dd></dl></div><p>エイリアス</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
brick_simple:get_many/3
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">brick_simple:get_many(Tab, Key, MaxNum).</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
brick_simple:get_many/4
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">brick_simple:get_many(Tab, Key, MaxNum, Flags).</code>
</li><li class="listitem">
<code class="literal">brick_simple:get_many(Tab, Key, MaxNum, Timeout).</code>
</li></ul></div></li></ul></div></dd></dl></div><p>例</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
現在、キーが2個しかないテーブルから、すべてのキーの検索に成功した場合（ブール値の<code class="literal">false</code> は、キー <code class="literal">foo</code> に後続のキーが存在しないことを示します）
</p><pre class="screen">&gt; brick_simple:get_many(tab1, "", 5).
{ok,{[{&lt;&lt;"another"&gt;&gt;,1271543102911775,&lt;&lt;"yes!"&gt;&gt;},
      {&lt;&lt;"foo"&gt;&gt;,1271543165272987,&lt;&lt;"Foo again?"&gt;&gt;}],
     false}}</pre></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<code class="literal">witness</code> フラグを指定して、現在キーが2個しかないテーブルから、すべてのキーの検索に成功した場合
</p><pre class="screen">&gt; brick_simple:get_many(tab1, "", 5, ['witness']).
{ok,{[{&lt;&lt;"another"&gt;&gt;,1271543102911775},
      {&lt;&lt;"foo"&gt;&gt;,1271543165272987}],
     false}}</pre></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<code class="literal">get_all_attribs</code> フラグを指定して、現在キーが2個しかないテーブルから、すべてのキーの検索に成功した場合
</p><pre class="screen">&gt; brick_simple:get_many(tab1, "", 5).
{ok,{[{&lt;&lt;"another"&gt;&gt;,1271543102911775,&lt;&lt;"yes!"&gt;&gt;,0,
       [{val_len,4}]},
      {&lt;&lt;"foo"&gt;&gt;,1271543165272987,&lt;&lt;"Foo again?"&gt;&gt;,0,[{val_len,6}]}],
     false}}</pre></dd></dl></div></div><div class="section" title="3.7. brick_simple:delete/4"><div class="titlepage"><div><div><h3 class="title"><a id="brick-simple-delete"></a>3.7. brick_simple:delete/4</h3></div></div></div><p>書式</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
<span class="strong"><strong>brick_simple:delete(Tab, Key, Flags, Timeout).</strong></span>
</dd></dl></div><p>解説</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
テーブル <code class="literal">Tab</code> から、キー <code class="literal">Key</code> を削除します。
</dd></dl></div><p>引数</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Tab</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
キーと、そのペアとなるバリューを削除するテーブルの名前
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Tab = table()</code>
</li><li class="listitem">
<code class="literal">table() = atom()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Key</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
テーブルから削除するキー
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Key = key()</code>
</li><li class="listitem">
<code class="literal">key() = iodata()</code>
</li><li class="listitem">
<code class="literal">iodata() = iolist() | binary()</code>
</li><li class="listitem"><p class="simpara">
<code class="literal">iolist()  = [char() | binary() | iolist()]</code>
</p><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p><code class="literal">Key</code> を <code class="literal">iolist()</code> または<code class="literal">binary()</code> で指定することもできますが、操作の実行前にBinary型に変換されます。</p></td></tr></table></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Flags</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">delete</code> 操作に適用される操作フラグのリスト
</li><li class="listitem">
任意：デフォルト値は空リスト
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Flags = flags_list()</code>
</li><li class="listitem">
<code class="literal">flags_list() = [do_op_flag()]</code>
</li><li class="listitem">
<code class="literal">do_op_flag() = {'testset', timestamp()} |'must_exist' | 'must_not_exist'</code>
</li><li class="listitem">
<code class="literal">timestamp() = integer()</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
操作フラグの使用方法
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
<code class="literal">{'testset', timestamp()}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
キーのタイムスタンプが<code class="literal">timestamp()</code> と正確に一致しない場合、操作は失敗します。
<a class="ulink" href="#brick-simple-do" target="_top">マイクロ・トランザクション</a>の中で使用すると、キーのタイムスタンプが<code class="literal">timestamp()</code> と正確に一致しない場合にトランザクションが終了します。このフラグは、<code class="literal">must_exist</code> と<code class="literal">must_not_exist</code> の両フラグに優先します。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'must_exist'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
<a class="ulink" href="#brick-simple-do" target="_top">マイクロ・トランザクション</a>の中で使用すると、キーが存在しない場合にトランザクションが終了します。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'must_not_exist'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
<a class="ulink" href="#brick-simple-do" target="_top">マイクロ・トランザクション</a>の中で使用すると、キーが存在する場合にトランザクションが終了します。このフラグは、クライアント・アプリケーションにとって2個以上のキーの間の関係が重要な場合に便利です。
</li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Timeout</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
操作のタイムアウト時間（単位はミリ秒）
</li><li class="listitem">
任意：デフォルト値は15,000（ミリ秒）
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Timeout = timeout()</code>
</li><li class="listitem">
<code class="literal">timeout() = integer() | 'infinity'</code>
</li></ul></div></li></ul></div></dd></dl></div><p>戻り値</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
正常終了の場合
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">'ok'</code>
</li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
エラー終了の場合
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
<code class="literal">'key_not_exist'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
キーが存在しないため、操作が失敗しました。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{'ts_error', timestamp()}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">{'testset', timestamp()}</code> フラグが使用され、タイムスタンプが一致しないため、操作が失敗しました。戻り値の <code class="literal">timestamp()</code> は、既存のキーの現在のタイムスタンプの値です。
</li><li class="listitem">
<code class="literal">timestamp() = integer()</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'invalid_flag_present'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Flags</code> 引数に無効な <code class="literal">do_op_flag()</code> が検出されたため、操作が失敗しました。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'brick_not_available'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
該当キーに相当するチェインの現在の長さがゼロで利用できないため、操作が失敗しました。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{{'nodedown',node()},{'gen_server','call',term()}}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
要求を処理するサーバーのブリックに障害が発生した、あるいはクライアントとサーバー間のネットワークにパーティションが発生したため、操作が失敗しました。Adminサーバーが障害を検知してチェインの復旧処置を実施することを考慮して、少し時間をおいた後にクライアントから要求を再送してください。
</li><li class="listitem">
<code class="literal">node() = atom()</code>
</li></ul></div></li></ul></div></dd></dl></div><p>エイリアス</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
brick_simple:delete/2
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">brick_simple:delete(Tab, Key).</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
brick_simple:delete/3
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">brick_simple:delete(Tab, Key, Flags).</code>
</li><li class="listitem">
<code class="literal">brick_simple:delete(Tab, Key, Timeout).</code>
</li></ul></div></li></ul></div></dd></dl></div><p>例</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
キーと、そのペアのバリュー、および属性の削除に成功した場合
</p><pre class="screen">&gt; brick_simple:delete(tab1, &lt;&lt;"foo"&gt;&gt;).
ok</pre></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
キーを削除しようとしてキーが存在しないため、失敗した場合
</p><pre class="screen">&gt; brick_simple:delete(tab1, "key6").
key_not_exist</pre></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
キーを削除しようとして現在のタイムスタンプの指定が正しくなかったため、失敗した場合
</p><pre class="screen">&gt; brick_simple:delete(tab1, "goo", [{'testset', 12345}]).
{ts_error,1271543165272987}</pre></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
現在のタイムスタンプを正しく指定して、キーの削除に成功した場合
</p><pre class="screen">&gt; brick_simple:delete(tab1, "goo", [{'testset', 1271543165272987}]).
ok</pre></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
デフォルトではない操作のタイムアウト時間を指定して、キーの削除に成功した場合
</p><pre class="screen">&gt; brick_simple:delete(tab1, "key3", 30000).
ok</pre></dd></dl></div></div><div class="section" title="3.8. brick_simple:do/4"><div class="titlepage"><div><div><h3 class="title"><a id="brick-simple-do"></a>3.8. brick_simple:do/4</h3></div></div></div><p>書式</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
<span class="strong"><strong>brick_simple:do(Tab, OpList, OpFlags, Timeout).</strong></span>
</dd></dl></div><p>解説</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
テーブル<code class="literal">Tab</code> に基本操作のリストを送ります。それと同時に、Hibariのブリックがその基本操作を実行します。操作リスト<code class="literal">OpList</code> の最初の項目が<code class="literal">brick_server:make_txn()</code> の場合は、操作リストをマイクロ・トランザクションとして実行します。この場合は、すべての操作が成功するか、あるいはすべての操作が実行されないかのどちらかになります。これを「マイクロ」トランザクションと呼ぶのは、<code class="literal">brick_simple:do()</code> API を使用するすべての操作に適用される明確な制約となるからです。
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
対象となるキーはすべて、同一テーブル内に存在しなければなりません。
</li><li class="listitem">
対象となるキーはすべて、同一チェイン内に存在しなければなりません。
</li><li class="listitem">
トランザクション内のすべての操作は、1回の<code class="literal">brick_simple:do()</code> のコールで送らなければなりません。他のデータベースとは異なり、トランザクションのハンドルを要求し、そのトランザクションに対してアドホックに1個ずつ操作を追加することはできません。
</li></ul></div></dd><dt><span class="term">
 
</span></dt><dd>
マイクロ・トランザクションに関する詳細情報については、「Hibariシステム管理者ガイド」の
<a class="ulink" href="hibari-sysadmin-guide.en.html#micro-transactions" target="_top">マイクロ・トランザクション</a>の節を参照してください。
</dd></dl></div><p>引数</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Tab</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
操作を実行するテーブルの名前
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Tab = table()</code>
</li><li class="listitem">
<code class="literal">table() = atom()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>OpList</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
実行したい基本操作のリスト。各基本操作は、<code class="literal">brick_server:make_*()</code> APIによって起動されます。
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">OpList = do_op_list()</code>
</li><li class="listitem">
<code class="literal">do_op_list() = [do1_op()]</code>
</li><li class="listitem"><p class="simpara">
<code class="literal">do1_op() =</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
<code class="literal">brick_server:make_add(Key, Value, ExpTime, Flags)</code>
</li><li class="listitem">
<code class="literal">brick_server:make_replace(Key, Value, ExpTime, Flags)</code>
</li><li class="listitem">
<code class="literal">brick_server:make_set(Key, Value, ExpTime, Flags)</code>
</li><li class="listitem">
<code class="literal">brick_server:make_get(Key, Flags)</code>
</li><li class="listitem">
<code class="literal">brick_server:make_get_many(Key, Flags)</code>
</li><li class="listitem">
<code class="literal">brick_server:make_delete(Key, Flags)</code>
</li><li class="listitem"><p class="simpara">
<code class="literal">brick_server:make_txn()</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">do</code> 操作をアトミック・トランザクションとして実行したい場合は、 <code class="literal">OpList</code> の最初の項目として <code class="literal">brick_server:make_txn()</code> を入れてください。
</li></ul></div></li><li class="listitem">
各基本操作の引数は、その操作を単独で実行する場合と同じであることに注意してください。ただし、<code class="literal">Tab</code> および <code class="literal">Timeout</code> 引数は除きます。この両引数は、個別の操作の引数ではなく、<code class="literal">do</code> 操作全体の引数となります。たとえば、<code class="literal">add</code> 操作を単独で実行する場合の指定は<code class="literal">brick_simple:add(Tab, Key, Value, ExpTime, Flags, Timeout)</code> となります。それに対して、<code class="literal">do</code> 操作の中で実行する場合は<code class="literal">brick_server:make_add(Key, Value, ExpTime, Flags)</code> となります。
</li><li class="listitem">
各基本操作の詳細については、次を参照してください。
       <a class="ulink" href="#brick-simple-add" target="_top">brick_simple:add/6</a>,
       <a class="ulink" href="#brick-simple-replace" target="_top">brick_simple:replace/6</a>,
       <a class="ulink" href="#brick-simple-set" target="_top">brick_simple:set/6</a>,
       <a class="ulink" href="#brick-simple-get" target="_top">brick_simple:get/4</a>,
       <a class="ulink" href="#brick-simple-get-many" target="_top">brick_simple:get_many/5</a>, and
       <a class="ulink" href="#brick-simple-delete" target="_top">brick_simple:delete/4</a>.
</li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>OpFlags</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">do</code> 操作全体に適用される操作フラグのリスト
</li><li class="listitem">
任意：デフォルト値は空リスト
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">OpFlags = do_flags_list()</code>
</li><li class="listitem">
<code class="literal">do_flags_list() = [do_flag()]</code>
</li><li class="listitem">
<code class="literal">do_flag() = 'fail_if_wrong_role' | 'ignore_role'</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
操作フラグの使用方法
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
<code class="literal">'fail_if_wrong_role'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
do操作が対象のチェイン内の誤ったブリックに送られた場合（read要求が誤ってヘッド・ブリックに送られた、あるいはwrite要求が誤ってテイル・ブリックに送信された場合）、ただちにトランザクションは終了します。このフラグを指定していない場合のデフォルト処理では、誤りのブリックが要求を正しいブリックに転送します。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'ignore_role'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
このフラグを指定すると、要求を受けとったたブリックがどんな役割を割り振られていても、そのブリックが直接に要求にこたえます。
</li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
Timeout
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
操作のタイムアウト時間（単位はミリ秒）
</li><li class="listitem">
任意：デフォルト値は15,000（ミリ秒）
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Timeout = timeout()</code>
</li><li class="listitem">
<code class="literal">timeout() = integer() | 'infinity'</code>
</li></ul></div></li></ul></div></dd></dl></div><p>戻り値</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
正常終了の場合
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
<code class="literal">[do1_res_ok]</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">do1_res_ok</code> のリスト。リストの各項目が、<code class="literal">do</code> 操作で指定した各基本操作に対応します。戻り値は、要求の<code class="literal">OpList</code> で基本操作を指定した順番でリストに戻されます。<code class="literal">do</code> 操作でトランザクション処理を要求していない場合は、個別の基本操作が失敗しても<code class="literal">do</code> 操作全体は失敗しないことに注意してください。
</li><li class="listitem">
戻り値のリスト内で個別の基本操作に対応して返される<code class="literal">do1_res_ok</code> は、その基本操作を単独で実行した場合の戻り値と同じものです。たとえば、<code class="literal">do</code> 操作が正常終了した場合の戻り値のリスト内に <code class="literal">add</code> 基本操作の戻り値として返ってくるものは、
    <a class="ulink" href="#brick-simple-add" target="_top">brick_simple:add/6</a> で説明したものと同じです。また、replace基本操作の戻り値として返ってくるものは、
    <a class="ulink" href="#brick-simple-replace" target="_top">brick_simple:replace/6</a> で説明したものと同じです。これは、
    likewise for <a class="ulink" href="#brick-simple-set" target="_top">set</a>、
    <a class="ulink" href="#brick-simple-get" target="_top">get</a>、
    <a class="ulink" href="#brick-simple-get-many" target="_top">get_many</a>、
    <a class="ulink" href="#brick-simple-delete" target="_top">delete</a>の各基本操作に関しても同様です。
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
エラー終了の場合
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
<code class="literal">{txn_fail, [{integer(), do1_res_fail()}]}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">do</code> 操作でトランザクション処理が要求され、トランザクション中の個別基本操作が失敗したため、操作が失敗しました。<code class="literal">integer()</code> は、どの基本操作が失敗したかを、要求時の<code class="literal">OpList</code> に指定した順番で示します。たとえば、2が返された場合は、要求時の<code class="literal">OpList</code> に指定された2番目の基本操作が失敗したことを示します。<code class="literal">OpList</code> の最初の<code class="literal">txn()</code> 指定は順番に入っていないことに注意してください。
</li><li class="listitem"><p class="simpara">
<code class="literal">do1_res_fail()</code> は、基本操作の失敗の種類を示します。次のものが考えられます。
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p class="simpara">
<code class="literal">{'key_exists', timestamp()}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">timestamp() = integer()</code>
</li></ul></div></li><li class="listitem">
<code class="literal">'key_not_exist'</code>
</li><li class="listitem">
<code class="literal">{'ts_error', timestamp()}</code>
</li><li class="listitem">
<code class="literal">'invalid_flag_present'</code>
</li></ul></div></li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'invalid_flag_present'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">do</code> 要求の<code class="literal">OpFlags</code> 引数に無効な <code class="literal">do_flag()</code> が検出されたため、操作が失敗しました。これは、個別の基本操作で指定するフラグが誤ったエラーとは異なるエラーであることに注意してください。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'brick_not_available'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
該当キーに相当するチェインの現在の長さがゼロで利用できないため、操作が失敗しました。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{{'nodedown',node()},{'gen_server','call',term()}}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
要求を処理するサーバーのブリックに障害が発生した、あるいはクライアントとサーバー間のネットワークにパーティションが発生したため、操作が失敗しました。Adminサーバーが障害を検知してチェインの復旧処置を実施することを考慮して、少し時間をおいた後にクライアントから要求を再送してください。
</li><li class="listitem">
<code class="literal">node() = atom()</code>
</li></ul></div></li></ul></div></dd></dl></div><p>エイリアス</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
brick_simple:do/2
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">brick_simple:do(Tab, OpList).</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
brick_simple:do/3
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">brick_simple:do(Tab, OpList, Timeout).</code>
</li></ul></div></li></ul></div></dd></dl></div><p>例</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
トランザクション処理を要求しない<code class="literal">do</code> 操作に成功し、2個の新しいキーをテーブル<code class="literal">tab1</code> に追加した場合
</p><pre class="screen">&gt; brick_simple:do(tab1, [brick_server:make_add("foo3", "bar3"),brick_server:make_add("foo4", "bar4")]).
[ok,ok]</pre></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
2個の<code class="literal">get</code> 基本操作<code class="literal">Do1</code> と<code class="literal">Do2</code> を生成し、それつなげてトランザクション処理を要求しない<code class="literal">do</code> 操作にして、実行に成功した場合
</p><pre class="screen">&gt; Do1 = brick_server:make_get("foo").
{get,&lt;&lt;"foo"&gt;&gt;,[]}
&gt; Do2 = brick_server:make_get("foo2").
{get,&lt;&lt;"foo2"&gt;&gt;,[]}
&gt; brick_simple:do(tab1, [Do1, Do2]).
[{ok,1271543102911775,&lt;&lt;"Foo again?"&gt;&gt;},key_not_exist]</pre></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
トランザクション処理を要求した操作に失敗した場合（トランザクション処理が要求されているため、基本操作<code class="literal">Do2b</code> の失敗により、操作全体が失敗）
</p><pre class="screen">&gt; Do1b = brick_server:make_get("foo").
{get,&lt;&lt;"foo"&gt;&gt;,[]}
&gt; Do2b = brick_server:make_get("foo2", [must_exist]).
{get,&lt;&lt;"foo2"&gt;&gt;,[must_exist]}
&gt; brick_simple:do(tab1, [brick_server:make_txn(), Do1b, Do2b]).
{txn_fail,[{2,key_not_exist}]}</pre></dd></dl></div></div><div class="section" title="3.9. brick_simple:fold_table/7"><div class="titlepage"><div><div><h3 class="title"><a id="brick-simple-fold-table"></a>3.9. brick_simple:fold_table/7</h3></div></div></div><p>書式</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
<span class="strong"><strong>brick_simple:fold_table(Tab, Fun, Acc, NumItems, Flags, MaxParallel, Timeout).</strong></span>
</dd></dl></div><p>解説</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
テーブル内のすべてのキーに対して、フォールド操作を行います。この操作の基盤であるErlangのfold関数の概要については、 <a class="ulink" href="http://www.erlang.org/doc/man/lists.html#foldl-3" target="_top">http://www.erlang.org/doc/man/lists.html#foldl-3</a> を参照してください。
</dd></dl></div><div class="important" title="&#x91CD;&#x8981;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x91CD;&#x8981;]" src="images/icons/important.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>データの移行処理中にこの操作を実行しないでください。</p></td></tr></table></div><p>引数</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Tab</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
フォールド操作を実行するテーブルの名前
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Tab = table()</code>
</li><li class="listitem">
<code class="literal">table() = atom()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Fun</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
リストの連続要素に対して適用する関数
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Fun  = fun_arity_2()</code>
</li><li class="listitem"><p class="simpara">
<code class="literal">fun_arity_2()</code> arguments =
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p class="simpara">
<code class="literal">{ChainName, Tuple_from_get_many}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">Tuple_From_get_many</code> は、
<a class="ulink" href="#brick-simple-get-many" target="_top">brick_simple:get_many()</a>のひとつの結果を単独のタプルで表わしたものです。<code class="literal">Flags</code> 引数によりフォーマットが異なります。<code class="literal">Flags</code> 引数はそのまま <code class="literal">get_many()</code> コールに渡されます。たとえば<code class="literal">Flags</code> = <code class="literal">[]</code> の場合、<code class="literal">Tuple_From_get_many</code> は<code class="literal">{Key, TS, Value}</code> というフォーマットとなり、<code class="literal">Flags</code> = <code class="literal">[witness]</code> の場合、<code class="literal">Tuple_From_get_many</code> は<code class="literal">{Key, TS}</code> というフォーマットとなります。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">Acc</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
結果を累算する項
</li></ul></div></li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Acc</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
結果を累算する項の初期値
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
o Acc = term()
NumItems
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
フォールド操作によるget_many操作のバッチサイズ
</li><li class="listitem">
必須
</li><li class="listitem">
型
</li><li class="listitem">
<code class="literal">Acc  = term()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>NumItems</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
フォールド関数に使う<code class="literal">get_many</code> 操作のバッチサイズ
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">NumItems  = integer()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Flags</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">fold_table</code> 操作に適用される操作フラグのリスト。ここでサポートするフラグは、
<a class="ulink" href="#brick-simple-get-many" target="_top">brick_simple:get_many()</a>と同じです。
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Flags = flags_list()</code>
</li><li class="listitem">
<code class="literal">flags_list() = [do_op_flag() | property()]</code>
</li><li class="listitem">
<code class="literal">do_op_flag() = 'get_all_attribs' | 'witness' | {'binary_prefix',
    binary()} | {'max_bytes', integer()}</code>
</li><li class="listitem">
<code class="literal">property() = atom() | {term(), term()}</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
操作フラグの使用方法
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
<code class="literal">'get_all_attribs'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
各キーのすべての属性を返します。<code class="literal">witness</code> フラグと組み合わせて使用できます。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'witness'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
検索結果としてバリューBLOBを返しません。このフラグを指定すると、ブリックが要求に対応するためにディスクにアクセスする必要がないことを保証できます。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{'binary_prefix', binary()}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
<code class="literal">binary()</code> と正確に一致するバイナリ値をプレフィクスとするキーのみを返します。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{'max_bytes', integer()}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
対応するバリューBLOBのサイズの合計が<code class="literal">integer()</code> バイトを超えない範囲のキーだけを返します。
</li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>MaxParallel</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">MaxParallel</code>= 0を指定すると、本来の意味のフォールドを実行します。<code class="literal">MaxParallel</code>&gt;= 1を指定すると、それぞれのチェインで独立にフォールドを実行します。<code class="literal">MaxParallel</code> で指定した数に達するまでフォールドを並行して実行し、それぞれのチェインのフォールドの結果をそのまま要求者に返します。つまり、<code class="literal">map-reduce</code> サイクルの<code class="literal">reduce</code> フェーズのように処理結果を結合するわけでは<span class="strong"><strong>ありません</strong></span> 。
</li><li class="listitem">
任意：デフォルト値は0
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">MaxParallel = integer()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Timeout</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
操作のタイムアウト時間（単位はミリ秒）
</li><li class="listitem">
任意：デフォルト値は5,000（ミリ秒）
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Timeout = timeout()</code>
</li><li class="listitem">
<code class="literal">timeout() = integer()</code>
</li></ul></div></li></ul></div></dd></dl></div><p>戻り値</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
正常終了の場合
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
<code class="literal">{ok, Acc, Iterations}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Acc = term()</code>
</li><li class="listitem">
<code class="literal">Iterations = integer()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
エラー終了の場合
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
<code class="literal">{error, GdssError, Acc, Iterations}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">GdssError = term()</code>
</li><li class="listitem">
<code class="literal">Acc = term()</code>
</li><li class="listitem">
<code class="literal">Iterations = integer()</code>
</li></ul></div></li></ul></div></dd></dl></div><p>エイリアス</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
brick_simple:fold_table/5
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">brick_simple:fold_table(Tab, Fun, Acc, NumItems, Flags).</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
brick_simple:fold_table/6
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">brick_simple:fold_table(Tab, Fun, Acc, NumItems, Flags,
    MaxParallel).</code>
</li></ul></div></li></ul></div></dd></dl></div><p>例</p><p>_（追加予定）</p></div><div class="section" title="3.10. brick_simple:fold_key_prefix/9"><div class="titlepage"><div><div><h3 class="title"><a id="brick-simple-fold-key"></a>3.10. brick_simple:fold_key_prefix/9</h3></div></div></div><p>書式</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
<span class="strong"><strong>brick_simple:fold_key_prefix(Tab, Prefix, StartKey, Fun, Acc, Flags0,
 NumItems, SleepTime, Timeout).</strong></span>
</dd></dl></div><p>解説</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd>
テーブル<code class="literal">Tab</code> の<code class="literal">StartKey</code> から始まるすべてのキーに対して、フォールド操作を実行します。その際、バイナリ値が<code class="literal">Prefix</code> で始まるキーのみを対象とします。イテレーションの間で<code class="literal">SleepTime</code> ミリ秒だけスリープし、<code class="literal">Flags</code> と<code class="literal">NumItems</code> を
<a class="ulink" href="#brick-simple-get-many" target="_top">brick_simple:get_many()</a>への引数として使用します。この操作の基盤であるErlangのfold関数の概要については、http://www.erlang.org/doc/man/lists.html#foldl-3を参照してください。
</dd></dl></div><div class="important" title="&#x91CD;&#x8981;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x91CD;&#x8981;]" src="images/icons/important.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>データの移行処理中にこの操作を実行しないでください。</p></td></tr></table></div><p>引数</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Tab</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
フォールド操作を実行するテーブルの名前
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Tab = table()</code>
</li><li class="listitem">
<code class="literal">table() = atom()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Prefix</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
フォールド操作を実行したいキーのプレフィクスの値
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Prefix = binary()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>StartKey</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
フォールド操作を開始したいキー値
</li><li class="listitem">
任意：デフォルト値は指定した<code class="literal">Prefix</code> の値
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">StartKey = binary()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Fun</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
リストの連続要素に対して適用する関数
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Fun  = fun_arity_2()</code>
</li><li class="listitem"><p class="simpara">
<code class="literal">fun_arity_2()</code> arguments =
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p class="simpara">
<code class="literal">Tuple_from_get_many</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">Tuple_From_get_many</code> は、
  <a class="ulink" href="#brick-simple-get-many" target="_top">brick_simple:get_many()</a>のひとつの結果を単独のタプルで表わしたものです。<code class="literal">Flags</code> 引数によりフォーマットが異なります。<code class="literal">Flags</code> 引数はそのまま <code class="literal">get_many()</code> コールに渡されます。たとえば、<code class="literal">Flags</code> = <code class="literal">[]</code> の場合、<code class="literal">Tuple_From_get_many</code> は<code class="literal">{Key, TS, Value}</code> というフォーマットとなり、<code class="literal">Flags</code> = <code class="literal">[witness]</code> の場合、<code class="literal">Tuple_From_get_many</code> は<code class="literal">{Key, TS}</code> というのフォーマットとなります。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">UserAccumulatorTerm</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
_（説明を追加予定）
</li></ul></div></li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Acc</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
_（説明を追加予定）
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Acc  = term()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Flags0</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">fold_key_prefix</code> 操作に適用される操作フラグのリスト。ここでサポートするフラグは、
  <a class="ulink" href="#brick-simple-get-many" target="_top">brick_simple:get_many()</a>と同じです。ただし、 <code class="literal">{'binary_prefix', binary()}</code> フラグを除きます。キーのプレフィクス値は、<code class="literal">brick_simple:fold_key_prefix()</code> の<code class="literal">Prefix</code> 引数を通して直接渡されるため、このフラグは使用されません。
</li><li class="listitem">
必須
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Flags0 = 'get_all_attribs' | 'witness' | {'max_bytes', integer()}</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
操作フラグの使用方法
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
<code class="literal">'get_all_attribs'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
キーのすべての属性を返します。<code class="literal">witness</code> フラグと組み合わせて使用できます。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">'witness'</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
検索結果としてバリューBLOBを返しません。このフラグを指定すると、ブリックが要求に対応するためにディスクにアクセスする必要がないことを保証できます。
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">{'max_bytes', integer()}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
対応するバリューBLOBのサイズの合計が<code class="literal">integer()</code> バイトを超えない範囲のキーだけを返します。
</li></ul></div></li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>NumItems</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
_（説明を追加予定）
</li><li class="listitem">
任意：省略値は100
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">NumItems  = integer()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>SleepTime</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
イテレーションの間のスリープ時間（単位はミリ秒）
</li><li class="listitem">
任意：デフォルト値は0
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">SleepTime = integer()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
<span class="strong"><strong>Timeout</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
操作のタイムアウト時間（単位はミリ秒）
</li><li class="listitem">
任意：デフォルト値は15,000（ミリ秒）
</li><li class="listitem"><p class="simpara">
型
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Timeout = timeout()</code>
</li><li class="listitem">
<code class="literal">timeout() = integer()</code>
</li></ul></div></li></ul></div></dd></dl></div><p>戻り値</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><p class="simpara">
正常終了の場合
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
<code class="literal">{ok, Acc, Iterations}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">Acc = term()</code>
</li><li class="listitem">
<code class="literal">Iterations = integer()</code>
</li></ul></div></li></ul></div></dd><dt><span class="term">
 
</span></dt><dd><p class="simpara">
エラー終了の場合
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
<code class="literal">{error, GdssError, Acc, Iterations}</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">GdssError = term()</code>
</li><li class="listitem">
<code class="literal">Acc = term()</code>
</li><li class="listitem">
<code class="literal">Iterations = integer()</code>
</li></ul></div></li></ul></div></dd></dl></div><p>エイリアス</p><div class="variablelist"><dl><dt><span class="term">
 
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
brick_simple:fold_key_prefix/5
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">brick_simple:fold_key_prefix(Tab, Prefix, Fun, Acc, Flags).</code>
</li></ul></div></li></ul></div></dd></dl></div><p>例</p><p>_（追加予定）</p></div></div><div class="section" title="4. &#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;API&#xFF1A;UBF"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="client-api-ubf"></a>4. クライアントAPI：UBF</h2></div></div></div><p><a class="ulink" href="http://github.com/norton/ubf" target="_top">UBFプロトコル</a> は、正式に規定されたプロトコル群です。多数のクライアント言語がこれをサポートしています。本章では、UBFプロトコル層の各層について説明します。さらに、UBFクライアントをErlangやその他の言語で使用する方法、およびそのクライアントを使ってHibariのストレージ・クラスターにアクセスする方法について説明します。</p><p>Hibariのソースコードのディストリビューションには、次の言語におけるUBF/EBFプロトコルのサポートが含まれています。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Erlangに関しては <a class="xref" href="#using-ubf-erlang-client" title="4.5. Erlang&#x7528;&#x306E;UBF&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;&#x30FB;&#x30E9;&#x30A4;&#x30D6;&#x30E9;&#x30EA;&#x306E;&#x4F7F;&#x7528;&#x6CD5;">「Erlang用のUBFクライアント・ライブラリの使用法」</a> を参照してください。
</li><li class="listitem">
Javaに関しては <a class="xref" href="#using-ubf-java-client" title="4.6. Java&#x7528;&#x306E;UBF&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;&#x30FB;&#x30E9;&#x30A4;&#x30D6;&#x30E9;&#x30EA;&#x306E;&#x4F7F;&#x7528;&#x6CD5;">「Java用のUBFクライアント・ライブラリの使用法」</a> を参照してください。
</li><li class="listitem">
Pythonに関しては <a class="xref" href="#using-ubf-python-client" title="4.7. Python&#x7528;&#x306E;EBF&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;&#x30FB;&#x30E9;&#x30A4;&#x30D6;&#x30E9;&#x30EA;&#x306E;&#x4F7F;&#x7528;&#x6CD5;">「Python用のEBFクライアント・ライブラリの使用法」</a> を参照してください。
</li></ul></div><div class="section" title="4.1. Hibari&#x30B5;&#x30FC;&#x30D0;&#x30FC;&#x306B;&#x304A;&#x3051;&#x308B;UBF&#x30D7;&#x30ED;&#x30C8;&#x30B3;&#x30EB;&#x5C64;&#x306E;&#x5B9F;&#x88C5;"><div class="titlepage"><div><div><h3 class="title"><a id="hibari-server-impl-of-ubf-proto-stack"></a>4.1. HibariサーバーにおけるUBFプロトコル層の実装</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">
UBF(A)：ボトム層、トランスポート・プロトコル層およびセッション・プロトコル層
</span></dt><dd><p class="simpara">
この層は、<a class="ulink" href="http://en.wikipedia.org/wiki/Open_Network_Computing_Remote_Procedure_Call" target="_top">ONC-RPC</a>や
<a class="ulink" href="http://en.wikipedia.org/wiki/IIOP" target="_top">CORBA IIOP</a>、
<a class="ulink" href="http://en.wikipedia.org/wiki/Protocol_buffers" target="_top">Protocol Buffers</a>、
<a class="ulink" href="http://en.wikipedia.org/wiki/Thrift_(protocol)" target="_top">Thrift</a> など、ホスト間伝送にTCPを用いる他の多くのシリアライズされたデータ伝送プロトコルと同様に、基本的な役割を果たします。
</p><p class="simpara">Hibariサーバーは、TCP/IPトランスポート層の上に載るこれらのセッション・プロトコルをいくつかサポートします。どのセッション・プロトコルを選択するかは、使いやすいもの、あるいは、アプリケーション開発者が支持するものでよいでしょう。アプリケーション開発者にとって、HibariでRubyとJSON-RPCを使うのも、PythonとProtocol Buffersを使うのも、同じように容易なはずです。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
UBF(A)：Joe Armstrongが作ったセッション層プロトコル。
</li><li class="listitem">
EBF：Erlang Binary Format。このセッション層プロトコルは軽くて効率的なプロトコルです。Erlangの組込み関数である<code class="literal">term_to_binary()</code> と <code class="literal">binary_to_term()</code> を使用してErlangのデータ項をシリアライズします。<a class="ulink" href="http://bert-rpc.org/" target="_top">BERTプロトコル</a>と非常に密接な関連を持ちます。
</li><li class="listitem">
JSON over TCP：JSF（JavaScript Format）とも呼ばれるもの。Erlangの項を
 <a class="ulink" href="http://en.wikipedia.org/wiki/JSON" target="_top">JSONの項</a>として表記し、直接TCPトランスポート層上で送信します。このプロトコルは、あまり一般的に使用されているものではありませんが、UBFサーバーのフレームワーク内で容易に実装できます。
</li><li class="listitem">
HTTP：<a class="ulink" href="http://en.wikipedia.org/wiki/HTTP" target="_top">Hypertext Transfer Protocol</a>。このプロトコルはHibariの
<a class="ulink" href="http://en.wikipedia.org/wiki/JSON-RPC" target="_top">JSON-RPC</a>サーバーに使用され、Hibariを支えています。
</li><li class="listitem">
<a class="ulink" href="http://en.wikipedia.org/wiki/Thrift_(protocol)" target="_top">Thrift</a>：UBF(A) やErlangネイティブのワイヤ・フォーマットではなく、Thriftのバイナリ表記をワイヤ・プロトコルとして使用している点を除けば、EBFと同じです。
</li><li class="listitem">
<a class="ulink" href="http://en.wikipedia.org/wiki/Protocol_buffers" target="_top">Protocol Buffers</a>：UBF(A) やErlangネイティブのワイヤ・フォーマットではなく、Google のProtocol Buffers バイナリ表記をワイヤ・プロトコルとして使用している点を除けば、EBFと同じです。<span class="strong"><strong>Hibariでは実験的にサポートしています（まだ実装段階ではありません）。</strong></span>
</li><li class="listitem">
<a class="ulink" href="http://hadoop.apache.org/avro/docs/current/" target="_top">Avro</a>：UBF(A) やErlangネイティブのワイヤ・フォーマットではなく、Avroのバイナリ表記をワイヤ・プロトコルとして使用している点を除けば、EBFと同じです。<span class="strong"><strong>Hibariでは実験的にサポートしています（まだ実装段階ではありません）。</strong></span>
</li></ul></div></dd><dt><span class="term">
UBF(B)：ミドル層、「コントラクト」
</span></dt><dd><p class="simpara">
UBF(B)は、UBF(A)の型、およびクライアントとサーバー間のプロトコルを記述するプログラミング言語です。UBF(B)は、Verified XMLやXMLスキーマ、SOAP、WDSLとほぼ同等です。
</p><p class="simpara">この層は、プロトコルの「コントラクト」、つまりクライアントおよびサーバーが送信する全データのフォーマット仕様として働きます。少しでもプロトコルに従わないデータがあれば、サーバー内に埋め込まれたコントラクト・チェッカーがそれを排除します。クライアントが望めば、コントラクト・チェッカーを使ってサーバーが送信するデータの妥当性を確認することもできますが、一般的にはあまり行われません。</p></dd><dt><span class="term">
UBF（C）：トップ層、UBFメタプロトコル
</span></dt><dd>
メタプロトコルは、UBFセッションの開始時に、TCPリスナーが提供可能なUBF(B)コントラクトのひとつを選択します。現時点でHibariサーバーがサポートできるのは“gdss”コントラクトだけですが、将来は他のコントラクトも追加する予定です。
</dd></dl></div></div><div class="section" title="4.2. UBF&#x306B;&#x304A;&#x3051;&#x308B;&#x30B9;&#x30C8;&#x30EA;&#x30F3;&#x30B0;&#x3068;&#x30D0;&#x30A4;&#x30CA;&#x30EA;&#x306E;&#x8868;&#x73FE;"><div class="titlepage"><div><div><h3 class="title"><a id="ubf-representation-of-strings"></a>4.2. UBFにおけるストリングとバイナリの表現</h3></div></div></div><p>Erlang言語は、ストリング（文字列）をデータ型として明確にはサポートしておらず、整数（ASCIIバイト値）やバイナリのリストとして表現します。</p><p>一方、UBFコントラクトは、ストリングとリストとバイナリを区別します。ストリングの場合、UBF(A)は、ストリング "Hello, world!" を <code class="literal">{'#S', "Hello, world!"}</code> と表記します。</p><p>しかし、開発者にとって、このストリング表記を使用するのは煩雑です。Erlangでは、<code class="literal">ubf.hrl</code> ヘッダー・ファイルに <code class="literal">?S("Hello, world!")</code> というマクロが入っており、少しはましな近道になります。他の言語を使用する際には、いずれかの2項のタプルとアトムとして、2項のタプルとアトム <code class="literal">'#S'</code> を作成できます。</p><p>幸いなことに、ストリングが必要になるのは、 <code class="literal">startSession</code> メタプロトコル・コマンドを用いてHibariデータ・サーバー・コントラクトの使用を開始する際の1回だけです。以下に例を示します。</p></div><div class="section" title="4.3. &#x3059;&#x3079;&#x3066;&#x306E;&#x8A00;&#x8A9E;&#x306B;&#x304A;&#x3051;&#x308B;UBF&#x30D9;&#x30FC;&#x30B9;&#x306E;&#x30D7;&#x30ED;&#x30C8;&#x30B3;&#x30EB;&#x306E;&#x4F7F;&#x7528;&#x624B;&#x9806;"><div class="titlepage"><div><div><h3 class="title"><a id="using-ubf-in-any-language"></a>4.3. すべての言語におけるUBFベースのプロトコルの使用手順</h3></div></div></div><p>UBFベースのプロトコルを使用する場合、すべての言語で同じ手順に従います。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
UBFサーバーへのコネクションを作成します。
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
EBFサーバー、JSON-RPCサーバー、 Thriftサーバーなど他のサーバーでも同様です。
</li></ul></div></li><li class="listitem">
UBFメタプロトコルを用いて、<code class="literal">gdss</code> コントラクト、すなわちHibariサーバー・コントラクトの使用を開始します。
</li><li class="listitem">
Hibariサーバーに1回ないし複数回のクエリを送信し、サーバーの各応答を解析します。
</li><li class="listitem">
UBFサーバーへのコネクションをクローズします。
</li></ol></div></div><div class="section" title="4.4. Hibari&#x306E;UBF&#x30D7;&#x30ED;&#x30C8;&#x30B3;&#x30EB;&#x30FB;&#x30B3;&#x30F3;&#x30C8;&#x30E9;&#x30AF;&#x30C8;"><div class="titlepage"><div><div><h3 class="title"><a id="the-hibari-ubf-protocol-contract"></a>4.4. HibariのUBFプロトコル・コントラクト</h3></div></div></div><p>HibariのUBFプロトコル・コントラクトは、ファイル<code class="literal">ubf_gdss_plugin.con</code> にあります。</p><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>このファイルの最新版は、Hibariのソースコードを参照してください。
<a class="ulink" href="./misc-codes/ubf_gdss_plugin.con" target="_top">このドキュメント内にもファイル<code class="literal">ubf_gdss_plugin.con</code> のコピーがあります</a>が、さらに改訂版が出ている可能性があります。</p></td></tr></table></div><p>コントラクト内で指定されるUBFの型名は、<a class="xref" href="#client-api-erlang" title="3. &#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;API &#xFF1A; &#x30CD;&#x30A4;&#x30C6;&#x30A3;&#x30D6;Erlang">「クライアントAPI ： ネイティブErlang」</a>で使用している型名とは少し違います。たとえば、UBFコントラクトでは、キーの有効期限を <code class="literal">exp_time()</code> としていますが、このドキュメントでは <code class="literal">expiry()</code> としています。多少名前が違っても、有効期限として両方の名前が使用する基本データ型は同じ<code class="literal">integer()</code> です。</p><p>UBFコントラクトでは、各コマンドに次の命名規約を使います。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">CommandName_req()</code> クライアントからサーバーに送信する要求。たとえば<code class="literal">set</code> コマンドは<code class="literal">set_req()</code> となります。
</li><li class="listitem">
<code class="literal">CommandName_res()</code> サーバーからクライアントに送信する応答。たとえば<code class="literal">set</code> コマンドは<code class="literal">set_res()</code> となります。
</li></ul></div><p>UBFのRPCコールは、タプルの形式になるのが一般的です。タプルの最初の要素がコマンド名で、後続の要素がそのコマンドの引数です。応答はErlangのいずれのデータ型の項でも返せますが、Hibariのコントラクトは、アトム型かタプル型の応答のみを返します。</p><p>以下に、UBFのクライアント要求とErlangのAPIのマッピングをアルファベット順に示します。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">add_req()</code> →<code class="literal">brick_simple:add()</code> ：<a class="xref" href="#brick-simple-add" title="3.2. brick_simple:add/6">「brick_simple:add/6」</a> を参照
</li><li class="listitem">
<code class="literal">delete_req()</code> →<code class="literal">brick_simple:delete()</code> ：<a class="xref" href="#brick-simple-delete" title="3.7. brick_simple:delete/4">「brick_simple:delete/4」</a> を参照
</li><li class="listitem">
<code class="literal">do_req()</code> → <code class="literal">brick_simple:do()</code> ：<a class="xref" href="#brick-simple-do" title="3.8. brick_simple:do/4">「brick_simple:do/4」</a> を参照
</li><li class="listitem">
<code class="literal">get_req()</code> →<code class="literal">brick_simple:get()</code> ：<a class="xref" href="#brick-simple-get" title="3.5. brick_simple:get/4">「brick_simple:get/4」</a> を参照
</li><li class="listitem">
<code class="literal">get_many_req()</code> →<code class="literal">brick_simple:get_many()</code> ：<a class="xref" href="#brick-simple-get-many" title="3.6. brick_simple:get_many/5">「brick_simple:get_many/5」</a> を参照
</li><li class="listitem">
<code class="literal">replace_req()</code> → <code class="literal">brick_simple:replace()</code> ：<a class="xref" href="#brick-simple-replace" title="3.3. brick_simple:replace/6">「brick_simple:replace/6」</a> を参照
</li><li class="listitem">
<code class="literal">set_req()</code> →<code class="literal">brick_simple:set()</code> ：<a class="xref" href="#brick-simple-set" title="3.4. brick_simple:set/6">「brick_simple:set/6」</a> を参照
</li></ul></div></div><div class="section" title="4.5. Erlang&#x7528;&#x306E;UBF&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;&#x30FB;&#x30E9;&#x30A4;&#x30D6;&#x30E9;&#x30EA;&#x306E;&#x4F7F;&#x7528;&#x6CD5;"><div class="titlepage"><div><div><h3 class="title"><a id="using-ubf-erlang-client"></a>4.5. Erlang用のUBFクライアント・ライブラリの使用法</h3></div></div></div><div class="important" title="&#x91CD;&#x8981;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x91CD;&#x8981;]" src="images/icons/important.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
Erlangシェルを実験やプロトタイプで使用する場合、シェルのサーチ・パスに、ErlangのUBFクライアント・ライブラリへのパスを入れなければなりません。その一番簡単な方法は、Erlangシェルの <code class="literal">erl</code> コマンドの引数として、次を使用することです。
<code class="literal">-pz /path/to/ubf/library/ebin</code>
</li><li class="listitem">
コードを作成する場合は、<code class="literal">?S()</code> マクロを使用できるように、ソースモジュールの先頭行に次のステートメントを置いてください。
<code class="literal">-include("ubf.hrl").</code>
Erlangシェルの制限により、シェル中ではマクロを使用できません。
</li></ol></div></td></tr></table></div><p><a class="xref" href="#using-ubf-in-any-language" title="4.3. &#x3059;&#x3079;&#x3066;&#x306E;&#x8A00;&#x8A9E;&#x306B;&#x304A;&#x3051;&#x308B;UBF&#x30D9;&#x30FC;&#x30B9;&#x306E;&#x30D7;&#x30ED;&#x30C8;&#x30B3;&#x30EB;&#x306E;&#x4F7F;&#x7528;&#x624B;&#x9806;">「すべての言語におけるUBFベースのプロトコルの使用手順」</a>
 で概説したように、最初のステップは、Hibariサーバーへのコネクションを作成することです。Hibariクラスターにノードが複数ある場合は、どのノードへのコネクションを作成しても構いません。すべてのノードがすべてのUBF要求に対応し、要求を適切なブリックに回すことができます。</p><p title="UBF&#x30B5;&#x30FC;&#x30D0;&#x30FC;&#xFF08;&#x201C;localhost&#x201D;&#x306E;TCP&#x30DD;&#x30FC;&#x30C8;7581&#xFF09;&#x3078;&#x306E;&#x30B3;&#x30CD;&#x30AF;&#x30B7;&#x30E7;&#x30F3;&#x3092;&#x4F5C;&#x6210;&#x3059;&#x308B;"><strong>UBFサーバー（“localhost”のTCPポート7581）へのコネクションを作成する. </strong>
</p><pre class="screen">(asdf@bb3)54&gt; {ok, P1, _} = ubf_client:connect("localhost", 7581, [{proto, ubf}], 5000).
{ok,&lt;0.139.0&gt;,{'#S', "gdss_meta_server"}}</pre><p title="UBF&#x30B5;&#x30FC;&#x30D0;&#x30FC;&#xFF08;&#x201C;localhost&#x201D;&#x306E;TCP&#x30DD;&#x30FC;&#x30C8;7581&#xFF09;&#x3078;&#x306E;&#x30B3;&#x30CD;&#x30AF;&#x30B7;&#x30E7;&#x30F3;&#x3092;&#x4F5C;&#x6210;&#x3059;&#x308B;">
</p><p>次に、このコネクションを用いてコマンドを使用していくために、UBFメタプロトコルを用いて、Hibariサーバーの“gdss” と呼ばれるコントラクトを選択します。</p><div class="tip" title="&#x30D2;&#x30F3;&#x30C8;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x30D2;&#x30F3;&#x30C8;]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Hibariサーバーのコントラクトは「ステートレス」です。<code class="literal">ubf_client:rpc/2</code> 関数からの応答に含まれる項はすべて<code class="literal">{reply,ServerReply,UBF_StateName}</code> の形式をとります。Hibariサーバーのコントラクトはステートレスであるため、<code class="literal">UBF_StateName</code> は常にアトム<code class="literal">none</code> になります。</p></td></tr></table></div><p title="UBF&#x30E1;&#x30BF;&#x30D7;&#x30ED;&#x30C8;&#x30B3;&#x30EB;&#x3092;&#x7528;&#x3044;&#x3066;&#x201C;gdss&#x201D;&#x30B3;&#x30F3;&#x30C8;&#x30E9;&#x30AF;&#x30C8;&#x3092;&#x8981;&#x6C42;&#x3059;&#x308B;"><strong>UBFメタプロトコルを用いて“gdss”コントラクトを要求する. </strong>
</p><pre class="screen">(asdf@bb3)55&gt; ubf_client:rpc(P1, {startSession, {'#S', "gdss"}, []}).
{reply,{ok,ok},none}</pre><p title="UBF&#x30E1;&#x30BF;&#x30D7;&#x30ED;&#x30C8;&#x30B3;&#x30EB;&#x3092;&#x7528;&#x3044;&#x3066;&#x201C;gdss&#x201D;&#x30B3;&#x30F3;&#x30C8;&#x30E9;&#x30AF;&#x30C8;&#x3092;&#x8981;&#x6C42;&#x3059;&#x308B;">
</p><p>これでUBFコネクションが確立しました。このコネクションを用いてキー「foo」を設定します。</p><p title="&#x30C6;&#x30FC;&#x30D6;&#x30EB; tab1 &#x306B;&#x3001;&#x30AD;&#x30FC;&#x300C;foo&#x300D;&#x3092;&#x8A2D;&#x5B9A;&#x3059;&#x308B;&#xFF08;&#x30D0;&#x30EA;&#x30E5;&#x30FC;&#x306F;&#x300C;foo val&#x300D;&#x3001;&#x6709;&#x52B9;&#x671F;&#x9650;&#x3068;&#x30D5;&#x30E9;&#x30B0;&#x306F;&#x6307;&#x5B9A;&#x306A;&#x3057;&#x3001;&#x30BF;&#x30A4;&#x30E0;&#x30A2;&#x30A6;&#x30C8;&#x6642;&#x9593;&#x306F;5&#x79D2;&#xFF09;"><strong>テーブル <code class="literal">tab1</code> に、キー「foo」を設定する（バリューは「foo val」、有効期限とフラグは指定なし、タイムアウト時間は5秒）. </strong>
</p><pre class="screen">(asdf@bb3)59&gt; ubf_client:rpc(P1, {set, tab1, &lt;&lt;"foo"&gt;&gt;, &lt;&lt;"foo val"&gt;&gt;, 0, [], 5000}).
{reply,ok,none}</pre><p title="&#x30C6;&#x30FC;&#x30D6;&#x30EB; tab1 &#x306B;&#x3001;&#x30AD;&#x30FC;&#x300C;foo&#x300D;&#x3092;&#x8A2D;&#x5B9A;&#x3059;&#x308B;&#xFF08;&#x30D0;&#x30EA;&#x30E5;&#x30FC;&#x306F;&#x300C;foo val&#x300D;&#x3001;&#x6709;&#x52B9;&#x671F;&#x9650;&#x3068;&#x30D5;&#x30E9;&#x30B0;&#x306F;&#x6307;&#x5B9A;&#x306A;&#x3057;&#x3001;&#x30BF;&#x30A4;&#x30E0;&#x30A2;&#x30A6;&#x30C8;&#x6642;&#x9593;&#x306F;5&#x79D2;&#xFF09;">
</p><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>上記の例の<code class="literal">set_req()</code> と下記の例の <code class="literal">get_req()</code> の両方で、戻り値の値は、それぞれ<a class="xref" href="#brick-simple-set" title="3.4. brick_simple:set/6">「brick_simple:set/6」</a> と <a class="xref" href="#brick-simple-get" title="3.5. brick_simple:get/4">「brick_simple:get/4」</a> に記述されたとおりであることに注意してください。</p><p>唯一の違いは、<code class="literal">ubf_client:rpc/2</code> 関数では、サーバーからの応答を3項のタプル <code class="literal">{reply,ServerReply,none}</code>.としてまとめることです。</p></td></tr></table></div><p title="&#x30C6;&#x30FC;&#x30D6;&#x30EB;tab1 &#x304B;&#x3089;&#x3001;&#x30AD;&#x30FC;&#x300C;foo&#x300D;&#x3092;&#x53D6;&#x5F97;&#x3059;&#x308B;&#xFF08;&#x30BF;&#x30A4;&#x30E0;&#x30A2;&#x30A6;&#x30C8;&#x6642;&#x9593;&#x306F;5&#x79D2;&#xFF09;"><strong>テーブル<code class="literal">tab1</code> から、キー「foo」を取得する（タイムアウト時間は5秒）. </strong>
</p><pre class="screen">(asdf@bb3)66&gt; ubf_client:rpc(P1, {get, tab1, &lt;&lt;"foo"&gt;&gt;, [], 5000}).
{reply,{ok,1273009092549799,&lt;&lt;"foo val"&gt;&gt;},none}</pre><p title="&#x30C6;&#x30FC;&#x30D6;&#x30EB;tab1 &#x304B;&#x3089;&#x3001;&#x30AD;&#x30FC;&#x300C;foo&#x300D;&#x3092;&#x53D6;&#x5F97;&#x3059;&#x308B;&#xFF08;&#x30BF;&#x30A4;&#x30E0;&#x30A2;&#x30A6;&#x30C8;&#x6642;&#x9593;&#x306F;5&#x79D2;&#xFF09;">
</p><p>クライアントがコントラクトに違反する要求を送信すると、下記の例のように、サーバーが違反を返します。</p><p title="&#x30B3;&#x30F3;&#x30C8;&#x30E9;&#x30AF;&#x30C8;&#x9055;&#x53CD;&#x306E;&#x8981;&#x6C42;&#x3092;&#x9001;&#x4FE1;&#x3059;&#x308B;"><strong>コントラクト違反の要求を送信する. </strong>
</p><pre class="screen">(asdf@bb3)89&gt; ubf_client:rpc(P1, {bbb, 3000}).
{reply,{clientBrokeContract,{bbb,3000},[]},none}</pre><p title="&#x30B3;&#x30F3;&#x30C8;&#x30E9;&#x30AF;&#x30C8;&#x9055;&#x53CD;&#x306E;&#x8981;&#x6C42;&#x3092;&#x9001;&#x4FE1;&#x3059;&#x308B;">
</p><p>コネクションを使い終わったら、明示的にコネクションを終了させるのがきまりです。クライアントが<code class="literal">stop/1</code> の呼び出しを忘れた場合や呼び出せない場合は、サーバーがコネクションのサーバー側のクリーンナップ処理を暗黙のうちに実行します。</p><p title="UBF&#x30B3;&#x30CD;&#x30AF;&#x30B7;&#x30E7;&#x30F3;&#x3092;&#x30AF;&#x30ED;&#x30FC;&#x30BA;&#x3059;&#x308B;"><strong>UBFコネクションをクローズする. </strong>
</p><pre class="screen">(asdf@bb3)92&gt; ubf_client:stop(P1).
ok</pre><p title="UBF&#x30B3;&#x30CD;&#x30AF;&#x30B7;&#x30E7;&#x30F3;&#x3092;&#x30AF;&#x30ED;&#x30FC;&#x30BA;&#x3059;&#x308B;">
</p></div><div class="section" title="4.6. Java&#x7528;&#x306E;UBF&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;&#x30FB;&#x30E9;&#x30A4;&#x30D6;&#x30E9;&#x30EA;&#x306E;&#x4F7F;&#x7528;&#x6CD5;"><div class="titlepage"><div><div><h3 class="title"><a id="using-ubf-java-client"></a>4.6. Java用のUBFクライアント・ライブラリの使用法</h3></div></div></div><p>Java用UBFクライアント・ライブラリのソースコードは、
<a class="ulink" href="http://github.com/norton/ubf" target="_top">http://github.com/norton/ubf</a>にあるUBFソース・リポジトリの<code class="literal">priv/java</code> サブディレクトリにあります。</p><div class="section" title="Java&#x7528;UBF&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;&#x30FB;&#x30E9;&#x30A4;&#x30D6;&#x30E9;&#x30EA;&#x306E;&#x30B3;&#x30F3;&#x30D1;&#x30A4;&#x30EB;"><div class="titlepage"><div><div><h4 class="title"><a id="_java&#x7528;ubf&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;_&#x30E9;&#x30A4;&#x30D6;&#x30E9;&#x30EA;&#x306E;&#x30B3;&#x30F3;&#x30D1;&#x30A4;&#x30EB;"></a>Java用UBFクライアント・ライブラリのコンパイル</h4></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
UBFクライアント・ライブラリのコードを、2010年5月10日以降の「マスター」版にアップデートしてください。またはGitのタグ「v1.14」以降のものを使用してください。2010年5月10日より前でタグが「v1.14」より前の版のライブラリにはいくつかバグがあり、UBFクライアントが正しく機能しません。
</li><li class="listitem">
ディレクトリを、UBFクライアント・ライブラリの配布ソースの<code class="literal">priv/java</code> ディレクトリに変更します。
</li><li class="listitem">
<code class="literal">make</code> を実行します。
</li><li class="listitem">
（オプション）<code class="literal">classes</code> サブディレクトリ内のクラス・ファイルを、自分のJava開発環境の適切なディレクトリにコピーします。
</li></ol></div></div><div class="section" title="UBF&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;&#x30FB;&#x30E9;&#x30A4;&#x30D6;&#x30E9;&#x30EA;&#x306E;&#x30C6;&#x30B9;&#x30C8;&#x30D7;&#x30ED;&#x30B0;&#x30E9;&#x30E0;HibariTest.java&#x306E;&#x30B3;&#x30F3;&#x30D1;&#x30A4;&#x30EB;"><div class="titlepage"><div><div><h4 class="title"><a id="_ubf&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;_&#x30E9;&#x30A4;&#x30D6;&#x30E9;&#x30EA;&#x306E;&#x30C6;&#x30B9;&#x30C8;&#x30D7;&#x30ED;&#x30B0;&#x30E9;&#x30E0;hibaritest_java&#x306E;&#x30B3;&#x30F3;&#x30D1;&#x30A4;&#x30EB;"></a>UBFクライアント・ライブラリのテストプログラムHibariTest.javaのコンパイル</h4></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
ディレクトリを、Hibariのソースコードのディストリビューション内の<code class="literal">gdss-ubf-proto/priv/java</code> サブディレクトリに変更します。
</li><li class="listitem">
<code class="literal">Makefile</code> を編集して、<code class="literal">UBF_CLASSES_DIR</code> 変数を、UBFパッケージのソースコードの<code class="literal">priv/java/classes</code> サブディレクトリ（または、該当するクラスの自分のシステムへの正式インストール先のサブディレクトリ）を指すものに変更します。
</li><li class="listitem"><p class="simpara">
次の2つの<code class="literal">make</code> コマンドを実行します。2つ目のコマンドは、HibariサーバーのUBFサーバーがローカルマシン（localhost）上にあると想定しています。
</p><pre class="screen">% make HibariTest
% make run-HibariTest</pre></li><li class="listitem">
Hibariサーバーがローカルマシン上で稼働していない場合は、<code class="literal">make -n run-HibariTest</code> を実行して、テストプログラムを実行するjavaコマンドを表示します。コマンドをシェルにカット・アンド・ペーストして、最後の引数がHibariサーバーのホスト名を指定するように編集してください。
</li></ol></div></div><div class="section" title="HibariTest.java&#x306E;&#x78BA;&#x8A8D;"><div class="titlepage"><div><div><h4 class="title"><a id="_hibaritest_java&#x306E;&#x78BA;&#x8A8D;"></a>HibariTest.javaの確認</h4></div></div></div><p><code class="literal">main()</code> 関数は次の3つの処理を行います。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
HibariサーバーへのUBFコネクションを新しく作成します。ホスト名/IPアドレスは、最初のコマンドの引数で指定します。さらにUBFメタプロトコル経由で<code class="literal">gdss</code> コントラクトを要求します。
</li><li class="listitem">
<code class="literal">test_hibari_basics()</code> メソッド内の小さなテストケースを実行します。
</li><li class="listitem">
UBFセッションをクローズして終了します。
</li></ol></div><p title="ubf.HibariTest.main()&#x30E1;&#x30BD;&#x30C3;&#x30C9;"><a id="the-ubf-hibaritest-main-method"></a><strong>ubf.HibariTest.main()メソッド. </strong>
</p><pre class="screen">public class HibariTest
{
    public static void main(String[] args)
        throws Exception
    {
        Socket sock = null;
        UBFClient ubf = null;

        try {
            sock = new Socket(args[0], 7581);
            ubf = UBFClient.new_via_sock(new UBFString("gdss"), new UBFList(),
                    new FooHandler(), sock);
        }
        catch (Exception e) {
            System.out.println(e);
            System.exit(1);
        }

        test_hibari_basics(ubf);

        ubf.stopSession();
        System.out.println("Success, it works");
        System.exit(0);
    }
/* ... */
}</pre><p title="ubf.HibariTest.main()&#x30E1;&#x30BD;&#x30C3;&#x30C9;">
</p><p><code class="literal">test_hibari_basics()</code> メソッドは、<a class="xref" href="#using-ubf-python-client" title="4.7. Python&#x7528;&#x306E;EBF&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;&#x30FB;&#x30E9;&#x30A4;&#x30D6;&#x30E9;&#x30EA;&#x306E;&#x4F7F;&#x7528;&#x6CD5;">「Python用のEBFクライアント・ライブラリの使用法」</a> に記述するPythonのEBFデモスクリプトと同じUBF基本操作を実行します。以下のデモプログラムはPythonのデモスクリプトとは異なり、Hibariの<code class="literal">do()</code> コマンドではなく、<code class="literal">get()</code> や<code class="literal">set()</code> のような単独操作のコマンドを使用しています。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
テーブル<code class="literal">tab1</code> から、キー <code class="literal">foo</code> を削除します。
</p><pre class="screen">    public static void test_hibari_basics(UBFClient ubf)
        throws IOException, UBFException
    {
        // setup
        UBFObject res1 = ubf.rpc(
                UBF.tuple( new UBFAtom("delete"), new UBFAtom("tab1"),
                            new UBFBinary("foo"), new UBFList(),
                            new UBFInteger(4000)));
        System.out.println("Res 1:" + res1.toString());</pre></li><li class="listitem"><p class="simpara">
テーブル<code class="literal">tab1</code> に、キー <code class="literal">foo</code> を追加します。
</p><pre class="screen">        // add - ok
        UBFObject res2 = ubf.rpc(
                UBF.tuple( new UBFAtom("add"), atom_tab1,
                            new UBFBinary("foo"), new UBFBinary("bar"),
                            new UBFInteger(0), new UBFList(),
                            new UBFInteger(4000)));
        System.out.println("Res 2:" + res2.toString());
        if (! res2.equals(atom_ok))
            System.exit(1);</pre></li><li class="listitem"><p class="simpara">
テーブル<code class="literal">tab1</code> に、キー <code class="literal">foo</code> を再度追加します。今回はエラーとなるはずです。
</p><pre class="screen">        // add - ng
        UBFObject res3 = ubf.rpc(
                UBF.tuple( new UBFAtom("add"), atom_tab1,
                            new UBFBinary("foo"), new UBFBinary("bar"),
                            new UBFInteger(0), new UBFList(),
                            new UBFInteger(4000)));
        System.out.println("Res 3:" + res3.toString());
        if (! ((UBFTuple)res3).value[0].equals(atom_key_exists))
            System.exit(1);</pre></li><li class="listitem"><p class="simpara">
テーブルtab1 から、キー「foo」を取得します。
</p><pre class="screen">        // get - ok
        UBFObject res4 = ubf.rpc(
                UBF.tuple( new UBFAtom("get"), atom_tab1,
                            new UBFBinary("foo"), new UBFList(),
                            new UBFInteger(4000)));
        System.out.println("Res 4:" + res4.toString());
        if (! ((UBFTuple)res4).value[0].equals(atom_ok) ||
            ! ((UBFTuple)res4).value[2].equals("bar"))
            System.exit(1);</pre></li><li class="listitem"><p class="simpara">
テーブル<code class="literal">tab1</code> に、キー <code class="literal">foo</code> とバリュー <code class="literal">bar bar</code> を設定します。
</p><pre class="screen">        // set - ok
        UBFObject res5 = ubf.rpc(
                UBF.tuple( new UBFAtom("set"), atom_tab1,
                            new UBFBinary("foo"), new UBFBinary("bar bar"),
                            new UBFInteger(0), new UBFList(),
                            new UBFInteger(4000)));
        System.out.println("Res 5:" + res5.toString());
        if (! res5.equals(atom_ok))
            System.exit(1);</pre></li><li class="listitem"><p class="simpara">
再度<code class="literal">foo</code> を読み出し、バリューが <code class="literal">bar bar</code> であることを確認します。
</p><pre class="screen">        // get - ok
        UBFObject res6 = ubf.rpc(
                UBF.tuple( new UBFAtom("get"), atom_tab1,
                            new UBFBinary("foo"), new UBFList(),
                            new UBFInteger(4000)));
        System.out.println("Res 6:" + res6.toString());
        if (! ((UBFTuple)res6).value[0].equals(atom_ok) ||
            ! ((UBFTuple)res6).value[2].equals("bar bar"))
            System.exit(1);</pre></li></ol></div></div><div class="section" title="UBF&#x306E;&#x30A4;&#x30D9;&#x30F3;&#x30C8;&#x30FB;&#x30CF;&#x30F3;&#x30C9;&#x30E9;&#x30FC;&#x306E;&#x30A4;&#x30F3;&#x30BF;&#x30FC;&#x30D5;&#x30A7;&#x30A4;&#x30B9;"><div class="titlepage"><div><div><h4 class="title"><a id="_ubf&#x306E;&#x30A4;&#x30D9;&#x30F3;&#x30C8;_&#x30CF;&#x30F3;&#x30C9;&#x30E9;&#x30FC;&#x306E;&#x30A4;&#x30F3;&#x30BF;&#x30FC;&#x30D5;&#x30A7;&#x30A4;&#x30B9;"></a>UBFのイベント・ハンドラーのインターフェイス</h4></div></div></div><p><code class="literal">UBFClient</code> の各インスタンスは、個別のスレッドを用いてサーバーからデータを読み出し、次のいずれかを実行します。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
同期RPCの応答をサーバーから受信したというシグナルを他のスレッドに送ります。
</li><li class="listitem">
サーバーから <code class="literal">event_out</code> 非同期イベントを受信した場合は、コールバック機能を実行します。
</li><li class="listitem">
ソケットをそのままクローズします。
</li></ol></div><p>2番目と3番目は、<code class="literal">UBFEventHandler</code> インターフェイスを実装するクラスを用いて、この場合に実行するアクションを定義します。</p><p><code class="literal">HibariTest.java</code> は、非同期イベントに対応するコールバック機能のサンプルを実装しています。実際のアプリケーションでは、このサンプルよりずっと多くの処理が必要です。</p><pre class="screen">    public static class FooHandler implements UBFEventHandler {
        public FooHandler() {
        }
        public void handleEvent(UBFClient client, UBFObject event) {
            System.out.println("Hey, got an event: " + event.toString());
        }
        public void connectionClosed(UBFClient client) {
            System.out.println("Hey, connection closed, ignoring it¥n");
        }
    }</pre><div class="tip" title="&#x30D2;&#x30F3;&#x30C8;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x30D2;&#x30F3;&#x30C8;]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>この<code class="literal">FooHandler</code> クラスの使用例は、<a class="xref" href="#the-ubf-hibaritest-main-method" title="ubf.HibariTest.main()&#x30E1;&#x30BD;&#x30C3;&#x30C9;">ubf.HibariTest.main()メソッド</a> を参照してください。</p></td></tr></table></div></div></div><div class="section" title="4.7. Python&#x7528;&#x306E;EBF&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;&#x30FB;&#x30E9;&#x30A4;&#x30D6;&#x30E9;&#x30EA;&#x306E;&#x4F7F;&#x7528;&#x6CD5;"><div class="titlepage"><div><div><h3 class="title"><a id="using-ubf-python-client"></a>4.7. Python用のEBFクライアント・ライブラリの使用法</h3></div></div></div><p>Python用のEBFクライアント・ライブラリのソースコードは、<a class="ulink" href="http://github.com/norton/ubf" target="_top">http://github.com/norton/ubf</a>にあるUBFソース・リポジトリの<code class="literal">priv/python</code> サブディレクトリにあります。</p><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>EBFプロトコルは、UBFと非常に密接な関連があることを思い出してください。唯一の大きな違いは、「レイヤー5」のセッション・プロトコル層です。ここでは、UBF(A)を使用する代わりにEBF (Erlang Binary Format) プロトコルを使用しています。詳細は<a class="xref" href="#hibari-server-impl-of-ubf-proto-stack" title="4.1. Hibari&#x30B5;&#x30FC;&#x30D0;&#x30FC;&#x306B;&#x304A;&#x3051;&#x308B;UBF&#x30D7;&#x30ED;&#x30C8;&#x30B3;&#x30EB;&#x5C64;&#x306E;&#x5B9F;&#x88C5;">「HibariサーバーにおけるUBFプロトコル層の実装」</a>  を参照してください。</p></td></tr></table></div><p>さらに、Tomas Abrahamssonらが開発した「py_interface」パッケージが必要です。「py_interface」は、<a class="ulink" href="http://www.fsf.org/licensing/education/licenses/lgpl.html" target="_top">GNU Library General Public License</a>の下で配布されています。Gitのリポジトリは、repo.or.czにあります。それをコピーしてビルドするには、以下を使用します。</p><pre class="screen">git clone git://repo.or.cz/py_interface.git
cd py_interface
autoconf
./configure
make
pwd</pre><p>最後のコマンドのアウトプット<code class="literal">pwd</code> を使用して、「py-interface」ライブラリへの完全なディレクトリ・パスを記憶します。下記の例は、パスが<code class="literal">/tmp/py-interface</code> であると想定しています。</p><p><code class="literal">pyebf.py</code> ファイルには、HibariのUBFコントラクトの<code class="literal">do_req()</code> コマンドを数回呼び出す小さな単体テストが入っています。ほとんどすべてのコマンドの実行結果は、 <code class="literal">assert</code> 関数で確認します。</p><pre class="screen">env PYTHONPATH=/path/to/py_interface python pyebf.py</pre><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
「localhost」のTCPポート7580のHibariサーバーに接続し、UBFメタプロトコルを用いて、gdssコントラクトに切り替えます。
</p><pre class="screen">    ## login
    ebf.login('gdss', 'gdss_meta_server')</pre></li><li class="listitem"><p class="simpara">
テーブル <code class="literal">tab1</code> から、キー <code class="literal">'foo'</code> を削除します。
</p><pre class="screen">    ## setup
    req0 = (Atom('do'), Atom('tab1'), [(Atom('delete'), 'foo', [])], [], 1000)
    res0 = ebf.rpc('gdss', req0)</pre></li><li class="listitem"><p class="simpara">
テーブル <code class="literal">tab1</code> から、キー <code class="literal">'foo'</code> を取得します。
</p><pre class="screen">    ## get - ng
    req1 = (Atom('do'), Atom('tab1'), [(Atom('get'), 'foo', [])], [], 1000)
    res1 = ebf.rpc('gdss', req1)
    assert res1[0] == 'key_not_exist'</pre></li><li class="listitem"><p class="simpara">
テーブル <code class="literal">tab1</code> に、キー <code class="literal">'foo'</code> を追加します。 <code class="literal">do_req()</code> インターフェイスは、クライアントがタイムスタンプの整数を明示的に管理しなければならず、ここではタイムスタンプとして <code class="literal">1</code> を使用しています。
</p><pre class="screen">    ## add - ok
    req2 = (Atom('do'), Atom('tab1'), [(Atom('add'), 'foo', 1, 'bar', 0, [])], [
], 1000)
    res2 = ebf.rpc('gdss', req2)
    assert res2[0] == 'ok'</pre></li><li class="listitem"><p class="simpara">
テーブル <code class="literal">tab1</code> に、キー <code class="literal">'foo'</code> を追加します。
</p><pre class="screen">    ## add - ng
    req3 = (Atom('do'), Atom('tab1'), [(Atom('add'), 'foo', 1, 'bar', 0, [])], [], 1000)
    res3 = ebf.rpc('gdss', req3)
    assert res3[0][0] == 'key_exists'
    assert res3[0][1] == 1</pre></li><li class="listitem"><p class="simpara">
テーブル <code class="literal">tab1</code> から、キー <code class="literal">'foo'</code> を取得し、タイムスタンプがまだ <code class="literal">1</code> でバリューが <code class="literal">bar</code> のままであることを確認します。
</p><pre class="screen">    ## get - ok
    req4 = (Atom('do'), Atom('tab1'), [(Atom('get'), 'foo', [])], [], 1000)
    res4 = ebf.rpc('gdss', req4)
    assert res4[0][0] == 'ok'
    assert res4[0][1] == 1
    assert res4[0][2] == 'bar'</pre></li><li class="listitem"><p class="simpara">
テーブル<code class="literal">tab1</code> に、キー <code class="literal">'foo'</code> を設定します。その際、新しいタイムスタンプとして<code class="literal">2</code> を用います。
</p><pre class="screen">    ## set - ok
    req5 = (Atom('do'), Atom('tab1'), [(Atom('set'), 'foo', 2, 'baz', 0, [])], [], 1000)
    res5 = ebf.rpc('gdss', req5)
    assert res5[0] == 'ok'</pre></li><li class="listitem"><p class="simpara">
テーブル<code class="literal">tab1</code> から、キー <code class="literal">'foo'</code> を取得し、タイムスタンプとバリューが両方とも新しく更新されていることを確認します。
</p><pre class="screen">    ## get - ok
    req6 = (Atom('do'), Atom('tab1'), [(Atom('get'), 'foo', [])], [], 1000)
    res6 = ebf.rpc('gdss', req6)
    assert res6[0][0] == 'ok'
    assert res6[0][1] == 2
    assert res6[0][2] == 'baz'</pre></li></ol></div></div></div><div class="section" title="5. &#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;API&#xFF1A; Thrift"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="client-api-tbf"></a>5. クライアントAPI： Thrift</h2></div></div></div><p>「TBF」は、UBFコントラクトが規定する<a class="ulink" href="https://github.com/apache/thrift" target="_top">Thriftプロトコル</a>です（<a class="xref" href="#the-hibari-ubf-protocol-contract" title="4.4. Hibari&#x306E;UBF&#x30D7;&#x30ED;&#x30C8;&#x30B3;&#x30EB;&#x30FB;&#x30B3;&#x30F3;&#x30C8;&#x30E9;&#x30AF;&#x30C8;">「HibariのUBFプロトコル・コントラクト」</a> 参照）。本章では、HibariのThrift APIについて説明します。ユーザーはこのAPIを使ってThriftクライアントからHibariにアクセスできます。Thrift がサポートするものであれば、プログラミング言語は問いません。さらに、アプリケーションの用途に応じてAPIを拡張する方法についても説明します。</p><div class="section" title="5.1. Hibari&#x306E;Thrift API"><div class="titlepage"><div><div><h3 class="title"><a id="_hibari&#x306E;thrift_api"></a>5.1. HibariのThrift API</h3></div></div></div><p>HibariのThrift APIは、<a class="ulink" href="./misc-codes/hibari.thrift" target="_top">hibari.thrift</a> 中にHibariサービスとして規定されています。このAPIの開発時に利用できたのはThrift 0.4.0だけでした。私たちが初めて採用したのはこのバージョンです。まだサポートしていない関数やオプションもあります。</p><p>IMPORTANT:HibariのThrift APIがサポートするのは、Thrift 0.4.0以上のみです。</p><pre class="screen">service Hibari {

  /**
   * Check connection availability / keepalive
   */
  oneway void keepalive()

  /**
   * Hibari Server Info
   */
  string info()

  /**
   * Hibari Description
   */
  string description()

  /**
   * Hibari Contract
   */
  string contract()

  /**
   * Add
   */
  HibariResponse Add(1: Add request)
      throws (1:HibariException ouch)

  /**
   * Replace
   */
  HibariResponse Replace(1: Replace request)
      throws (1:HibariException ouch)

  /**
   * Set
   */
  HibariResponse Set(1: Set request)
      throws (1:HibariException ouch)

  /**
   * Delete
   */
  HibariResponse Delete(1: Delete request)
      throws (1:HibariException ouch)

  /**
   * Get
   */
  HibariResponse Get(1: Get request)
      throws (1:HibariException ouch)
}</pre><p>各基本ユーティリティ関数には、インプット用の引数が1つだけあります。この引数は機能に対応する名前を持つオブジェクトです。このオブジェクトが、Hibariに対して必須の引数も任意の引数もすべて引き渡します。将来は、このオブジェクトを利用してマイクロ・トランザクションを実装する予定です。</p></div><div class="section" title="5.2. UBF&#x30B3;&#x30F3;&#x30C8;&#x30E9;&#x30AF;&#x30C8;&#x578B;&#x3068;Thrift&#x578B;&#x3068;&#x306E;&#x30DE;&#x30C3;&#x30D4;&#x30F3;&#x30B0;"><div class="titlepage"><div><div><h3 class="title"><a id="_ubf&#x30B3;&#x30F3;&#x30C8;&#x30E9;&#x30AF;&#x30C8;&#x578B;&#x3068;thrift&#x578B;&#x3068;&#x306E;&#x30DE;&#x30C3;&#x30D4;&#x30F3;&#x30B0;"></a>5.2. UBFコントラクト型とThrift型とのマッピング</h3></div></div></div><p>UBFとThriftの型変換の詳細に関しては、<a class="ulink" href="https://github.com/norton/ubf-thrift" target="_top">UBF-Thrift</a>を参照してください。</p></div><div class="section" title="5.3. UBF&#x30B3;&#x30F3;&#x30C8;&#x30E9;&#x30AF;&#x30C8;&#x3068;Thrift&#x30B5;&#x30FC;&#x30D3;&#x30B9;&#x3068;&#x306E;&#x30DE;&#x30C3;&#x30D4;&#x30F3;&#x30B0;"><div class="titlepage"><div><div><h3 class="title"><a id="_ubf&#x30B3;&#x30F3;&#x30C8;&#x30E9;&#x30AF;&#x30C8;&#x3068;thrift&#x30B5;&#x30FC;&#x30D3;&#x30B9;&#x3068;&#x306E;&#x30DE;&#x30C3;&#x30D4;&#x30F3;&#x30B0;"></a>5.3. UBFコントラクトとThriftサービスとのマッピング</h3></div></div></div><p>UBFの型をThriftの基本型にマッピングすることと、UBFのコントラクトをThriftのサービスにマッピングすることは、異なります。Thriftは主に2つの異なる型（structとfield）を用いて要求を組み立てます。</p><p>Thriftを使ってクライアント・コードを作成するとき、要求をどのように組み立てたらいいのか、心配する必要はありません。Thriftをインストールしてクライアント・コードを作成する方法については、<a class="ulink" href="http://wiki.apache.org/thrift/ThriftGeneration" target="_top">Thrift Wiki</a>を参照してください。また、着手にあたっては<a class="ulink" href="./misc-codes/hibari.thrift" target="_top">hibari.thrift</a>も必要です。</p><p>UBFのコントラクトに関心がある場合は、<code class="literal">ntbf_gdss_plugin.con</code> のファイル内にHibariのNTBFのコントラクトがあります。</p></div><div class="section" title="5.4. Thrift&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;&#x306E;&#x4F7F;&#x7528;&#x4F8B;"><div class="titlepage"><div><div><h3 class="title"><a id="_thrift&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;&#x306E;&#x4F7F;&#x7528;&#x4F8B;"></a>5.4. Thriftクライアントの使用例</h3></div></div></div><p>コードさえ作成できれば、Hibariに接続するのは簡単です。下記の例では、3つの言語で、テーブル<code class="literal">tab1</code> に、キー <code class="literal">'fookey'</code> とバリュー <code class="literal">'Hello, world!'</code> を追加しています。</p><p>Erlangの例：</p><pre class="screen">  -include("hibari_thrift.hrl").

  % init
  {ok, Client} = thrift_client:start_link("127.0.0.1", 7600, hibari_thrift),

  % create the input parameter object
  Request = #add{table=&lt;&lt;"tab1"&gt;&gt;, key=&lt;&lt;"fookey"&gt;&gt;, value=&lt;&lt;"Hello, world!"&gt;},

  % send request
  try
    HibariResponse = thrift_client:call(Client, 'Add', [Request]),
  catch
    HibariException -&gt;
      HibariException
  end,

  ok = thrift_client:close(Client).</pre><p>Javaの例：</p><pre class="screen">  import com.hibari.rpc.*;

  // init
  TTransport transport = new TSocket("127.0.0.1", 7600);
  TProtocol proto = new TBinaryProtocol(transport);
  Hibari.Client client = new Hibari.Client(proto);
  transport.open();

  // create the input parameter object
  Add request = new Add("tab1", ByteBuffer.wrap("fookey".getBytes()),
    ByteBuffer.wrap("Hello, world!".getBytes())))

  // send request
  try {
    HibariResponse response = client.Add(request);
  } catch (HibariException e) {
    // ...
  }

  transport.close();</pre><p>Pythonの例：</p><pre class="screen">  from hibari import Hibari

  # init
  transport = TSocket.TSocket('localhost', 7600)
  transport.setTimeout(None)
  transport = TTransport.TBufferedTransport(transport)
  protocol = TBinaryProtocol.TBinaryProtocol(transport)
  client = Hibari.Client(protocol)
  transport.open()

  # create the input parameter object
  request = Add()
  request.table = "tab1"
  request.key = b"fookey"
  request.value = b"Hello, world!"

  # send request
  response = client.Add(request)

  transport.close()</pre></div><div class="section" title="5.5. Thrift &#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;&#x304B;&#x3089;&#x306E;TBF&#x30B3;&#x30F3;&#x30C8;&#x30E9;&#x30AF;&#x30C8;&#x5FDC;&#x7B54;&#x306E;&#x30DE;&#x30C3;&#x30D4;&#x30F3;&#x30B0;"><div class="titlepage"><div><div><h3 class="title"><a id="_thrift_&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;&#x304B;&#x3089;&#x306E;tbf&#x30B3;&#x30F3;&#x30C8;&#x30E9;&#x30AF;&#x30C8;&#x5FDC;&#x7B54;&#x306E;&#x30DE;&#x30C3;&#x30D4;&#x30F3;&#x30B0;"></a>5.5. Thrift クライアントからのTBFコントラクト応答のマッピング</h3></div></div></div><p>TBFは、HibariのThrift APIのすべての関数に対して、2つの汎用型（HibariResponseとHibariException）のうち1つを返します。正常終了の場合はHibariResponseが返ることが期待できますが、そうでない場合は、HibariExceptionが返ることになっています。</p></div></div><div class="section" title="6. &#x958B;&#x767A;&#x8005;&#x5411;&#x3051;&#x30E6;&#x30FC;&#x30C6;&#x30A3;&#x30EA;&#x30C6;&#x30A3;"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_&#x958B;&#x767A;&#x8005;&#x5411;&#x3051;&#x30E6;&#x30FC;&#x30C6;&#x30A3;&#x30EA;&#x30C6;&#x30A3;"></a>6. 開発者向けユーティリティ</h2></div></div></div><p><span class="emphasis"><em>（作成中）</em></span></p><div class="section" title="6.1. Basho Bench"><div class="titlepage"><div><div><h3 class="title"><a id="_basho_bench"></a>6.1. Basho Bench</h3></div></div></div><p><span class="emphasis"><em>（追加予定）</em></span></p></div><div class="section" title="6.2. Yahoo! &#x30AF;&#x30E9;&#x30A6;&#x30C9;&#x30FB;&#x30B5;&#x30FC;&#x30D3;&#x30B9;&#x30FB;&#x30D9;&#x30F3;&#x30C1;&#x30DE;&#x30FC;&#x30AF;"><div class="titlepage"><div><div><h3 class="title"><a id="_yahoo_&#x30AF;&#x30E9;&#x30A6;&#x30C9;_&#x30B5;&#x30FC;&#x30D3;&#x30B9;_&#x30D9;&#x30F3;&#x30C1;&#x30DE;&#x30FC;&#x30AF;"></a>6.2. Yahoo! クラウド・サービス・ベンチマーク</h3></div></div></div><p><span class="emphasis"><em>（追加予定）</em></span></p></div></div><div class="section" title="7. &#x30BD;&#x30FC;&#x30B9;&#x30B3;&#x30FC;&#x30C9;&#x304B;&#x3089;Hibari&#x3092;&#x30D3;&#x30EB;&#x30C9;&#x3059;&#x308B;"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="HibariBuildingSource"></a>7. ソースコードからHibariをビルドする</h2></div></div></div><p>この章では、以下をビルドするための基本的な方法を説明します。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Hibari リリースパッケージ
</li><li class="listitem">
Hibari ドキュメント
</li><li class="listitem">
Erlang/OTP システム
</li></ul></div><div class="section" title="7.1. &#x5FC5;&#x8981;&#x306A;&#x30B5;&#x30FC;&#x30C9;&#x30D1;&#x30FC;&#x30C6;&#x30A3;&#x306E;&#x30BD;&#x30D5;&#x30C8;&#x30A6;&#x30A7;&#x30A2;"><div class="titlepage"><div><div><h3 class="title"><a id="_&#x5FC5;&#x8981;&#x306A;&#x30B5;&#x30FC;&#x30C9;&#x30D1;&#x30FC;&#x30C6;&#x30A3;&#x306E;&#x30BD;&#x30D5;&#x30C8;&#x30A6;&#x30A7;&#x30A2;"></a>7.1. 必要なサードパーティのソフトウェア</h3></div></div></div><p>事前準備として、ツールとソフトウェアのチェックリストをよく読み、必要に応じてインストールとセットアップを行ってください。</p><div class="section" title="&#x5FC5;&#x9808;&#x30A2;&#x30A4;&#x30C6;&#x30E0; (Hibari&#x3092;&#x30D3;&#x30EB;&#x30C9;&#x3059;&#x308B;&#x305F;&#x3081;&#x306B;&#x5FC5;&#x8981;&#x306A;&#x30BD;&#x30D5;&#x30C8;&#x30A6;&#x30A7;&#x30A2;)"><div class="titlepage"><div><div><h4 class="title"><a id="_&#x5FC5;&#x9808;&#x30A2;&#x30A4;&#x30C6;&#x30E0;_hibari&#x3092;&#x30D3;&#x30EB;&#x30C9;&#x3059;&#x308B;&#x305F;&#x3081;&#x306B;&#x5FC5;&#x8981;&#x306A;&#x30BD;&#x30D5;&#x30C8;&#x30A6;&#x30A7;&#x30A2;"></a>必須アイテム (Hibariをビルドするために必要なソフトウェア)</h4></div></div></div><p>Hibariのダウンロード、およびリリースパッケージのビルドには、以下のソフトウェアが必要です。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
Git - <a class="ulink" href="http://git-scm.com/" target="_top">http://git-scm.com/</a>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
バージョン1.5.4以降を使用してください。
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
バージョン1.7.3.4 がHibariでテスト済みの最新バージョンです。
</li></ul></div></li><li class="listitem"><p class="simpara">
Git用の電子メールアドレスと名前を設定していない場合は、以下のように設定してください。
</p><pre class="screen">$ git config --global user.email "you@example.com"
$ git config --global user.name "Your Name"</pre></li><li class="listitem">
GitHubアカウントを取得していない場合は、ここで取得してください。
</li></ul></div></li><li class="listitem"><p class="simpara">
<a class="ulink" href="https://github.com/" target="_top">https://github.com/</a>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
GITプロトコルを使った読み取り専用の匿名アクセスがデフォルトです。
</li><li class="listitem">
読み書きアクセス可能なメンバーには、GitHubアカウントにSSHの公開鍵を必ず追加してください。
</li></ul></div></li><li class="listitem"><p class="simpara">
Python - <a class="ulink" href="http://www.python.org" target="_top">http://www.python.org</a>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
バージョン2.4以降を使用してください。
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
バージョン2.7がHibariでテスト済みの最新バージョンです。
</li><li class="listitem">
注意: Python 3.x には対応できていない可能性があります。
</li></ul></div></li></ul></div></li><li class="listitem"><p class="simpara">
Repo - <a class="ulink" href="http://source.android.com/source/git-repo.html" target="_top">http://source.android.com/source/git-repo.html</a>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
以下のようにインストールしてください。
</p><pre class="screen">$ mkdir -p ~/bin
$ wget -O - http://android.git.kernel.org/repo &gt; ~/bin/repo
$ chmod a+x ~/bin/repo</pre></li><li class="listitem">
ダウンロードおよびパッケージのプロセスでは、Rebar (<a class="ulink" href="https://github.com/basho/rebar/wiki" target="_top">https://github.com/basho/rebar/wiki</a>) も使用しますが、このツールはHibari Gitリポジトリに入っています。そのため、あらためてインストールする必要はありません。
</li></ul></div></li><li class="listitem"><p class="simpara">
OpenSSL - <a class="ulink" href="http://www.openssl.org/" target="_top">http://www.openssl.org/</a>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
Erlangの “crypto” モジュールに必要です。
</li></ul></div></li><li class="listitem"><p class="simpara">
Erlang/OTP - <a class="ulink" href="http://www.erlang.org/" target="_top">http://www.erlang.org/</a>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
バージョンR13B04以降を使用してください。
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
R14B01がHibariでテスト済みの最新バージョンです。
</li></ul></div></li><li class="listitem">
ソースコードからErlang/OTPをビルドする方法は、 <a class="xref" href="#ErlangOTP" title="7.5. Erlang/OTP&#x3092;&#x30D3;&#x30EB;&#x30C9;&#x3057;&#x3066;&#x30A4;&#x30F3;&#x30B9;&#x30C8;&#x30FC;&#x30EB;&#x3059;&#x308B;">「Erlang/OTPをビルドしてインストールする」</a>を参照して下さい。
</li></ul></div></li></ul></div></div><div class="section" title="&#x30AA;&#x30D7;&#x30B7;&#x30E7;&#x30F3;&#x30A2;&#x30A4;&#x30C6;&#x30E0;(Hibari&#x306E;&#x30C9;&#x30AD;&#x30E5;&#x30E1;&#x30F3;&#x30C8;&#x306E;&#x30D3;&#x30EB;&#x30C9;&#x306B;&#x5FC5;&#x8981;&#x306A;&#x30BD;&#x30D5;&#x30C8;&#x30A6;&#x30A7;&#x30A2;)"><div class="titlepage"><div><div><h4 class="title"><a id="_&#x30AA;&#x30D7;&#x30B7;&#x30E7;&#x30F3;&#x30A2;&#x30A4;&#x30C6;&#x30E0;_hibari&#x306E;&#x30C9;&#x30AD;&#x30E5;&#x30E1;&#x30F3;&#x30C8;&#x306E;&#x30D3;&#x30EB;&#x30C9;&#x306B;&#x5FC5;&#x8981;&#x306A;&#x30BD;&#x30D5;&#x30C8;&#x30A6;&#x30A7;&#x30A2;"></a>オプションアイテム(Hibariのドキュメントのビルドに必要なソフトウェア)</h4></div></div></div><p>以下のソフトウェアは、ソースコードからHibariのドキュメントをビルドしたい場合にのみ必要です。 (<a class="ulink" href="http://hibari.github.com/hibari-doc/" target="_top">http://hibari.github.com/hibari-doc/</a>) に、ドキュメントのオンライン版があるので参考にしてください。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
AsciiDoc - <a class="ulink" href="http://www.methods.co.nz/asciidoc/index.html" target="_top">http://www.methods.co.nz/asciidoc/index.html</a>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
バージョン8.6.1以降を使用してください。
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
バージョン8.6.4がHibariでテスト済みの最新バージョンです。
</li></ul></div></li><li class="listitem"><p class="simpara">
その他にも、以下のサポートツールが必要です。
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
ImageMagick - <a class="ulink" href="http://www.imagemagick.org/" target="_top">http://www.imagemagick.org/</a>
</li><li class="listitem">
Graphviz - <a class="ulink" href="http://www.graphviz.org/" target="_top">http://www.graphviz.org/</a>
</li><li class="listitem">
Mscgen - <a class="ulink" href="http://www.mcternan.me.uk/mscgen/" target="_top">http://www.mcternan.me.uk/mscgen/</a>
</li><li class="listitem">
Dia - <a class="ulink" href="http://projects.gone.org/dia/" target="_top">http://projects.gone.org/dia/</a>
</li></ul></div></li></ul></div></li><li class="listitem"><p class="simpara">
dblatex - <a class="ulink" href="http://dblatex.sourceforge.net/" target="_top">http://dblatex.sourceforge.net/</a>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
HibariドキュメントのPDF版をビルドする際に必要なオプションです。
</li></ul></div></li><li class="listitem"><p class="simpara">
w3m - <a class="ulink" href="http://w3m.sourceforge.net/" target="_top">http://w3m.sourceforge.net/</a>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
Hibariドキュメントのテキストバージョンをビルドする際に必要なオプションです。
</li></ul></div></li></ul></div></div></div><div class="section" title="7.2. Hibari&#x3092;&#x30C0;&#x30A6;&#x30F3;&#x30ED;&#x30FC;&#x30C9;&#x3059;&#x308B;"><div class="titlepage"><div><div><h3 class="title"><a id="_hibari&#x3092;&#x30C0;&#x30A6;&#x30F3;&#x30ED;&#x30FC;&#x30C9;&#x3059;&#x308B;"></a>7.2. Hibariをダウンロードする</h3></div></div></div><p>以下の手順に従って、GitHubからHibariリポジトリをダウンロードします。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
作業ディレクトリを作成し、Hibariマニフェストファイルを読み出します。
</p><pre class="screen">$ mkdir working-directory
$ cd working-directory
$ repo init -u git://github.com/hibari/manifests.git -m hibari-default.xml</pre><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>repo initでは、"Git" IDが必要です。このIDを取得済みの場合は、GitHubアカウントの名前とemailを入力してください。読み書きアクセス可能なメンバーは、
"repo init -u
<a class="ulink" href="mailto:git@github.com" target="_top">git@github.com</a>:hibari/manifests.git -m hibari-default-rw.xml" を使用してください。</p></td></tr></table></div><div class="tip" title="&#x30D2;&#x30F3;&#x30C8;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x30D2;&#x30F3;&#x30C8;]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Hibariの最新開発バージョンをチェックアウトしたい場合は、repo initコマンドに、" -b dev" を付けてください。</p></td></tr></table></div></li><li class="listitem"><p class="simpara">
HibariのGitリポジトリをダウンロードします。
</p><pre class="screen">$ repo sync</pre><p class="simpara">repo syncを実行すると、作業ディレクトリの構造は以下のようになります。</p></li></ol></div><pre class="screen">&lt;working-directory&gt;
  |- hibari/
    |- .git/
    |- .gitignore
    |- Makefile
    |- dialyze-ignore-warnings.txt
    |- dialyze-nospec-ignore-warnings.txt
    |- lib/                             <a id="CO1-1"></a><img src="images/icons/callouts/1.png" alt="1" border="0" />
      |- &lt;application_name&gt;/
        |- .git/
        |- .gitignore
        |- ebin/
        |- include/
          |- *.hrl
        |- priv/
        |- rebar.config
        |- src/
          |- &lt;application_name&gt;.app.src
          |- *.erl
        |- test/
          |- eunit/
            |- *.erl
          |- eqc/
            |- *.erl
      :
    |- rebar
    |- rebar.config
    |- rel/                             <a id="CO1-2"></a><img src="images/icons/callouts/2.png" alt="2" border="0" />
      |- files/
        |- app.config
        |- erl
        |- hibari
        |- hibari-admin
        |- nodetool
        |- nodetool-admin
        |- vm.args
      |- hibari/
        :
        |- releases/
          |- &lt;release_vsn&gt;/
            :
          :
        :
      |- reltool.config
  |- hibari-doc/                        <a id="CO1-3"></a><img src="images/icons/callouts/3.png" alt="3" border="0" />
    :
  |- manifests/                         <a id="CO1-4"></a><img src="images/icons/callouts/4.png" alt="4" border="0" />
    :
  |- patches/                           <a id="CO1-5"></a><img src="images/icons/callouts/5.png" alt="5" border="0" />
    :
  |- rebar/                             <a id="CO1-6"></a><img src="images/icons/callouts/6.png" alt="6" border="0" />
    :
  |- .repo/
    :</pre><p>&lt;1&gt;
アプリケーション
&lt;2&gt; リリース
&lt;3&gt;
ドキュメント
&lt;4&gt;
マニフェスト
&lt;5&gt;
パッチ
&lt;6&gt; Rebar</p></div><div class="section" title="7.3. Hibari&#x306E;&#x30EA;&#x30EA;&#x30FC;&#x30B9;&#x30D1;&#x30C3;&#x30B1;&#x30FC;&#x30B8;&#x3092;&#x30D3;&#x30EB;&#x30C9;&#x3059;&#x308B;"><div class="titlepage"><div><div><h3 class="title"><a id="_hibari&#x306E;&#x30EA;&#x30EA;&#x30FC;&#x30B9;&#x30D1;&#x30C3;&#x30B1;&#x30FC;&#x30B8;&#x3092;&#x30D3;&#x30EB;&#x30C9;&#x3059;&#x308B;"></a>7.3. Hibariのリリースパッケージをビルドする</h3></div></div></div><p>以下の手順に従って、Hibariのリリースパッケージをビルドします。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
_basic recipe_をビルドします。
</p><pre class="screen">$ cd working-directory/hibari
$ make</pre><div class="tip" title="&#x30D2;&#x30F3;&#x30C8;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x30D2;&#x30F3;&#x30C8;]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>"make: erl: Command not found" というメッセージが出た場合、 Erlang/OTPが確かにインストールされていること、および$PATH環境変数に"otp-installing-directory-name/bin" が追加されていることを確認してください。</p></td></tr></table></div></li><li class="listitem"><p class="simpara">
パッケージ化した_basic recipe_をリリースします。
</p><pre class="screen">$ cd working-directory/hibari
$ make package</pre><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>リリースパッケージのtarball "hibari-X.Y.Z-dev-ARCH-WORDSIZE.tgz" およびmd5sumファイル "hibari-X.Y.Z-dev-ARCH-WORDSIZE-md5sum.txt" が、作業ディレクトリ内に書き込まれます。<a class="xref" href="#getting-started" title="2. &#x306F;&#x3058;&#x3081;&#x306B;">「はじめに」</a>で説明したように、これらのファイルを使って、シングルノードまたはマルチノードのHibariのインストールを実行できます。</p></td></tr></table></div></li></ol></div></div><div class="section" title="7.4. Hibari&#x306E;&#x30C9;&#x30AD;&#x30E5;&#x30E1;&#x30F3;&#x30C8;&#x3092;&#x30D3;&#x30EB;&#x30C9;&#x3059;&#x308B;"><div class="titlepage"><div><div><h3 class="title"><a id="HibariAsciiDoc"></a>7.4. Hibariのドキュメントをビルドする</h3></div></div></div><p>以下の手順に従って、Hibariのドキュメントをビルドします。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
Hibariの "Guides" の _basic recipe_をビルドします。
</p><pre class="screen">$ cd working-directory/hibari-doc/src/hibari
$ make clean -OR- make realclean
$ make</pre></li><li class="listitem"><p class="simpara">
Hibariの "Website" の_basic recipe_をビルドします。
</p><pre class="screen">$ cd working-directory/hibari-doc/src/hibari/website
$ make clean -OR- make realclean
$ make</pre><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>"./public_html" ディレクトリに、 HTMLドキュメントが書き込まれます。</p></td></tr></table></div></li></ol></div><p>Hibariのドキュメントは、AsciiDocと、次の補助ツールを使って作成されます。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
ImageMagick
</li><li class="listitem">
dblatex
</li><li class="listitem">
Dia
</li><li class="listitem">
Graphviz
</li><li class="listitem">
Mscgen
</li><li class="listitem">
w3m
</li></ul></div><p>Hibariのドキュメントは、AsciiDocと、手で修正したa2xツールを使って生成できます。
lang-ja.confファイルは、lang-en.confファイルへのシンボリックリンクとして作成しました。</p><pre class="screen">$ diff -r -u 8.6.4-orig/bin/a2x.py 8.6.4/bin/a2x.py
--- 8.6.4-orig/bin/a2x.py      2011-04-24 00:50:26.000000000 +0900
+++ 8.6.4/bin/a2x.py   2011-04-24 00:35:55.000000000 +0900
@@ -156,7 +156,10 @@
 def shell_copy(src, dst):
     verbose('copying "%s" to "%s"' % (src,dst))
     if not OPTIONS.dry_run:
-        shutil.copy(src, dst)
+        try:
+            shutil.copy(src, dst)
+        except shutil.Error:
+            return

 def shell_rm(path):
     if not os.path.exists(path):
Only in 8.6.4/etc/asciidoc: lang-ja.conf</pre></div><div class="section" title="7.5. Erlang/OTP&#x3092;&#x30D3;&#x30EB;&#x30C9;&#x3057;&#x3066;&#x30A4;&#x30F3;&#x30B9;&#x30C8;&#x30FC;&#x30EB;&#x3059;&#x308B;"><div class="titlepage"><div><div><h3 class="title"><a id="ErlangOTP"></a>7.5. Erlang/OTPをビルドしてインストールする</h3></div></div></div><p>以下の手順に従ってソースコードをダウンロードし、Erlang/OTPをビルドします。続いてシステムをインストールします。以下の手順が基本的なやり方ですが、すべてのオプションに対応しているわけではありません。</p><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Erlang/OTP の設定とビルドを行う前に、システムに <span class="emphasis"><em>openssl-devel</em></span> パッケージがインストールされていることを確認してください。</p></td></tr></table></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
Erlang/OTPシステムのソースコードをダウンロードします。
</p><pre class="screen">$ cd working-directory
$ wget http://www.erlang.org/download/otp_src_R14B01.tar.gz</pre></li><li class="listitem"><p class="simpara">
Erlang/OTPシステムのソースコードを解凍します。
</p><pre class="screen">$ tar -xzf otp_src_R14B01.tar.gz</pre></li><li class="listitem"><p class="simpara">
Erlang/OTPを設定します。
</p><pre class="screen">$ cd working-directory/otp_src_R14B01
$ ./configure --prefix=otp-installing-directory-name</pre></li><li class="listitem"><p class="simpara">
Erlang/OTPをビルドします。
</p><pre class="screen">$ make</pre></li><li class="listitem"><p class="simpara">
Erlang/OTPをインストールします。
</p><pre class="screen">$ sudo make install</pre></li></ol></div><div class="caution" title="&#x6CE8;&#x610F;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x610F;]" src="images/icons/caution.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>"otp-installing-directory-name/bin" が$PATH環境変数に追加されたことを確認してください。
　　
== サンプル・アプリケーション
<span class="emphasis"><em>（作成中）</em></span></p></td></tr></table></div></div></div><div class="section" title="8. Hibari&#x3092;&#x3088;&#x308A;&#x4F7F;&#x3044;&#x3053;&#x306A;&#x3059;&#x305F;&#x3081;&#x306B;"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_hibari&#x3092;&#x3088;&#x308A;&#x4F7F;&#x3044;&#x3053;&#x306A;&#x3059;&#x305F;&#x3081;&#x306B;"></a>8. Hibariをより使いこなすために</h2></div></div></div><div class="section" title="8.1. GitHub&#x3068;Git&#x3068;Repo"><div class="titlepage"><div><div><h3 class="title"><a id="_github&#x3068;git&#x3068;repo"></a>8.1. GitHubとGitとRepo</h3></div></div></div><p><span class="emphasis"><em>（追加予定）</em></span></p><p>Hibariのすべての"プロジェクト" に関する作業ディレクトリをリストします。</p><pre class="screen">$ repo forall -c "pwd"</pre><div class="note" title="&#x6CE8;&#x8A18;" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[&#x6CE8;&#x8A18;]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>プロジェクトにはそれぞれ、対応するGitリポジトリとデフォルトの改訂版があります。詳細は "manifests/hibari-default.xml" ファイルを確認してください。</p></td></tr></table></div><p>新しいトピック（例：new-topic-name）のブランチを作成します。</p><pre class="screen">$ repo start new-topic-name `repo forall -c "pwd" | xargs echo`</pre><p>既存のトピック（例：topic-name）のブランチを中断します。</p><pre class="screen">$ repo abandon topic-name `repo forall -c "pwd" | xargs echo`</pre><p>マスター・ブランチを構成管理下に置き、チェックアウトします。</p><pre class="screen">$ repo forall -c "git branch --track master github/master"
$ repo forall -c "git checkout master"</pre><p>dev（開発）ブランチを構成管理下に置き、チェックアウトします。</p><pre class="screen">$ repo forall -c "git branch --track dev github/dev"
$ repo forall -c "git checkout dev"</pre></div><div class="section" title="8.2. &#x30B3;&#x30FC;&#x30C9;&#x3068;&#x30D6;&#x30E9;&#x30F3;&#x30C1;&#x3068;&#x30D0;&#x30FC;&#x30B8;&#x30E7;&#x30F3;&#x306E;&#x7BA1;&#x7406;"><div class="titlepage"><div><div><h3 class="title"><a id="_&#x30B3;&#x30FC;&#x30C9;&#x3068;&#x30D6;&#x30E9;&#x30F3;&#x30C1;&#x3068;&#x30D0;&#x30FC;&#x30B8;&#x30E7;&#x30F3;&#x306E;&#x7BA1;&#x7406;"></a>8.2. コードとブランチとバージョンの管理</h3></div></div></div><p><span class="emphasis"><em>（追加予定）</em></span></p></div><div class="section" title="8.3. &#x6587;&#x66F8;&#x5316;"><div class="titlepage"><div><div><h3 class="title"><a id="_&#x6587;&#x66F8;&#x5316;"></a>8.3. 文書化</h3></div></div></div><p><span class="emphasis"><em>（追加予定）</em></span></p></div><div class="section" title="8.4. &#x30D1;&#x30C3;&#x30C1;&#x306E;&#x63D0;&#x4F9B;"><div class="titlepage"><div><div><h3 class="title"><a id="_&#x30D1;&#x30C3;&#x30C1;&#x306E;&#x63D0;&#x4F9B;"></a>8.4. パッチの提供</h3></div></div></div><p><span class="emphasis"><em>（追加予定）</em></span></p></div></div></div></body></html>
