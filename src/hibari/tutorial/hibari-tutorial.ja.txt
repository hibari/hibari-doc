// -*- Doc -*-
// vim: set syntax=asciidoc:

= 2011Q2 Tutorial - Hibari Hands On *DRAFT*
:Author: Joseph Wayne Norton
:Email: norton@geminimobile.com
:Date: 2011/04/24
:Revision: 0.1
:Copyright: 2011 Gemini Mobile Technologies, Inc.  All rights reserved.
:incremental:

== Overview

Part 1::
- Hibari Overview
Part 2::
- Erlang Basics
- Native Client
- _UBF Basics (extra)_
- _UBF Client (extra)_
Part 3::
- Hibari Basics
- Hands On Exercises

== Part 1

- Hibari Overview

== Hibari Overview
// == はじめに

- Hibariは、商用に活用できる分散型のキー・バリュー・ビック・データ・ストアです。
- Hibariは、チェイン・レプリケーションとErlangにより、堅固で、高性能の分散型ストレージソリューションを提供します。
- Hibariは、データの一貫性を犠牲にすることなく、高いスループットと可用性を提供します。
- Hibariは、オープンソースであり、通信事業者向けに開発され、通信事業者の商用環境にて数百万のユーザーに利用されています。

== Hibari - 特徴
// ==はじめに

- 高いパフォーマンス。特に読み出しと大きなバリュー
- テーブル毎のオプションとして、RAM+diskベース か　disk-onlyバリューストレージ (#)
- キー毎の有効期限とキー毎のカスタム・メタデータをサポート
- 複数キーのレンジリミット内でのアトミック処理をサポート
- "test-and-set" タイプの運用を容易にするキー・タイムスタンプの仕組み
- システムを拡張する際の自動データ・リバランス
- ライブ・コード・アップグレードをサポート
- 複数クライアントAPIを実装

[role="incremental"]
_# per-key　オプションjが実装されているが、商用設定には未展開。_

==  Hibari - Erlangによる開発
// ====Erlangによる開発

- Hibariのサーバーは、完全にErlangで開発。HibariのクライアントはErlangでも、他のプログラミング言語でも開発可能。
- Erlangは、多目的プログラミング言語であり、信頼性ある高いパフォーマンスの分散システムをサポートするために特別に設計されたランタイム環境。
- Erlangの主な利点は、
  * Concurrency (同時並行性)
  * Distribution (分散)
  * Robustness (堅牢)
  * Portability (移植性)
  * ホット・コード・アップグレード
  * 予測可能なガベージコレクション

== Hibari - チェイン・レプリケーション
// ==== 高可用性と強い一貫性のためのチェイン・レプリケーション

image:images/chain_replication.png[]

- チェイン・レプリケーションは、データの一貫性を損なうことなく、冗長性と高可用性を提供する技術。
- 書き込みリクエストは、"head"　から "middle"、そして "tail" ブリックに。
- 読み出しリクエストは、"tail" ブリックに。
- チェインの長さは設定可能で、レプリケーションの度合を決める。
- コンシステント・ハッシングにより、キー・スペースは複数のストレージ "chains" 全体に分割される。
- 全てのキーやキーのプレフィックスはコンシステント・ハッシングに依存する。

== Hibari - 自動復旧
// ==== 高可用性と強い一貫性のためのチェイン・レプリケーション

image:images/automatic_failover.png[]

- Hibariは、チェインのなかの障害を検知し、自動的にメンバーブリックの役割を調整します。
- 仮に、ヘッド・ブリックがダウンした場合には、ミドル・ブリックが自動的にヘッド・ブリックの役割を引き受けます。
- 仮に、新しいヘッド・ブリックにも障害があった場合、残るブリックがヘッドとテイル両方の役割を行います。
- チェイン・レプリケーションの特性により、Hibariはブリック障害の際にも強い一貫性を提供できます。

== Hibari - 負荷分散
// ==== 高い可用性と強い一貫性のためのチェイン・レプリケーション
image:images/load_balanced_chains.png[]

- ヘッド・ブリックとテイル・ブリックはミドル・ブリックよりも大きな負荷がかかります。

- 物理的なマシン全体での役割とチェインの負荷分散は、ハードウェアリソースを有効に活用させます。

== Hibari - ノード障害
// ==== 高可用性と強い一貫性のためのチェイン・レプリケーション

image:images/automatic_failover_2.png[]

物理的なノード障害の場合、ブリックは自動的に役割をシフトし、それぞれのチェインはクライアントにサービスを提供し続けます。

チェイン・リペアのプロセス::
  1. 障害ノードが再開される。
  2. 障害ブリックが再開され、チェインのエンドに移される。
  3. 障害ブリックは、"公式テイル"に自身を修復する。
  4. 修復ブリックは元のポジションに戻され、通常サービスを再開する。

== Hibari - クラスター

image:images/cap-01.png[]

== Hibari - 負荷分散 (再)

image:images/chain-01.png[]

== Hibari - 管理サーバー

image:images/cap-02-admin.png[]

== Hibari - チェイン

image:images/cap-02-chain.png[]

== Hibari - クライアント

image:images/cap-02-client.png[]

== Hibari - 3 レイヤー

トップ・レイヤー:: コンシステント・ハッシング
ミドル・レイヤー:: チェイン・レプリケーション
ボトム・レイヤー:: ストレージ・ブリック

[role="incremental"]
image:images/logical-architecture1.png[]

== Hibari - コンシステント・ハッシング

- Hibari クライアントは、どのチェインがキーのオペレーションを取り扱うべきかを計算するアルゴリズムを利用します。
- クライアントは、Hibari管理サーバーからの更新を経由し、この情報を得ます。
- これらの更新は、大部分のユーズケースにおいて、クライアントにそのリクエストを正しいサーバーに直接送らせます。サーバーはクライアントの計算が正しいかを証明するアルゴリズムを利用します。
- 仮に、クライアントが誤ったブリックにオペレーションを送る場合、ブリックは正しいブリックにオペレーションを転送します。

== Hibari - チェイン・マイグレーション

image:images/chain-migration-3to4.png[]

データを再配置するきっかけ:

- チェインはクラスターから追加されるか、削除されます。
- ブリック・ハードウェアは変更されます。(例）ディスクかRAM容量の追加。
- テーブルのコンシステント・ハッシング・アルゴリズム設定における変更は、データ（定義により）を他のチェインに押し出します。

== Hibari - チェイン・マイグレーション (続)

image:images/migration-3to4.png[]

キー・ポイント::

- 一つの場所から他にデータを動かすことを最小限にする。
- サービスインパクトを最小限にするためのレート管理機能をサポートする。
- マイグレーションの前に、 "テスト" し、キー分散を"カスタマイズ" できること。

== Hibari - ログ先行書き込み

image:images/private-and-common-logs.png[]

- サーバー毎の共有 "common log"。  fsync() システムコール経由でサーバーノード内の全ての論理ブリックに永続的保証を提供する。
- ブリック毎の個別 "private logs"。  論理ブリックにおいてキーを認識する全てのメタデータは論理ブリックのprivate logに格納される。

== Hibari - クライアント API
// シンプルだが強力なクライアントAPI

キー・バリュー・ストアとして、HibariのコアデータモデルとクライアントAPIモデルは設計に際しシンプル。:

- blobベースのキー・バリュー・ペア
  * キー: 典型的に、 "/'　によってセパレートされるパスのような名前
  * バリュー: バイナリー　blobs (しばしば、 Erlang 用語によりシリアライズされる)
- オペレーション
 * 挿入 (add, set, replace)
  * 削除 (delete)
  * 検索 (get, get_many)
- 辞書配列ソートテーブル
- 個別のチェインにアトミックな "micro-transactions" の実装に（しばしば）利用されるキー・プレフィックス

== Hibari - クライアント API (続)
// シンプルだが強力なクライアント API

Hibariは、複数のクライアント API実装をサポート:

- Native Erlang
- Universal Binary Format (UBF/EBF)
- Thrift
- Amazon S3
- JSON-RPC

[role="incremental"]
Java, C/C++, Python, Ruby, Erlangを含む様々な言語におけるHibariクライアント・アプリケーション開発が可能

== Part 2

- 休憩 #1
  * 10 分休憩

- Erlang 基礎
- ネイティブ・クライアント
- _UBF 基礎 (追加)_
- _UBF クライアント (追加)_

== Erlang - 基本型
// ==== Erlang 基本データ型式

数:: 2種類の数値リテラル, *integers* と *floats*.

Atom::  *atom* はリテラルで、名前を持つ定数。atomは、小文字で開始する場合や、アルファベット、数値、アンダースコア (_),　や @以外の文字を含む場合には、シングル・クォート  (') で囲まれるべき
+
-----
hello
phone_number
'Monday'
'phone number'
'hello'
'phone_number'
-----

Bit String and Binary:: *bit string* は、非型式メモリーの領域を格納するために使われます。8で割り切れるビットからなるbit string は、 *binary* と呼ばれます。
+
-----
<<10,20>>
<<"ABC">>
-----

== Erlang - 複合型

Term:: あらゆるデータ型式のひとつのデータは、 *term* と呼ばれます。

Tuple:: *tuple* は、中括弧で囲まれる固定数をもつ複合データ型式です。:
+
-----
{Term1,...,TermN}
-----

List:: *list* は、鍵括弧で囲まれる変数をもつ複合データ型式です。:
+
-----
[Term1,...,TermN]
-----

String:: Stringsは、2重括弧 (") で囲まれますが、Erlangにおいては真のデータ型式ではありません。代わりに、string の"hello" は、
list [$h,$e,$l,$l,$o] に短縮されます。すなわち、 [104,101,108,108,111] です。

== Erlang - その他

Boolean:: Erlangには、Boolean データ型式はありません。代わりに、atomsの
`true` と`false` がBoolean values を表示するために使われます。

None or Null:: Erlangには、このような型式はありません。 しかし、atomの
'undefined' は、しばしば（慣習として）　この目的のために使われます。

Pid:: プロセス識別である pid　は、Erlangプロセスを識別します。

Reference:: reference は、Erlang ランタイムシステム独自の表現です。

Fun:: fun は、関数オブジェクトです。

[role="incremental"]
_... 数点追加_

== Erlang - 階乗プログラム

ファイル "math.erl" は次のプログラムを含みます。:

------
-module(math).
-export([fac/1]).

fac(N) when N > 0 -> N * fac(N-1);
fac(0) -> 1.
------

[role="incremental"]
このプログラムは、Erlang shellを使いながらコンパイルされ動作します。

[role="incremental"]
------
$ erl
Erlang R14B01 (erts-5.8.2) [source] [64-bit] [smp:2:2] [rq:2] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.8.2  (abort with ^G)
1> c(math).
{ok,math}
2> math:fac(25).
15511210043330985984000000
------

[role="incremental"]
強制終了させる ...

[role="incremental"]
------
3> math:fac(-1).
** exception error: no function clause matching math:fac(-1)
------

== Erlang - シーケンシャル・プログラム

Append::
+
------
append([],      L) -> L;
append([H | T], L) -> [H | append(T, L)].
------

[role="incremental"]
QuickSort::
+
------
qsort([]) -> [];
qsort([H | T]) ->
  qsort([ X || X <- T, X < H ]) ++
        [H] ++
        qsort([ X || X <- T, X >= H ]).
------

[role="incremental"]
Adder::
+
------
> Adder = fun(N) -> fun(X) -> X + N end end.
#Fun<erl_eval.6.13229925>
> G = Adder(10).
#Fun<erl_eval.6.13229925>
> G(5).
15
------

== Native Client - シングル・オペレーション
// == クライアント API: Native Erlang

brick_simple:add(Tab, Key, Value, ExpTime, Flags, Timeout):: => ok.
brick_simple:replace(Tab, Key, Value, ExpTime, Flags, Timeout):: => ok.
brick_simple:set(Tab, Key, Value, ExpTime, Flags, Timeout):: => ok.
brick_simple:get(Tab, Key, Flags, Timeout):: => `{'ok', timestamp(), val()}`.
brick_simple:get_many(Tab, Key, MaxNum, Flags, Timeout):: => `{ok, {[{key(), timestamp(), val()}], boolean()}}`.
brick_simple:delete(Tab, Key, Flags, Timeout):: => ok.

== Native Client - 複数オペレーション
// == クライアント API: Native Erlang

brick_simple:do(Tab, OpList, OpFlags, Timeout):: => [OpRes()].

Two flavors::
- normal - OpList
- micro-transaction - [`'txn'`|OpList]

[role="incremental"]
TIP: "シングル" オペレーションは、 do/4 機能を利用しながら実装されています(フードの下で）.

== Native Client - 共通引数
// == クライアント API: Native Erlang

 ::
*Tab*

- ノードの名前.
- 型式:
  * `Tab = table()`
  * `table() = atom()`

 ::
*Key*

- ペアのバリューに関連している、テーブルのキー
- Type:
  * `Key = key()`
  * `key() = iodata()`
  * `iodata() = iolist() | binary()`
  * `iolist()  = [char() | binary() | iolist()]`

NOTE: `Key` は、内部的に常にbinaryに変換されます。

== Native Client - 共通引数 (続)
// == クライアント API: Native Erlang

 ::
*Value*

- keyに紐づくValue.
- 型式:
  * `Value = val()`
  * `val() = iodata()`
  * `iodata() = iolist() | binary()`
  * `iolist()  = [char() | binary() | iolist()]`

 ::
*ExpTime*

- TUnix time_t() として表現される、keyが期限切れとなる時間
- オプション; defaults to 0 (no expiration).
- 型式:
  * `ExpTime = exp_time()`
  * `exp_time() = time_t()`
  * `time_t() = integer()`

== Native Client - Common Args (cont.)
// == クライアント API: Native Erlang

 ::
*Flags*

- データベースのkey-value ペアに関連するオペレーショナル・フラグとプロパティ・フラグのリスト。 カスタム・プロパティ・フラグの多用はRAMベースのストレージに起因し、抑制される。
- 型式:
  * `Flags = flags_list()`
  * `flags_list() = [do_op_flag() | property()]`
  * `do_op_flag() = {'testset', timestamp()}`
  * `timestamp() = integer()`
  * `property() = atom() | {term(), term()}`
- オペれーショナル・フラグ利用
  * `{'testset', timestamp()}`
    ** 既存の key's timestamp が`timestamp()`と正確に等しくない場合には、オペレーションは失敗する。マイクロ・トランザクション内で利用される場合には、keyのtimestampが、`timestamp()` と正確に等しくない場合には、トランザクションを停止

 ::
*Timeout*

- ミリ秒でオペレーション・タイムアウト
- オプション; defaults to 15000.
- 型式:
  * `Timeout = timeout()`
  * `timeout() = integer()`

== Native Client - Common Errs
// == クライアント API: Native Erlang

 ::
エラー・リターン

- `'key_not_exist'`
  * keyが存在しないため、オペレーションは失敗した。
- `{'key_exists',timestamp()}`
  * keyがすでに存在しているため、オペレーションは失敗した。
  * `timestamp() = integer()`
- `{'ts_error', timestamp()}`
  *  `{'testset', timestamp()}` フラグは使われており、timestampのミスマッチがあったため、オペレーションは失敗した。 リターンにおける`timestamp()` は、 既存の keyのtimestampの現在のバリュー。
  * `timestamp() = integer()`
- `'invalid_flag_present'`
  * `Flags` 印数に無効な `do_op_flag()` が見つかったため、オペレーションは失敗した。
    
- `'brick_not_available'`
  * このkey を受け持つチェインの長さが現在ゼロで利用できないためにオペレーションは失敗した。
- `{{'nodedown',node()},{'gen_server','call',term()}}`
  * リクエストを処理するサーバー・ブリックが停止したか、クライアントとサーバー間でネットワーク分断が起きたため、オペレーションは失敗した。管理サーバーが障害を検知し、チェイン修理を行うステップをとるという前提で、クライアントは短い遅延後にクエリを再送する。
  * `node() = atom()`
- Exit by timeout.

== Native Client - Get Flags
// == クライアント API: Native Erlang

- オペれーショナル・フラグ利用
  * `'get_all_attribs'`
    ** keyの全ての属性をリターン。`witness` flagとの組み合わせで利用され得る。
  * `'witness'`
    ** 結果として、バリューの blob をリターンさせない。このフラグは、ブリックがこのリクエストを満たすディスクアクセスを要求していないことを保証する。

== Native Client - Get Rets
// == クライアント API: Native Erlang

 ::
サクセス・リターン

- `{'ok', timestamp(), val()}`
  * デフォルトの反応
- `{'ok', timestamp()}`
  * get が`'witness'` を使うが、`'get_all_attribs'`を使わない場合のサクセス・リターン
- `{'ok', timestamp(), proplist()}`
  * get が `'witness'` と `'get_all_attribs'`の両方を使う場合のサクセス・リターン
- `{'ok', timestamp(), val(), exp_time(), proplist()}`
  * get が `'get_all_attribs'` だが `'witness'`でない場合のサクセス・リターン

NOTE: For proplists, `{val_len,Size::integer()}` always returned.

== Native Client - GetMany Flags
// == Client API: Native Erlang

- Operational flag usage
  * `'get_all_attribs'`
    ** Return all attributes of each key. May be used in combination
       with the `witness` flag.
  * `'witness'`
    ** Do not return the value blobs in the result. This flag will
       guarantee that the brick does not require disk access to
       satisfy this request.
  * `{'binary_prefix', binary()}`
    ** Return only keys that have a binary prefix that is exactly
       equal to `binary()`.
  * `{'max_bytes', integer()}`
    ** Return only as many keys as the sum of the sizes of their
       corresponding value blobs does not exceed `integer()` bytes.
       If this flag is not explicity specified in a client request,
       the value defaults to 2GB.
  * `{'max_num', integer()}`
    ** Maxinum number of keys to return. Defaults to 10. Note: This
       flag is duplicative of the MaxNum argument in purpose.

== Native Client - GetMany Rets
// == Client API: Native Erlang

 ::
Success returns

- `{ok, {[{key(), timestamp(), val()}], boolean()}}`
  * Default behavior.
- `{ok, {[{key(), timestamp()}], boolean()}}`
  * Success return when the `get_many` uses `'witness'` but not
    `'get_all_attribs'`.
- `{ok, {[{key(), timestamp(), proplist()}], boolean()}}`
  * Success return when the `get_many` uses both `'witness'` and
    `'get_all_attribs'`.
- `{ok, {[{key(), timestamp(), val(), exp_time(), proplist()}],
  boolean()}}`
  * Success return when the `get_many` uses `'get_all_attribs'` but
    not `'witness'`.

NOTE: `boolean()` indicates if the chain has more keys or not.

NOTE: For proplists, `{val_len,Size::integer()}` always returned.

== Native Client - Do Rets

 ::
Error returns

- `{txn_fail, [{integer(), do1_res_fail()}]}`
  * Operation failed because transaction semantics were used in the
    `do` request and one or more primitive operations within the
    transaction failed. The `integer()` identifies the failed
    primitive operation by its position within the request's
    `OpList`. For example, a 2 indicates that the second primitive
    listed in the request's `OpList` failed. Note that this position
    identifier does not count the `txn()` specifier at the start of
    the `OpList`.

== Part 3

- Intermission #2
  * 10 minute break

- Hibari Basics
- Hands On Exercises

== Hibari - Single Node Install
// === Installing a Single-Node Hibari System

- Create a directory
+
-----
$ mkdir running-directory
-----
+
- untar Hibari tarball package - "hibari-_X.Y.Z-DIST-ARCH-WORDSIZE_.tgz"
+
-----
$ tar -C running-directory -xvf hibari-X.Y.Z-DIST-ARCH-WORDSIZE.tgz
-----

- _X.Y.Z_ is the release version => "0.1.4"
- _DIST_ is the release distribution => "fedora14"
- _ARCH_ is the release architecture => "x86_64-unknown-linux-gnu"
- _WORDSIZE_ is the release wordsize => "64"

== Hibari - Single Node Start, Bootstrap, and Stop
// ==== Starting and Bootstrapping Hibari

- Start Hibari:
+
------
$ running-directory/hibari/bin/hibari start
------
+
- Bootstrap the system:
+
------
$ running-directory/hibari/bin/hibari-admin bootstrap
ok
------
+
- Stop Hibari (later when needed):
+
------
$ running-directory/hibari/bin/hibari stop
------

== Hibari - Verifying Status
// ==== Verifying Hibari

- Confirm that you can open the "Hibari Web Administration" page:
+
------
$ firefox http://127.0.0.1:23080 &
------
+
- Confirm that you can successfully ping the Hibari node:
+
------
$ running-directory/hibari/bin/hibari ping
pong
------

[role="incremental"]
TIP: A single-node Hibari system is hard-coded to listen on the
localhost address 127.0.0.1. Consequently the Hibari node is reachable
only from the node itself.

== Hibari - Remote Shell

- Connect to Hibari using Erlang's remote shell
+
------
$ running-directory/hibari/erts-5.8.2/bin/erl -name hogehoge@127.0.0.1 -setcookie hibari -kernel net_ticktime 20 -remsh hibari@127.0.0.1
Erlang R14B01 (erts-5.8.2) [source] [64-bit] [smp:2:2] [rq:2] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.8.2  (abort with ^G)
(hibari@127.0.0.1)1>
------
+
- Check your node name and the set of connected Erlang nodes.
+
------
(hibari@127.0.0.1)1> node().
'hibari@127.0.0.1'
(hibari@127.0.0.1)2> nodes().
['hogehoge@127.0.0.1']
(hibari@127.0.0.1)3>
------

[role="incremental"]
TIP: Hibari's name, cookie, and kernel net_ticktime are configurable
and located in the running-directory/hibari/etc/vm.args file.

[role="incremental"]
TIP: The "rlwrap -a running-directory/hibari/erts-5.8.2/bin/erl" tool
is helpful for keeping track of your Erlang shell history (e.g. yum
install rlwrap).

== Hibari - Creating New Tables
// === Creating New Tables

- Create a new table having a hash prefix of 2 and having 3 bricks per
  chain.
+
------
$ running-directory/hibari/bin/hibari-admin create-table tab2 \
    -bigdata -disklogging -syncwrites \
    -varprefix -varprefixsep 47 -varprefixnum 2 \
    -bricksperchain 3 \
    hibari@127.0.0.1 hibari@127.0.0.1 hibari@127.0.0.1
------
+
- For example, let's assume the first part of a key represent's a
  user's id.  A hash prefix of 2 makes the keys of each individual
  user to be stored on the same chain ... but not necessarily on the
  same chain as other user's keys.
+
------
  :
/user1/adir/
/user1/adir/file1
/user1/adir/file3
/user1/file1
/user1/file4
/user1/xdir/
/user1/xdir/fileY
  :
/user2/file1
  :
/user3/file4
  :
------

[role="incremental"]
TIP: Tables can also be created using Hibari's Admin Server
Webpage. Open `http://localhost:23080/` and click the "Add a table"
link.

== Hands On Exercises

The goal of these exercises is to learn more about Hibari and to
implement and to test your own Hibari mini-applications using Hibari's
Native Erlang Client.

== Hands On Exercises #1-A

. Install Hibari
. Start and Bootstrap Hibari
. Wait 15 seconds (or so) and then make a backup of Hibari's
   Schema.local file and data files:
+
------
$ tar -cvzf backup.tgz running-directory/hibari/Schema.local running-directory/hibari/data/brick
------
+
. Verify the status of Hibari
. Connect to Hibari using the Erlang shell
. Create tab2 as described above
. Open Hibari's Admin Server Webpage
. Make a list of what is the same and what is different between tab1
   and tab2.
. What other things can be learned from the Admin Server Webpage?

== Hands On Exercises #1-B

. Stop Hibari
. Delete Hibari's Schema.local and data files:
+
------
$ rm -r running-directory/hibari/Schema.local running-directory/hibari/data/brick/*
------
+
. Restore Hibari's Schema.local and data files:
+
------
$ tar -xvzf backup.tgz
------
+
. Start Hibari
. Verify the status of Hibari
. Open Hibari's Admin Server Webpage
. What tables exist now?
. Create tab2 (again) as described above.
. Stop and Start Hibari
  . Follow the status of the Chains and Bricks
  . What's happening?
  . What about the history of each Chain and/or Brick?

== Hands On Exercises #1-C

Using the Erlang Shell, repeat the examples listed in Hibari's
Application Developer Guide.

. http://hibari.github.com/hibari-doc/hibari-app-developer-guide.en.html#brick-simple-add[brick_simple:add/6]
. http://hibari.github.com/hibari-doc/hibari-app-developer-guide.en.html#brick-simple-replace[brick_simple:replace/6]
. http://hibari.github.com/hibari-doc/hibari-app-developer-guide.en.html#brick-simple-set[brick_simple:set/6]
. http://hibari.github.com/hibari-doc/hibari-app-developer-guide.en.html#brick-simple-get[brick_simple:get/4]
. http://hibari.github.com/hibari-doc/hibari-app-developer-guide.en.html#brick-simple-get_many[brick_simple:get_many/5]
. http://hibari.github.com/hibari-doc/hibari-app-developer-guide.en.html#brick-simple-delete[brick_simple:delete/4]

[role="incremental"]
What changes can be seen on Hibari's Admin Server Webpages during and
after doing these example exercises?

== Hands On Exercises #2

Implement a new API for Hibari but doing so on the client (and not
server) side.

rename(Tab, OldKey, Key, ExpTime, Flags, Timeout):: => `'ok'` |
`'key_not_exist'` | `{'ts_error', timestamp()}` | `{'key_exists',timestamp()}`


- This function renames an existing value corresponding to OldKey to
  new Key and deletes the OldKey.  Flags of the OldKey are ignored and
  replaced with the Flags argument (except for `'testset'` flag).
- If OldKey doesn't exist, return `'key_not_exist'`.
- If OldKey exists, Flags contains `{'testset', timestamp()}`, and
  there is a timestamp mismatch with the OldKey, return `{'ts_error',
  timestamp()}`.
- If Key exists, return `{'key_exists',timestamp()}`.

== Hands On Exercises #2 - Hints

. For your first implementation, don't worry about a transactional do/4
  operation.
. The Erlang/OTP `proplists:delete/2` and `proplists:get_value/3` can
  be used for Flags filtering.
. The `{'testset', timestamp()}` flag is your friend.
. If you are feeling adventurous, try implementing with a
  transactional do/4 operation.  What restrictions must then be placed
  on OldKey and Key?

== Hands On Exercises #3

Mnesia is a distributed Database Management System distributed with
Erlang/OTP. Mnesia supports a
http://www.erlang.org/doc/man/mnesia.html#dirty_update_counter-2[dirty_update_counter/3]
operation.  Implement a similiar API for Hibari but doing so on the
client (and not server) side.

update_counter(Tab, Key, Incr, Timeout):: => `{'ok', NewVal}` | `'invalid_arg_present'` | `{non_integer,timestamp()}` | exit by Timeout.


- This function updates a counter with a positive or negative
  integer. However, counters can never become less than zero.
- If Incr is not an integer, return `'invalid_arg_present'`.
- If two (or more) callers perform update_counter/3 simultaneously,
  both updates will take effect without the risk of losing one of the
  updates. The new value `{'ok', NewVal}` of the counter is returned.
- If Key doesn't exist, a new counter is created with the value Incr
  if it is larger than 0, otherwise it is set to 0.
- If Key exists but it's value is not an integer greater than or equal
  to zero, return {non_integer, timestamp()}.
- If updating of the counter exceeds the specified timeout, exit by
  Timeout.

== Hands On Exercises #3 - Hints

. The `{'testset', timestamp()}` flag is your friend.
. Use `if is_integer(X) -> ...; true -> ... end.` to check if a term is an
  integer or not.
. The erlang primitives `erlang:integer_to_binary/1` and
  `erlang:binary_to_integer/1` are very helpful (and necessary).
. The erlang primitive `erlang:now/0` and `timer:now_diff/2` can be
  used to create an absolute now time and to compare with a new
  abosolute now time, respectively.  Timeout is in milliseconds.  Now
  is in microseconds.

== Hands On Exercises #4 - Advanced

Implement a filesystem-like Client API using Hibari's Key-Value Data
Model.

mkdir(Tab, Path, Timeout):: => `'ok'` | `{'dir_exists', timestamp()}`.

listdir(Tab, Path, Timeout):: => `{'ok', Names}` | `'dir_not_exist'`.

rmdir(Tab, Path, Timeout):: => `'ok'` | `'dir_not_exist'` | `'dir_not_empty'`.

create(Tab, Path, Timeout):: => `'ok'` | `'dir_not_exist'` | `{'file_exists', timestamp()}`.

rmfile(Tab, Path, Timeout):: => `'ok'` | `'file_not_exist'`.

writefile(Tab, Path, Data, Timeout):: => `'ok'` | `'file_not_exist'`.

readfile(Tab, Path, Timeout):: => `{'ok', Data}` | `'file_not_exist'`.

== Hands On Exercises #4 - Hints

- How can you represent a file?
- How can you represent a directory?
- How can you find files within a certain directory? ... below a
  directory tree?
- How can you efficiently check if a directory is empty or not?
- How can test-n-set of timestamps be used?

== Thank You

Please check Hibari's GitHub repositories and webpages for updates.

[horizontal]
Hibari Open Source project:: https://github.com/hibari
Hibari Twitter:: @hibaridb Hashtag: #hibaridb
Gemini Twitter:: @geminimobile
Big Data blog:: http://hibari-gemini.blogspot.com/
Slideshare:: http://www.slideshare.net/geminimobile
