// -*- Doc -*-
// vim: set syntax=asciidoc:

= 2011Q2 Tutorial - Hibari Hands On
:Author: Joseph Wayne Norton
:Email: norton@geminimobile.com
:Date: 2011/04/24
:Revision: 0.1
:Copyright: 2011 Gemini Mobile Technologies, Inc.  All rights reserved.

== Overview

- Hibari Overview
- Erlang & UBF Basics
- Hibari Native Client API
- Hibari UBF Client API
- Hibari Basics
- Hands On Exercises

== Hibari Overview
// == Introduction

- Hibari is a production-ready, distributed, key-value, big data
  store.
- Hibari combines Chain Replication and Erlang to build a robust,
  high-performance distributed storage solution.
- Hibari delivers high throughput and availability without scarificing
  data consistency.
- Hibari is open source and built for the carrier-class telecom sector
  and proven in multi-million user telecom production environments.

== Hibari - Distinctive Features
// == Introduction

- Per-table options for RAM+disk-based or disk-only value storage (#)
- Support for per-key expiration times and per-key custom meta-data
- Support for multi-key atomic transactions, within range limits
- A key timestamping mechanism that facilitates "test-and-set" type
  operations
- Automatic data rebalancing as the system scales
- Support for live code upgrades
- Multiple client API implementations

_# per-key options have been implemented but not yet deployed in a
production setting._

==  Hibari - Engineered in Erlang
// ==== Engineered in Erlang

- Hibari's server is written entirely in Erlang.  Hibari clients may
  be written in Erlang and/or other programming languages.
- Erlang is a general purpose programming language and runtime
  environment designed specifically to support reliable,
  high-performance distributed systems.
- Erlang's Key Benefits are
  * Concurrency
  * Distribution
  * Robustness
  * Portability
  * Hot code upgrades
  * Predictable Garbage collection behavior

== Hibari - Chain Replication
// ==== Chain Replication for High Availability and Strong Consistency

image:images/chain_replication.png[]

- Chain Replication is a technique that achieves redundancy and high
  availability without sacrificing data consistency.
- Write requests are directed to "head", to "middle", and to "tail"
  bricks.
- Read requests are directed to the "tail" brick.
- The length of a chain is configurable and decides the degree of
  replication.
- Through consistent hashing, the key space is divided across multiple
  storage "chains".
- The entire key or a prefix of the key can be the subject of
  consistent hashing.

== Hibari - Automatic Failover
// ==== Chain Replication for High Availability and Strong Consistency

image:images/automatic_failover.png[]

- Hibari detects failures within a chain and automatically adjusts
  member brick roles.
- If the head brick goes down, the middle brick automatically takes
  over the head brick role.
- If the new head brick failed also, the long remaining brick would
  play both the head and the tail role.
- By following the properties of chain replication, Hibari can
  guarantee strong consistency even in the event of brick failures.

== Hibari - Load Balancing
// ==== Chain Replication for High Availability and Strong Consistency
image:images/load_balanced_chains.png[]

- Head bricks and tail bricks bear more load than do middle bricks.

- Load balancing of roles and of chains across physical machines can
  better utilize hardware resources.

== Hibari - Node Failure
// ==== Chain Replication for High Availability and Strong Consistency

image:images/automatic_failover_2.png[]

- In the event of physical node failure, bricks automatically shift
  roles and each chain continues to provide service to clients.
- Chain Repair Process
  1. Failed node is restarted.
  2. Failed bricks are restarted and moved to the end of the chain.
  3. Failed bricks repair themselves against the "official tail".
  4. Repaired bricks are moved to their original position and then
     resume normal service.

== Hibari - Cluster

image:images/cap-01.png[]

== Hibari - Load Balancing (again)

image:images/chain-01.png[]

== Hibari - Admin Server(s)

image:images/cap-02-admin.png[]

== Hibari - Chains

image:images/cap-02-chain.png[]

== Hibari - Clients

image:images/cap-02-client.png[]

== Hibari - 3 Layers

- Top layer:  consistent hashing
- Middle layer: chain replication
- Bottom layer: the storage brick

image:images/logical-architecture1.png[]

== Hibari - Consistent Hashing

- Hibari clients use the algorithm to calculate which chain must
  handle operations for a key.
- Clients obtain this information via updates from the Hibari Admin
  Server.
- These updates allow the client to send its request directly to the
  correct server in most use cases.  Servers use the algorithm to
  verify that the client's calculation was correct.
- If a client sends an operation to the wrong brick, the brick will
  forward the operation to the correct brick.

== Hibari - Chain Migration

image:images/chain-migration-3to4.png[]

Motivations for rebalancing of data:

- Chains are added or removed from the cluster.
- Brick hardware is changed, e.g. adding extra disk or RAM capacity.
- A change in a table's consistent hashing algorithm configuration
  forces data (by definition) to another chain.

== Hibari - Chain Migration (continued)

image:images/migration-3to4.png[]

Key Points:

- Minimize the moving of data from one place to another.
- Support rate control features to minimize service impact.
- Ability to "test" and to "customize" key distribution before
  migration.

== Hibari - Write-Ahead-Logs

image:images/private-and-common-logs.png[]

- The shared "common log" per server. Provides durability guarantees
  to all logical bricks within the server node via the fsync() system
  call.
- Individual "private logs" per brick. All metadata regarding keys in
  the logical brick are stored in the logical brick's private log.

== Hibari - Client APIs
// Simple But Powerful Client API

As a key-value store, Hibari's core data model and client API model
are simple by design:

- blob-based key-value pairs
  * keys: typically path-like names separated by "/'
  * values: binary blobs (often serialized Erlang terms)
- operations
  * insertion (add, set, replace)
  * deletion (delete)
  * retrieval (get, get_many)
- lexicographically sorted tables
- key prefixes (often) used for implementing atomic
  "micro-transactions" with individual chains

== Hibari - Client APIs (continued)
// Simple But Powerful Client API

Hibari supports multiple client API implementations:

- Native Erlang
- Universal Binary Format (UBF/EBF)
- Thrift
- Amazon S3
- JSON-RPC

You can develop Hibari client applications in a variety of languages
including Java, C/C++, Python, Ruby, and Erlang.

== Intermission #1

*10 minute Break*

== Erlang & UBF Basics
- point A

== Hibari Native Client API
- point A

== Hibari UBF Client API
- point A

== Intermission #2

*10 minute Break*

== Hibari Basics
- point A

== Hands On Exercises
- point A

== Thank You

Please check Hibari's GitHub repositories and webpages for updates.

// [horizontal]
// Hibari Open Source project:: https://github.com/hibari
// Hibari Twitter:: @hibaridb Hashtag: #hibaridb
// Gemini Twitter:: @geminimobile
// Big Data blog:: http://hibari-gemini.blogspot.com/
// Slideshare:: http://www.slideshare.net/geminimobile
